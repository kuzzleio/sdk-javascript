{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kuzzle.js","webpack:///webpack/bootstrap 8e46faa9aee312feeb8b","webpack:///./src/Kuzzle.js","webpack:///./src/eventEmitter/index.js","webpack:///./src/Document.js","webpack:///./src/security/SecurityDocument.js","webpack:///./src/networkWrapper/protocols/abstract/realtime.js","webpack:///./src/security/User.js","webpack:///./src/Room.js","webpack:///./src/SearchResult.js","webpack:///./src/networkWrapper/protocols/socketio.js","webpack:///./src/networkWrapper/protocols/websocket.js","webpack:///./src/Collection.js","webpack:///./src/CollectionMapping.js","webpack:///./src/MemoryStorage.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/security/Profile.js","webpack:///./src/security/Role.js","webpack:///./src/security/Security.js","webpack:///./~/uuid/lib/bytesToUuid.js","webpack:///./~/uuid/lib/rng-browser.js","webpack:///./~/uuid/v4.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","checkPropertyType","prop","typestr","wrongType","Array","isArray","_typeof","Error","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","uuidv4","KuzzleEventEmitter","Collection","Document","Security","MemoryStorage","User","networkWrapper","Kuzzle","_KuzzleEventEmitter","host","options","_this","eventActions","autoResubscribe","defaultIndex","jwt","protocol","sdkVersion","volatile","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","keys","next","done","opt","hasOwnProperty","err","return","room","opts","subscribeCB","_this2","requestId","controller","action","index","collection","body","filters","scope","state","users","notificationCB","data","type","unsetJwt","emit","copy","assign","document","result","_id","_source","_meta","notify","network","subscribe","unsubscribeCB","roomId","unsubscribe","channel","errorMessagePrefix","callback","eventTimeout","connected","timeout","error","disconnected","reconnected","tokenExpired","loginAttempt","autoQueue","set","autoReconnect","autoReplay","offlineQueue","offlineQueueLoader","port","queueFilter","queueMaxSize","queueTTL","replayInterval","reconnectionDelay","sslConnection","eumerable","ssl","addListener","query","bluebird","_ret","promisifyAll","suffix","filter","name","func","passes","whitelist","indexOf","eventName","_get2","now","Date","protectedEvent","protectedEvents","lastEmitted","_len","arguments","payload","_key","apply","concat","cb","_this3","connect","connectionError","internal","disconnect","checkToken","res","valid","on","token","success","JSON","stringify","strategy","_this4","request","expiresIn","queuable","response","message","setJwt","credentials","_this5","callbackRequired","_this6","security","hits","content","event","listener","toString","startTime","stopTime","_len2","args","_key2","queryCB","collections","flushQueue","_len3","_key3","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","arg","indexes","close","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","serverInfo","_len4","_key4","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_len5","_key5","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","autoRefresh","_len6","_key6","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","queryArgs","_arr","_i","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","attr","startQueuing","stopQueuing","playQueue","Listener","fn","once","_events","listeners","Boolean","find","map","listenerType","_exists","push","addOnceListener","prependListener","findIndex","l","splice","onceListeners","toDelete","removeListener","documentId","meta","dataCollection","kuzzle","version","_version","setContent","serialize","delete","buildQueryArgs","exists","refresh","newDocument","save","publish","replace","forEach","ids","values","SecurityDocument","deleteActionName","update","updateActionName","emitRequest","status","requestHistory","send","discardRequest","cleanQueue","lastDocumentIndex","ts","droppedRequest","dequeue","uniqueQueue","dequeuingProcess","shift","setTimeout","Math","max","additionalQueue","cleanHistory","RTWrapper","cleanHistoryTimer","queuing","offlineMode","wasConnected","stopRetryingToConnect","retrying","setInterval","clearHistoryTimer","fromSelf","removeAllListeners","clearInterval","KuzzleSecurityDocument","setProfiles","profileIds","setCredentials","addProfile","profileId","creationSerialize","saveRestricted","getProfileIds","getProfiles","fetchedProfiles","errored","fetchProfile","profile","Room","_roomId","roomstate","isListening","resubscribe","deactivate","resubscribeConditional","subscribeToSelf","count","onDone","SearchResult","raw","total","documents","doc","d","aggregations","from","size","scrollId","_scroll_id","fetched","freeze","includes","updateAfterSearch","scroll","sort","search_after","sortRule","search","SocketIO","_RTWrapper","socket","forceDisconnect","eventsWrapper","window","io","reconnection","forceNew","clientConnected","clientNetworkError","clientDisconnected","_addEventWrapper","off","wrapper","_event","Set","add","WebSocketClient","WSNode","WebSocket","e","code","client","lasturl","url","perMessageDeflate","onopen","onclose","closeEvent","reason","onerror","onmessage","parse","readyState","OPEN","blacklist","KuzzleSearchResult","CollectionMapping","createDocument","ifExist","deleteDocument","deleteSpecifications","documentExists","fetchDocument","getMapping","kuzzleMapping","mCreateDocument","mCreateOrReplaceDocument","mDeleteDocument","documentIds","mGetDocument","mReplaceDocument","mUpdateDocument","getSpecifications","publishMessage","replaceDocument","scrollSpecifications","searchSpecifications","evtName","truncate","updateDocument","retryOnConflict","updateSpecifications","specifications","validateSpecifications","collectionMapping","mapping","properties","mappings","field","assignParameter","assignGeoRadiusOptions","parsed","assignZrangeOptions","limit","mapGeoposResults","results","coords","latlon","parseFloat","mapGeoRadiusResults","point","coordinates","coord","distance","mapStringToArray","mapArrayStringToArrayInt","parseInt","mapNoResult","mapZrangeResults","buffer","mapped","member","score","mapScanResults","cursor","getId","required","getIdField","getKeys","getMember","getxScan","mapResults","getZrange","getZrangeBy","setId","setIdValue","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","geoadd","geodist","geohash","geopos","georadius","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","setex","setnx","sinter","sinterstore","sismember","smembers","smove","spop","srandmember","srem","sscan","strlen","sunion","sunionstore","time","touch","ttl","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","command","slice","pop","param","Profile","policies","addPolicy","policy","roleId","setPolicies","getPolicies","Role","fetchRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","role","searchProfiles","profiles","createProfile","updateProfile","updatedContent","deleteProfile","scrollProfiles","newProfile","fetchUser","searchUsers","createUser","replaceUser","createRestrictedUser","updateUser","deleteUser","scrollUsers","user","newUser","isActionAllowed","rights","filteredRights","right","some","item","getUserRights","userId","createCredentials","kuid","deleteCredentials","getAllCredentialFields","getCredentialFields","getCredentials","hasCredentials","updateCredentials","validateCredentials","bytesToUuid","buf","offset","bth","byteToHex","substr","rng","crypto","msCrypto","getRandomValues","rnds8","Uint8Array","rnds","r","random","v4","ii"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! Kuzzle javascript SDK version 5.0.10 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar uuidv4 = __webpack_require__(19),\n\t    KuzzleEventEmitter = __webpack_require__(1),\n\t    Collection = __webpack_require__(10),\n\t    Document = __webpack_require__(2),\n\t    Security = __webpack_require__(16),\n\t    MemoryStorage = __webpack_require__(12),\n\t    User = __webpack_require__(5),\n\t    networkWrapper = __webpack_require__(13);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle object constructor.\n\t *\n\t * @constructor\n\t * @param host - Server name or IP Address to the Kuzzle instance\n\t * @param [options] - Connection options\n\t * @param {responseCallback} [cb] - Handles connection response\n\t */\n\t\n\tvar Kuzzle = function (_KuzzleEventEmitter) {\n\t  _inherits(Kuzzle, _KuzzleEventEmitter);\n\t\n\t  function Kuzzle(host, options) {\n\t    _classCallCheck(this, Kuzzle);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Kuzzle.__proto__ || Object.getPrototypeOf(Kuzzle)).call(this));\n\t\n\t    if (!host || host === '') {\n\t      throw new Error('host argument missing');\n\t    }\n\t\n\t    Object.defineProperties(_this, {\n\t      // 'private' properties\n\t      eventActions: {\n\t        value: ['connected', 'discarded', 'disconnected', 'loginAttempt', 'networkError', 'offlineQueuePush', 'offlineQueuePop', 'queryError', 'reconnected', 'tokenExpired']\n\t      },\n\t      // configuration properties\n\t      autoResubscribe: {\n\t        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n\t        enumerable: true\n\t      },\n\t      defaultIndex: {\n\t        value: options && typeof options.defaultIndex === 'string' ? options.defaultIndex : undefined,\n\t        writable: true,\n\t        enumerable: true\n\t      },\n\t      jwt: {\n\t        value: undefined,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      protocol: {\n\t        value: options && typeof options.protocol === 'string' ? options.protocol : 'websocket',\n\t        enumerable: true\n\t      },\n\t      sdkVersion: {\n\t        value:  false ? require('../package.json').version : (\"5.0.10\")\n\t      },\n\t      volatile: {\n\t        value: {},\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    if (options) {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = Object.keys(options)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var opt = _step.value;\n\t\n\t          if (_this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(_this, opt).writable) {\n\t            _this[opt] = options[opt];\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Forward the subscribe query to the network wrapper\n\t    Object.defineProperty(_this, 'subscribe', {\n\t      value: function value(room, opts, subscribeCB) {\n\t        var _this2 = this;\n\t\n\t        var object = {\n\t          requestId: uuidv4(),\n\t          controller: 'realtime',\n\t          action: 'subscribe',\n\t          index: room.collection.index,\n\t          collection: room.collection.collection,\n\t          volatile: this.volatile,\n\t          body: room.filters,\n\t          scope: room.scope,\n\t          state: room.state,\n\t          users: room.users\n\t        },\n\t            notificationCB = function notificationCB(data) {\n\t          if (data.type === 'TokenExpired') {\n\t            _this2.unsetJwt();\n\t            return _this2.emit('tokenExpired');\n\t          }\n\t\n\t          if (data.type === 'document') {\n\t            var copy = Object.assign({}, data);\n\t            copy.document = new Document(room.collection, data.result._id, data.result._source, data.result._meta);\n\t            delete copy.result;\n\t            return room.notify(copy);\n\t          }\n\t\n\t          room.notify(data);\n\t        };\n\t\n\t        if (this.jwt !== undefined) {\n\t          object.jwt = this.jwt;\n\t        }\n\t\n\t        Object.assign(object.volatile, room.volatile, { sdkVersion: this.sdkVersion });\n\t\n\t        this.network.subscribe(object, opts, notificationCB, subscribeCB);\n\t      }\n\t    });\n\t\n\t    // Forward the unsubscribe query to the network wrapper\n\t    Object.defineProperty(_this, 'unsubscribe', {\n\t      value: function value(room, unsubscribeCB) {\n\t        var object = {\n\t          requestId: uuidv4(),\n\t          controller: 'realtime',\n\t          action: 'unsubscribe',\n\t          volatile: _this.volatile,\n\t          body: { roomId: room.roomId }\n\t        };\n\t\n\t        if (_this.jwt !== undefined) {\n\t          object.jwt = _this.jwt;\n\t        }\n\t\n\t        Object.assign(object.volatile, room.volatile, { sdkVersion: _this.sdkVersion });\n\t\n\t        _this.network.unsubscribe(object, room.channel, unsubscribeCB);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n\t     * and is called by these methods\n\t     */\n\t    Object.defineProperty(_this, 'callbackRequired', {\n\t      value: function value(errorMessagePrefix, callback) {\n\t        if (!callback || typeof callback !== 'function') {\n\t          throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n\t        }\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Create an attribute security that embed all methods to manage Role, Profile and User\n\t     */\n\t    Object.defineProperty(_this, 'security', {\n\t      value: new Security(_this),\n\t      enumerable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'memoryStorage', {\n\t      value: new MemoryStorage(_this),\n\t      enumerable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'collections', {\n\t      value: {},\n\t      writable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'eventTimeout', {\n\t      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n\t    });\n\t\n\t    Object.defineProperty(_this, 'protectedEvents', {\n\t      value: {\n\t        connected: { timeout: _this.eventTimeout },\n\t        error: { timeout: _this.eventTimeout },\n\t        disconnected: { timeout: _this.eventTimeout },\n\t        reconnected: { timeout: _this.eventTimeout },\n\t        tokenExpired: { timeout: _this.eventTimeout },\n\t        loginAttempt: { timeout: _this.eventTimeout }\n\t      }\n\t    });\n\t\n\t    _this.network = networkWrapper(_this.protocol, host, options);\n\t\n\t    // Properties related to the network layer\n\t    // Accessing a property irrelevant for a given protocol\n\t    // (e.g. \"autoReconnect\" for the HTTP layer) should\n\t    // throw an exception\n\t    Object.defineProperties(_this, {\n\t      autoQueue: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoQueue;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('autoQueue', 'boolean', value);\n\t          _this.network.autoQueue = value;\n\t        }\n\t      },\n\t      autoReconnect: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoReconnect;\n\t        }\n\t      },\n\t      autoReplay: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoReplay;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('autoReplay', 'boolean', value);\n\t          _this.network.autoReplay = value;\n\t        }\n\t      },\n\t      host: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.host;\n\t        }\n\t      },\n\t      offlineQueue: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.offlineQueue;\n\t        }\n\t      },\n\t      offlineQueueLoader: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.offlineQueueLoader;\n\t        },\n\t        set: function set(value) {\n\t          if (value !== null) {\n\t            checkPropertyType('offlineQueueLoader', 'function', value);\n\t          }\n\t          _this.network.offlineQueueLoader = value;\n\t        }\n\t      },\n\t      port: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.port;\n\t        }\n\t      },\n\t      queueFilter: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueFilter;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueFilter', 'function', value);\n\t          _this.network.queueFilter = value;\n\t        }\n\t      },\n\t      queueMaxSize: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueMaxSize;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueMaxSize', 'number', value);\n\t          _this.network.queueMaxSize = value;\n\t        }\n\t      },\n\t      queueTTL: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueTTL;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueTTL', 'number', value);\n\t          _this.network.queueTTL = value;\n\t        }\n\t      },\n\t      replayInterval: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.replayInterval;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('replayInterval', 'number', value);\n\t          _this.network.replayInterval = value;\n\t        }\n\t      },\n\t      reconnectionDelay: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.reconnectionDelay;\n\t        }\n\t      },\n\t      sslConnection: {\n\t        eumerable: true,\n\t        get: function get() {\n\t          return _this.network.ssl;\n\t        }\n\t      }\n\t    });\n\t\n\t    _this.network.addListener('offlineQueuePush', function (data) {\n\t      return _this.emit('offlineQueuePush', data);\n\t    });\n\t    _this.network.addListener('offlineQueuePop', function (data) {\n\t      return _this.emit('offlineQueuePop', data);\n\t    });\n\t    _this.network.addListener('queryError', function (err, query) {\n\t      return _this.emit('queryError', err, query);\n\t    });\n\t\n\t    _this.network.addListener('tokenExpired', function () {\n\t      _this.unsetJwt();\n\t      _this.emit('tokenExpired');\n\t    });\n\t\n\t    if (_this.bluebird) {\n\t      var _ret;\n\t\n\t      return _ret = _this.bluebird.promisifyAll(_this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics', 'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query', 'checkToken', 'whoAmI', 'updateSelf', 'getMyRights', 'getMyCredentials', 'createMyCredentials', 'deleteMyCredentials', 'updateMyCredentials', 'validateMyCredentials', 'createIndex', 'refreshIndex', 'getAutoRefresh', 'setAutoRefresh', 'connect'];\n\t\n\t          return passes && whitelist.indexOf(name) !== -1;\n\t        }\n\t      }), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t  * Emit an event to all registered listeners\n\t  * An event cannot be emitted multiple times before a timeout has been reached.\n\t  */\n\t\n\t\n\t  _createClass(Kuzzle, [{\n\t    key: 'emit',\n\t    value: function emit(eventName) {\n\t      var _get2;\n\t\n\t      var now = Date.now(),\n\t          protectedEvent = this.protectedEvents[eventName];\n\t\n\t      if (protectedEvent) {\n\t        if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n\t          return false;\n\t        }\n\t        protectedEvent.lastEmitted = now;\n\t      }\n\t\n\t      for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        payload[_key - 1] = arguments[_key];\n\t      }\n\t\n\t      (_get2 = _get(Kuzzle.prototype.__proto__ || Object.getPrototypeOf(Kuzzle.prototype), 'emit', this)).call.apply(_get2, [this, eventName].concat(payload));\n\t    }\n\t\n\t    /**\n\t     * Connects to a Kuzzle instance using the provided host name\n\t     * @param {function} [cb] Connection callback\n\t     */\n\t\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect(cb) {\n\t      var _this3 = this;\n\t\n\t      if (this.network.state !== 'offline') {\n\t        if (cb) {\n\t          cb(null, this);\n\t        }\n\t        return;\n\t      }\n\t\n\t      this.network.connect();\n\t\n\t      this.network.addListener('connect', function () {\n\t        _this3.emit('connected');\n\t\n\t        if (cb) {\n\t          cb(null, _this3);\n\t        }\n\t      });\n\t\n\t      this.network.addListener('networkError', function (error) {\n\t        var connectionError = new Error('Unable to connect to kuzzle proxy server at ' + _this3.network.host + ':' + _this3.network.port);\n\t\n\t        connectionError.internal = error;\n\t        _this3.emit('networkError', connectionError);\n\t\n\t        if (cb) {\n\t          cb(connectionError);\n\t        }\n\t      });\n\t\n\t      this.network.addListener('disconnect', function () {\n\t        _this3.disconnect();\n\t        _this3.emit('disconnected');\n\t      });\n\t\n\t      this.network.addListener('reconnect', function () {\n\t        if (_this3.jwt) {\n\t          _this3.checkToken(_this3.jwt, function (err, res) {\n\t            // shouldn't obtain an error but let's invalidate the token anyway\n\t            if (err || !res.valid) {\n\t              _this3.unsetJwt();\n\t            }\n\t\n\t            _this3.emit('reconnected');\n\t          });\n\t        } else {\n\t          _this3.emit('reconnected');\n\t        }\n\t      });\n\t\n\t      this.network.on('discarded', function (data) {\n\t        return _this3.emit('discarded', data);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Set the jwt used to query kuzzle\n\t     * @param token\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'setJwt',\n\t    value: function setJwt(token) {\n\t      if (typeof token === 'string') {\n\t        this.jwt = token;\n\t      } else if ((typeof token === 'undefined' ? 'undefined' : _typeof(token)) === 'object') {\n\t        if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n\t          this.jwt = token.result.jwt;\n\t        } else {\n\t          this.emit('loginAttempt', {\n\t            success: false,\n\t            error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n\t          });\n\t\n\t          return this;\n\t        }\n\t      } else {\n\t        this.emit('loginAttempt', { success: false, error: 'Invalid token argument: ' + token });\n\t        return this;\n\t      }\n\t\n\t      this.emit('loginAttempt', { success: true });\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unset the jwt used to query kuzzle\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'unsetJwt',\n\t    value: function unsetJwt() {\n\t      this.jwt = undefined;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Get the jwt used by kuzzle\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'getJwt',\n\t    value: function getJwt() {\n\t      return this.jwt;\n\t    }\n\t\n\t    /**\n\t     * Send login request to kuzzle with credentials\n\t     * If login success, store the jwt into kuzzle object\n\t     *\n\t     * @param strategy\n\t     * @param credentials\n\t     * @param expiresIn\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'login',\n\t    value: function login(strategy) {\n\t      var _this4 = this;\n\t\n\t      if (!strategy || typeof strategy !== 'string') {\n\t        throw new Error('Kuzzle.login: strategy required');\n\t      }\n\t\n\t      var request = {\n\t        strategy: strategy,\n\t        body: {}\n\t      };\n\t\n\t      var cb = null;\n\t\n\t      // Handle arguments (credentials, expiresIn, cb)\n\t      if (arguments.length <= 1 ? undefined : arguments[1]) {\n\t        if (_typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object') {\n\t          request.body = arguments.length <= 1 ? undefined : arguments[1];\n\t        } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'number' || typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'string') {\n\t          request.expiresIn = arguments.length <= 1 ? undefined : arguments[1];\n\t        } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n\t          cb = arguments.length <= 1 ? undefined : arguments[1];\n\t        }\n\t      }\n\t      if (arguments.length <= 2 ? undefined : arguments[2]) {\n\t        if (typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'number' || typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'string') {\n\t          request.expiresIn = arguments.length <= 2 ? undefined : arguments[2];\n\t        } else if (typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'function') {\n\t          cb = arguments.length <= 2 ? undefined : arguments[2];\n\t        }\n\t      }\n\t      if ((arguments.length <= 3 ? undefined : arguments[3]) && typeof (arguments.length <= 3 ? undefined : arguments[3]) === 'function') {\n\t        cb = arguments.length <= 3 ? undefined : arguments[3];\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'login' }, request, { queuable: false }, function (error, response) {\n\t        if (!error) {\n\t          if (response.result.jwt) {\n\t            _this4.setJwt(response.result.jwt);\n\t          }\n\t\n\t          cb && cb(null, response.result);\n\t        } else {\n\t          cb && cb(error);\n\t          _this4.emit('loginAttempt', { success: false, error: error.message });\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param credentials\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'createMyCredentials',\n\t    value: function createMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'createMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result._source);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Delete credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteMyCredentials',\n\t    value: function deleteMyCredentials(strategy, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'deleteMyCredentials' }, { strategy: strategy }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Get credential information of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'getMyCredentials',\n\t    value: function getMyCredentials(strategy, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'getMyCredentials' }, { strategy: strategy }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Update credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param credentals\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'updateMyCredentials',\n\t    value: function updateMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'updateMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Validate credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param credentials\n\t     * @param options\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'validateMyCredentials',\n\t    value: function validateMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'validateMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create a kuzzle index\n\t     *\n\t     * @param {string} index\n\t     * @param {object} [options]\n\t     * @param {responseCallback} cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'createIndex',\n\t    value: function createIndex(index, options, cb) {\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.createIndex: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'index', action: 'create', index: index }, {}, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Send logout request to kuzzle with jwt.\n\t     *\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'logout',\n\t    value: function logout(cb) {\n\t      var _this5 = this;\n\t\n\t      var request = {\n\t        action: 'logout',\n\t        controller: 'auth',\n\t        requestId: uuidv4(),\n\t        body: {}\n\t      };\n\t\n\t      this.query({ controller: 'auth', action: 'logout' }, request, { queuable: false }, function (error) {\n\t        if (typeof cb === 'function') {\n\t          cb(error, _this5);\n\t        }\n\t      });\n\t\n\t      return this.unsetJwt();\n\t    }\n\t\n\t    /**\n\t     * Checks whether a given jwt token still represents a valid session in Kuzzle.\n\t     *\n\t     * @param  {string}   token     The jwt token to check\n\t     * @param  {function} cb  The callback to be called when the response is\n\t     *                              available. The signature is `function(error, response)`.\n\t     */\n\t\n\t  }, {\n\t    key: 'checkToken',\n\t    value: function checkToken(token, cb) {\n\t      var request = {\n\t        body: {\n\t          token: token\n\t        }\n\t      };\n\t\n\t      this.callbackRequired('Kuzzle.checkToken', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'checkToken' }, request, { queuable: false }, function (err, res) {\n\t        cb(err, err ? undefined : res.result);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Fetches the current user.\n\t     *\n\t     * @param  {function} cb  The callback to be called when the response is\n\t     *                              available. The signature is `function(error, response)`.\n\t     */\n\t\n\t  }, {\n\t    key: 'whoAmI',\n\t    value: function whoAmI(cb) {\n\t      var _this6 = this;\n\t\n\t      this.callbackRequired('Kuzzle.whoAmI', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'getCurrentUser' }, {}, {}, function (err, res) {\n\t        cb(err, err ? undefined : new User(_this6.security, res.result._id, res.result._source, res.result._meta));\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets the rights array of the currently logged user.\n\t     *\n\t     * @param {object} [options] - Optional parameters\n\t     * @param  {function} cb The callback containing the normalized array of rights.\n\t     */\n\t\n\t  }, {\n\t    key: 'getMyRights',\n\t    value: function getMyRights(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getMyRights', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'getMyRights' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.hits);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Update current user in Kuzzle.\n\t     *\n\t     * @param {object} content - a plain javascript object representing the user's modification\n\t     * @param {object} [options] - (optional) arguments\n\t     * @param {responseCallback} [cb] - (optional) Handles the query response\n\t     * @returns {Kuzzle} this object\n\t     */\n\t\n\t  }, {\n\t    key: 'updateSelf',\n\t    value: function updateSelf(content, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'updateSelf' }, { body: content }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n\t     * insertion.\n\t     *\n\t     * @param {string} event - name of the global event to subscribe to\n\t     * @param {function} listener - callback to invoke each time an event is fired\n\t     */\n\t\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(event, listener) {\n\t      if (this.eventActions.indexOf(event) === -1) {\n\t        throw new Error('[' + event + '] is not a known event. Known events: ' + this.eventActions.toString());\n\t      }\n\t\n\t      return _get(Kuzzle.prototype.__proto__ || Object.getPrototypeOf(Kuzzle.prototype), 'addListener', this).call(this, event, listener);\n\t    }\n\t\n\t    /**\n\t     * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t     * This method returns all available statistics from Kuzzle.\n\t     *\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getAllStatistics',\n\t    value: function getAllStatistics(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\t\n\t      this.query({ controller: 'server', action: 'getAllStats' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.hits);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t     * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n\t     *\n\t     * @param {number} startTime -  Epoch time. Starting time from which the frames are to be retrieved\n\t     * @param {number} stopTime -  Epoch time. End time from which the frames are to be retrieved\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getStatistics',\n\t    value: function getStatistics() {\n\t      var startTime = void 0,\n\t          stopTime = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t        args[_key2] = arguments[_key2];\n\t      }\n\t\n\t      switch (args.length) {\n\t        case 1:\n\t          cb = args[0];\n\t          startTime = null;\n\t          stopTime = null;\n\t          options = null;\n\t          break;\n\t        case 2:\n\t          if (_typeof(args[0]) === 'object') {\n\t            options = args[0];\n\t            cb = args[1];\n\t          } else {\n\t            startTime = args[0];\n\t            cb = args[1];\n\t          }\n\t          break;\n\t        case 3:\n\t          if (_typeof(args[1]) === 'object') {\n\t            startTime = args[0];\n\t            options = args[1];\n\t            cb = args[2];\n\t          } else {\n\t            startTime = args[0];\n\t            stopTime = args[1];\n\t            cb = args[2];\n\t          }\n\t          break;\n\t        case 4:\n\t          startTime = args[0];\n\t          stopTime = args[1];\n\t          options = args[2];\n\t          cb = args[3];\n\t\n\t          break;\n\t        default:\n\t          throw new Error('Bad arguments list. Usage: kuzzle.getStatistics([startTime,] [stopTime,] [options,] callback)');\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getStatistics', cb);\n\t\n\t      var queryCB = function queryCB(err, res) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t\n\t        cb(null, startTime ? res.result.hits : [res.result]);\n\t      };\n\t\n\t      var query = {};\n\t      if (startTime) {\n\t        query = stopTime ? { startTime: startTime, stopTime: stopTime } : { startTime: startTime };\n\t      }\n\t\n\t      this.query({ controller: 'server', action: startTime ? 'getStats' : 'getLastStats' }, query, options, queryCB);\n\t    }\n\t\n\t    /**\n\t     * Create a new instance of a Collection object.\n\t     * If no index is specified, takes the default index.\n\t     *\n\t     * @param {string} collection - The name of the data collection you want to manipulate\n\t     * @param {string} [index] - The name of the data index containing the data collection\n\t     * @returns {Collection} A Collection instance\n\t     */\n\t\n\t  }, {\n\t    key: 'collection',\n\t    value: function collection(_collection, index) {\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Unable to create a new data collection object: no index specified');\n\t        }\n\t\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (typeof index !== 'string' || typeof _collection !== 'string') {\n\t        throw new Error('Invalid index or collection argument: string expected');\n\t      }\n\t\n\t      if (!this.collections[index]) {\n\t        this.collections[index] = {};\n\t      }\n\t\n\t      if (!this.collections[index][_collection]) {\n\t        this.collections[index][_collection] = new Collection(this, _collection, index);\n\t      }\n\t\n\t      return this.collections[index][_collection];\n\t    }\n\t\n\t    /**\n\t     * Empties the offline queue without replaying it.\n\t     *\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'flushQueue',\n\t    value: function flushQueue() {\n\t      this.network.flushQueue();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Returns the list of known persisted data collections.\n\t     *\n\t     * @param {string} [index] - Index containing collections to be listed\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'listCollections',\n\t    value: function listCollections() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n\t        args[_key3] = arguments[_key3];\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var arg = _step2.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.listCollections: index required');\n\t        }\n\t\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.listCollections', cb);\n\t\n\t      var query = { type: options && options.type || 'all' };\n\t\n\t      this.query({ index: index, controller: 'collection', action: 'list' }, query, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.collections);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns the list of existing indexes in Kuzzle\n\t     *\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'listIndexes',\n\t    value: function listIndexes(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.listIndexes', cb);\n\t\n\t      this.query({ controller: 'index', action: 'list' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.indexes);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Disconnects from Kuzzle and invalidate this instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this.network.close();\n\t\n\t      var _iteratorNormalCompletion3 = true;\n\t      var _didIteratorError3 = false;\n\t      var _iteratorError3 = undefined;\n\t\n\t      try {\n\t        for (var _iterator3 = Object.keys(this.collections)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t          var collection = _step3.value;\n\t\n\t          delete this.collections[collection];\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t            _iterator3.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError3) {\n\t            throw _iteratorError3;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Returns the server informations\n\t     *\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getServerInfo',\n\t    value: function getServerInfo(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getServerInfo', cb);\n\t\n\t      this.query({ controller: 'server', action: 'info' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.serverInfo);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Forces an index refresh\n\t     *\n\t     * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n\t     * @param {object} options - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'refreshIndex',\n\t    value: function refreshIndex() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n\t        args[_key4] = arguments[_key4];\n\t      }\n\t\n\t      var _iteratorNormalCompletion4 = true;\n\t      var _didIteratorError4 = false;\n\t      var _iteratorError4 = undefined;\n\t\n\t      try {\n\t        for (var _iterator4 = args[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t          var arg = _step4.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t            _iterator4.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError4) {\n\t            throw _iteratorError4;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.refreshIndex: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.query({ index: index, controller: 'index', action: 'refresh' }, {}, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Returns de current autoRefresh status for the given index\n\t     *\n\t     * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n\t     * @param {object} options - Optinal arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getAutoRefresh',\n\t    value: function getAutoRefresh() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n\t        args[_key5] = arguments[_key5];\n\t      }\n\t\n\t      var _iteratorNormalCompletion5 = true;\n\t      var _didIteratorError5 = false;\n\t      var _iteratorError5 = undefined;\n\t\n\t      try {\n\t        for (var _iterator5 = args[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t          var arg = _step5.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError5 = true;\n\t        _iteratorError5 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t            _iterator5.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError5) {\n\t            throw _iteratorError5;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.getAutoRefresh: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n\t      this.query({ index: index, controller: 'index', action: 'getAutoRefresh' }, {}, options, cb);\n\t    }\n\t\n\t    /**\n\t     * (Un)Sets the autoRefresh flag on the given index\n\t     *\n\t     * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n\t     * @param {boolean} autoRefresh - The autoRefresh value to set\n\t     * @param {object} options - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query result\n\t     * @returns {object} this\n\t     */\n\t\n\t  }, {\n\t    key: 'setAutoRefresh',\n\t    value: function setAutoRefresh() {\n\t      var index, autoRefresh, options, cb;\n\t\n\t      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n\t        args[_key6] = arguments[_key6];\n\t      }\n\t\n\t      var _iteratorNormalCompletion6 = true;\n\t      var _didIteratorError6 = false;\n\t      var _iteratorError6 = undefined;\n\t\n\t      try {\n\t        for (var _iterator6 = args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t          var arg = _step6.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'boolean':\n\t              autoRefresh = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError6 = true;\n\t        _iteratorError6 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t            _iterator6.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError6) {\n\t            throw _iteratorError6;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.setAutoRefresh: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (autoRefresh === undefined) {\n\t        throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n\t      }\n\t\n\t      this.query({ index: index, controller: 'index', action: 'setAutoRefresh' }, { body: { autoRefresh: autoRefresh } }, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Return the current Kuzzle's UTC Epoch time, in milliseconds\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'now',\n\t    value: function now(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.now', cb);\n\t\n\t      this.query({ controller: 'server', action: 'now' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.now);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n\t     * Base method used to send read queries to Kuzzle\n\t     *\n\t     * Takes an optional argument object with the following properties:\n\t     *    - volatile (object, default: null):\n\t     *        Additional information passed to notifications to other users\n\t     *\n\t     * @param {object} queryArgs - Query configuration\n\t     * @param {object} query - The query data\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} [cb] - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'query',\n\t    value: function query(queryArgs, _query, options, cb) {\n\t      var object = {\n\t        action: queryArgs.action,\n\t        controller: queryArgs.controller,\n\t        volatile: this.volatile\n\t      };\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      } else if (!cb && !options && typeof _query === 'function') {\n\t        cb = _query;\n\t        _query = {};\n\t        options = null;\n\t      }\n\t\n\t      if (options) {\n\t        var _arr = ['refresh', 'from', 'size', 'scroll', 'scrollId'];\n\t\n\t        for (var _i = 0; _i < _arr.length; _i++) {\n\t          var prop = _arr[_i];\n\t          if (options[prop] !== undefined) {\n\t            object[prop] = options[prop];\n\t          }\n\t        }\n\t\n\t        if (options.volatile && _typeof(options.volatile) === 'object') {\n\t          Object.assign(object.volatile, options.volatile);\n\t        }\n\t      }\n\t\n\t      if (!_query || (typeof _query === 'undefined' ? 'undefined' : _typeof(_query)) !== 'object' || Array.isArray(_query)) {\n\t        throw new Error('Invalid query parameter: ' + _query);\n\t      }\n\t\n\t      Object.assign(object.volatile, _query.volatile, { sdkVersion: this.sdkVersion });\n\t\n\t      var _iteratorNormalCompletion7 = true;\n\t      var _didIteratorError7 = false;\n\t      var _iteratorError7 = undefined;\n\t\n\t      try {\n\t        for (var _iterator7 = Object.keys(_query)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t          var attr = _step7.value;\n\t\n\t          if (attr !== 'volatile') {\n\t            object[attr] = _query[attr];\n\t          }\n\t        }\n\t\n\t        /*\n\t         * Do not add the token for the checkToken route, to avoid getting a token error when\n\t         * a developer simply wish to verify his token\n\t         */\n\t      } catch (err) {\n\t        _didIteratorError7 = true;\n\t        _iteratorError7 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t            _iterator7.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError7) {\n\t            throw _iteratorError7;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this.jwt !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n\t        object.jwt = this.jwt;\n\t      }\n\t\n\t      if (queryArgs.collection) {\n\t        object.collection = queryArgs.collection;\n\t      }\n\t\n\t      if (queryArgs.index) {\n\t        object.index = queryArgs.index;\n\t      }\n\t\n\t      if (!object.requestId) {\n\t        object.requestId = uuidv4();\n\t      }\n\t\n\t      this.network.query(object, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Starts the requests queuing.\n\t     */\n\t\n\t  }, {\n\t    key: 'startQueuing',\n\t    value: function startQueuing() {\n\t      this.network.startQueuing();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Stops the requests queuing.\n\t     */\n\t\n\t  }, {\n\t    key: 'stopQueuing',\n\t    value: function stopQueuing() {\n\t      this.network.stopQueuing();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * @DEPRECATED\n\t     * See Kuzzle.prototype.playQueue();\n\t     */\n\t\n\t  }, {\n\t    key: 'replayQueue',\n\t    value: function replayQueue() {\n\t      return this.playQueue();\n\t    }\n\t\n\t    /**\n\t     * Plays the requests queued during offline mode.\n\t     */\n\t\n\t  }, {\n\t    key: 'playQueue',\n\t    value: function playQueue() {\n\t      this.network.playQueue();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Sets the default Kuzzle index\n\t     *\n\t     * @param index\n\t     * @returns this\n\t     */\n\t\n\t  }, {\n\t    key: 'setDefaultIndex',\n\t    value: function setDefaultIndex(index) {\n\t      if (typeof index !== 'string') {\n\t        throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n\t      }\n\t\n\t      if (index.length === 0) {\n\t        throw new Error('Cannot set an empty index as the default index');\n\t      }\n\t\n\t      this.defaultIndex = index;\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Kuzzle;\n\t}(KuzzleEventEmitter);\n\t\n\tfunction checkPropertyType(prop, typestr, value) {\n\t  var wrongType = typestr === 'array' ? !Array.isArray(value) : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== typestr;\n\t\n\t  if (wrongType) {\n\t    throw new Error('Can only assign a ' + typestr + ' value to property \"' + prop + '\"');\n\t  }\n\t}\n\t\n\tmodule.exports = Kuzzle;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Listener = function Listener(fn) {\n\t  var once = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t  _classCallCheck(this, Listener);\n\t\n\t  this.fn = fn;\n\t  this.once = once;\n\t};\n\t\n\tvar KuzzleEventEmitter = function () {\n\t  function KuzzleEventEmitter() {\n\t    _classCallCheck(this, KuzzleEventEmitter);\n\t\n\t    this._events = {};\n\t  }\n\t\n\t  _createClass(KuzzleEventEmitter, [{\n\t    key: '_exists',\n\t    value: function _exists(listeners, fn) {\n\t      return Boolean(listeners.find(function (listener) {\n\t        return listener.fn === fn;\n\t      }));\n\t    }\n\t  }, {\n\t    key: 'listeners',\n\t    value: function listeners(eventName) {\n\t      if (this._events[eventName] === undefined) {\n\t        return [];\n\t      }\n\t\n\t      return this._events[eventName].map(function (listener) {\n\t        return listener.fn;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(eventName, listener) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!eventName || !listener) {\n\t        return this;\n\t      }\n\t\n\t      var listenerType = typeof listener === 'undefined' ? 'undefined' : _typeof(listener);\n\t\n\t      if (listenerType !== 'function') {\n\t        throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n\t      }\n\t\n\t      if (this._events[eventName] === undefined) {\n\t        this._events[eventName] = [];\n\t      }\n\t\n\t      if (!this._exists(this._events[eventName], listener)) {\n\t        this._events[eventName].push(new Listener(listener, once));\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'on',\n\t    value: function on(eventName, listener) {\n\t      return this.addListener(eventName, listener);\n\t    }\n\t  }, {\n\t    key: 'prependListener',\n\t    value: function prependListener(eventName, listener) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!eventName || !listener) {\n\t        return this;\n\t      }\n\t\n\t      if (this._events[eventName] === undefined) {\n\t        this._events[eventName] = [];\n\t      }\n\t\n\t      if (!this._exists(this._events[eventName], listener)) {\n\t        this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'addOnceListener',\n\t    value: function addOnceListener(eventName, listener) {\n\t      return this.addListener(eventName, listener, true);\n\t    }\n\t  }, {\n\t    key: 'once',\n\t    value: function once(eventName, listener) {\n\t      return this.addOnceListener(eventName, listener);\n\t    }\n\t  }, {\n\t    key: 'prependOnceListener',\n\t    value: function prependOnceListener(eventName, listener) {\n\t      return this.prependListener(eventName, listener, true);\n\t    }\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(eventName, listener) {\n\t      var listeners = this._events[eventName];\n\t\n\t      if (!listeners || !listeners.length) {\n\t        return this;\n\t      }\n\t\n\t      var index = listeners.findIndex(function (l) {\n\t        return l.fn === listener;\n\t      });\n\t\n\t      if (index !== -1) {\n\t        listeners.splice(index, 1);\n\t      }\n\t\n\t      if (listeners.length === 0) {\n\t        delete this._events[eventName];\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'removeAllListeners',\n\t    value: function removeAllListeners(eventName) {\n\t      if (eventName) {\n\t        delete this._events[eventName];\n\t      } else {\n\t        this._events = {};\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(eventName) {\n\t      var listeners = this._events[eventName];\n\t\n\t      if (listeners === undefined) {\n\t        return false;\n\t      }\n\t\n\t      var onceListeners = [];\n\t\n\t      for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        payload[_key - 1] = arguments[_key];\n\t      }\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var listener = _step.value;\n\t\n\t          listener.fn.apply(listener, payload);\n\t\n\t          if (listener.once) {\n\t            onceListeners.push(listener.fn);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = onceListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var toDelete = _step2.value;\n\t\n\t          this.removeListener(eventName, toDelete);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'eventNames',\n\t    value: function eventNames() {\n\t      return Object.keys(this._events);\n\t    }\n\t  }, {\n\t    key: 'listenerCount',\n\t    value: function listenerCount(eventName) {\n\t      return this._events[eventName] && this._events[eventName].length || 0;\n\t    }\n\t  }]);\n\t\n\t  return KuzzleEventEmitter;\n\t}();\n\t\n\tmodule.exports = KuzzleEventEmitter;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle handles documents either as realtime messages or as stored documents.\n\t * Document is the object representation of one of these documents.\n\t *\n\t * Notes:\n\t *   - this constructor may be called either with a documentId, a content, neither or both.\n\t *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n\t *\n\t *\n\t * @param {Collection} collection - an instanciated Collection object\n\t * @param {string} [documentId] - ID of an existing document\n\t * @param {object} [content] - Initializes this document with the provided content\n\t * @param {object} [meta] - Initializes this document with the provided meta\n\t * @constructor\n\t */\n\tfunction Document(collection, documentId, content, meta) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection.collection,\n\t      enumerable: true\n\t    },\n\t    dataCollection: {\n\t      value: collection,\n\t      enumerable: false\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: false\n\t    },\n\t    // writable properties\n\t    id: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    version: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      enumerable: true,\n\t      writable: false\n\t    }\n\t  });\n\t\n\t  // handling provided arguments\n\t  if (!content && documentId && typeof documentId === 'object') {\n\t    content = documentId;\n\t    documentId = null;\n\t  }\n\t\n\t  if (content) {\n\t    if (content._version) {\n\t      this.version = content._version;\n\t      delete content._version;\n\t    }\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  if (documentId) {\n\t    Object.defineProperty(this, 'id', {\n\t      value: documentId,\n\t      enumerable: true\n\t    });\n\t  }\n\t\n\t  // promisifying\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'refresh', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this document\n\t */\n\tDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  if (this.version) {\n\t    data._version = this.version;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Overrides the toString() method in order to return a serialized version of the document\n\t *\n\t * @return {string} serialized version of this object\n\t */\n\tDocument.prototype.toString = function () {\n\t  return JSON.stringify(this.serialize());\n\t};\n\t\n\t/**\n\t * Deletes this document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.delete = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.delete: cannot delete a document without a document ID');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n\t    cb(err, err ? undefined : self.id);\n\t  });\n\t};\n\t\n\t/**\n\t * Checks if this document exists in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.exists = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replaces the current content with the last version of this document stored in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.refresh = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.refresh', cb);\n\t\n\t  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n\t    var newDocument;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n\t    newDocument.version = res.result._version;\n\t\n\t    cb(null, newDocument);\n\t  });\n\t};\n\t\n\t/**\n\t * Saves this document into Kuzzle.\n\t *\n\t * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n\t * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n\t    if (error) {\n\t      return cb && cb(error);\n\t    }\n\t\n\t    self.id = res.result._id;\n\t    self.version = res.result._version;\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Sends the content of this document as a realtime message.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tDocument.prototype.publish = function (options) {\n\t  var data = this.serialize();\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {object} data - New content\n\t * @param {boolean} replace - if true: replace this document content with the provided data\n\t */\n\tDocument.prototype.setContent = function (data, replace) {\n\t  var self = this;\n\t\n\t  if (replace) {\n\t    this.content = data;\n\t  }\n\t  else {\n\t    Object.keys(data).forEach(function (key) {\n\t      self.content[key] = data[key];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Listens to events concerning this document. Has no effect if the document does not have an ID\n\t * (i.e. if the document has not yet been created as a persisted document).\n\t *\n\t * @param {object} [options] - subscription options\n\t * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n\t */\n\tDocument.prototype.subscribe = function (options, cb) {\n\t  var filters;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\t\n\t  if (!this.id) {\n\t    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n\t  }\n\t\n\t  filters = { ids: { values: [this.id] } };\n\t\n\t  return this.dataCollection.subscribe(filters, options, cb);\n\t};\n\t\n\tmodule.exports = Document;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\tfunction SecurityDocument(Security, id, content, meta) {\n\t\n\t  if (!id) {\n\t    throw new Error('A security document must have an id');\n\t  }\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    kuzzle: {\n\t      value: Security.kuzzle\n\t    },\n\t    Security: {\n\t      value: Security\n\t    },\n\t    // read-only properties\n\t    // writable properties\n\t    id: {\n\t      value: id,\n\t      enumerable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (content) {\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'update'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {Object} data - New securityDocument content\n\t * @return {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.setContent = function (data) {\n\t  this.content = data;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a pojo\n\t *\n\t * @return {object} pojo representing this securityDocument\n\t */\n\tSecurityDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Delete the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tSecurityDocument.prototype.delete = function (options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, res.result._id);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} content - Content to add to KuzzleSecurityDocument\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.update = function (content, options, cb) {\n\t  var\n\t    data = {},\n\t    self = this;\n\t\n\t  if (typeof content !== 'object') {\n\t    throw new Error('Parameter \"content\" must be a object');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = self.id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.setContent(response.result._source);\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = SecurityDocument;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar KuzzleEventEmitter = __webpack_require__(1);\n\t\n\tvar RTWrapper = function (_KuzzleEventEmitter) {\n\t  _inherits(RTWrapper, _KuzzleEventEmitter);\n\t\n\t  function RTWrapper(host, options) {\n\t    _classCallCheck(this, RTWrapper);\n\t\n\t    var _this = _possibleConstructorReturn(this, (RTWrapper.__proto__ || Object.getPrototypeOf(RTWrapper)).call(this));\n\t\n\t    Object.defineProperties(_this, {\n\t      cleanHistoryTimer: {\n\t        value: null,\n\t        writable: true\n\t      },\n\t      host: {\n\t        value: host,\n\t        enumerable: true\n\t      },\n\t      port: {\n\t        value: options && typeof options.port === 'number' ? options.port : 7512,\n\t        enumerable: true\n\t      },\n\t      ssl: {\n\t        value: options && typeof options.sslConnection === 'boolean' ? options.sslConnection : false,\n\t        enumerable: true\n\t      },\n\t      queuing: {\n\t        value: false,\n\t        writable: true\n\t      },\n\t      reconnectionDelay: {\n\t        value: options && typeof options.reconnectionDelay === 'number' ? options.reconnectionDelay : 1000,\n\t        enumerable: true\n\t      },\n\t      // configuration properties\n\t      autoReconnect: {\n\t        value: options && typeof options.autoReconnect === 'boolean' ? options.autoReconnect : true,\n\t        enumerable: true\n\t      },\n\t      autoQueue: {\n\t        value: false,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      autoReplay: {\n\t        value: false,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      state: {\n\t        value: 'offline',\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      /*\n\t        Offline queue use the following format:\n\t              [\n\t                {\n\t                  ts: <query timestamp>,\n\t                  query: 'query',\n\t                  cb: callbackFunction\n\t                }\n\t              ]\n\t       */\n\t      offlineQueue: {\n\t        value: [],\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueFilter: {\n\t        value: null,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueMaxSize: {\n\t        value: 500,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueTTL: {\n\t        value: 120000,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      replayInterval: {\n\t        value: 10,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      offlineQueueLoader: {\n\t        value: null,\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    if (options) {\n\t      Object.keys(options).forEach(function (opt) {\n\t        if (_this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(_this, opt).writable) {\n\t          _this[opt] = options[opt];\n\t        }\n\t      });\n\t\n\t      if (options.offlineMode === 'auto' && _this.autoReconnect) {\n\t        _this.autoQueue = _this.autoReplay = true;\n\t      }\n\t    }\n\t\n\t    Object.defineProperty(_this, 'requestHistory', {\n\t      value: {},\n\t      writable: true\n\t    });\n\t\n\t    _this.wasConnected = false;\n\t    _this.stopRetryingToConnect = false;\n\t    _this.retrying = false;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(RTWrapper, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      this.state = 'connecting';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is established\n\t     */\n\t\n\t  }, {\n\t    key: 'clientConnected',\n\t    value: function clientConnected() {\n\t      var _this2 = this;\n\t\n\t      this.state = 'connected';\n\t      this.emit(this.wasConnected && 'reconnect' || 'connect');\n\t      this.wasConnected = true;\n\t      this.stopRetryingToConnect = false;\n\t\n\t      if (this.autoQueue) {\n\t        this.stopQueuing();\n\t      }\n\t\n\t      if (this.autoReplay) {\n\t        this.playQueue();\n\t      }\n\t\n\t      if (!this.cleanHistoryTimer) {\n\t        this.cleanHistoryTimer = setInterval(function () {\n\t          cleanHistory(_this2.requestHistory);\n\t        }, 1000);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is closed\n\t     */\n\t\n\t  }, {\n\t    key: 'clientDisconnected',\n\t    value: function clientDisconnected() {\n\t      this.state = 'offline';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t\n\t      this.clearHistoryTimer();\n\t      this.emit('disconnect');\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is closed with an error state\n\t     *\n\t     * @param {Error} error\n\t     */\n\t\n\t  }, {\n\t    key: 'clientNetworkError',\n\t    value: function clientNetworkError(error) {\n\t      var _this3 = this;\n\t\n\t      this.state = 'offline';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t\n\t      this.clearHistoryTimer();\n\t\n\t      this.emit('networkError', error);\n\t      if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n\t        this.retrying = true;\n\t        setTimeout(function () {\n\t          _this3.retrying = false;\n\t          _this3.connect(_this3.host);\n\t        }, this.reconnectionDelay);\n\t      } else {\n\t        this.emit('disconnect');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Empties the offline queue without replaying it.\n\t     */\n\t\n\t  }, {\n\t    key: 'flushQueue',\n\t    value: function flushQueue() {\n\t      this.offlineQueue = [];\n\t    }\n\t\n\t    /**\n\t     * Replays the requests queued during offline mode.\n\t     */\n\t\n\t  }, {\n\t    key: 'playQueue',\n\t    value: function playQueue() {\n\t      if (this.state === 'connected') {\n\t        cleanQueue(this);\n\t        dequeue(this);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t     */\n\t\n\t  }, {\n\t    key: 'startQueuing',\n\t    value: function startQueuing() {\n\t      this.queuing = true;\n\t    }\n\t\n\t    /**\n\t     * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t     */\n\t\n\t  }, {\n\t    key: 'stopQueuing',\n\t    value: function stopQueuing() {\n\t      this.queuing = false;\n\t    }\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(object, options, notificationCB, cb) {\n\t      var _this4 = this;\n\t\n\t      if (this.state !== 'connected') {\n\t        return cb(new Error('Not Connected'));\n\t      }\n\t      this.query(object, options, function (error, response) {\n\t        if (error) {\n\t          return cb(error);\n\t        }\n\t        _this4.on(response.result.channel, function (data) {\n\t          data.fromSelf = _this4.requestHistory[data.requestId] !== undefined;\n\t          notificationCB(data);\n\t        });\n\t        cb(null, response.result);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(object, channel, cb) {\n\t      this.removeAllListeners(channel);\n\t      this.query(object, null, function (err, res) {\n\t        if (cb) {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'query',\n\t    value: function query(object, options, cb) {\n\t      var queuable = options && options.queuable !== false || true;\n\t\n\t      if (this.queueFilter) {\n\t        queuable = queuable && this.queueFilter(object);\n\t      }\n\t\n\t      if (this.queuing && queuable) {\n\t        cleanQueue(this, object, cb);\n\t        this.emit('offlineQueuePush', { query: object, cb: cb });\n\t        return this.offlineQueue.push({ ts: Date.now(), query: object, cb: cb });\n\t      }\n\t\n\t      if (this.state === 'connected') {\n\t        return emitRequest(this, object, cb);\n\t      }\n\t\n\t      return discardRequest(object, cb);\n\t    }\n\t  }, {\n\t    key: 'clearHistoryTimer',\n\t    value: function clearHistoryTimer() {\n\t      if (this.cleanHistoryTimer) {\n\t        clearInterval(this.cleanHistoryTimer);\n\t        this.cleanHistoryTimer = null;\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return RTWrapper;\n\t}(KuzzleEventEmitter);\n\t/**\n\t * Emit a request to Kuzzle\n\t *\n\t * @param {RTWrapper} network\n\t * @param {object} request\n\t * @param {responseCallback} [cb]\n\t */\n\t\n\t\n\tfunction emitRequest(network, request, cb) {\n\t  if (request.jwt !== undefined || cb) {\n\t    network.once(request.requestId, function (response) {\n\t      var error = null;\n\t\n\t      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n\t        network.emit('tokenExpired', request, cb);\n\t      }\n\t\n\t      if (response.error) {\n\t        error = new Error(response.error.message);\n\t        Object.assign(error, response.error);\n\t        error.status = response.status;\n\t        network.emit('queryError', error, request, cb);\n\t      }\n\t\n\t      if (cb) {\n\t        cb(error, response);\n\t      }\n\t    });\n\t  }\n\t  // Track requests made to allow Room.subscribeToSelf to work\n\t  network.requestHistory[request.requestId] = Date.now();\n\t  network.send(request);\n\t}\n\t\n\tfunction discardRequest(object, cb) {\n\t  if (cb) {\n\t    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n\t  }\n\t}\n\t\n\t/**\n\t * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n\t * @param {RTWrapper} network\n\t */\n\tfunction cleanQueue(network) {\n\t  var now = Date.now();\n\t  var lastDocumentIndex = -1;\n\t\n\t  if (network.queueTTL > 0) {\n\t    network.offlineQueue.forEach(function (query, index) {\n\t      if (query.ts < now - network.queueTTL) {\n\t        lastDocumentIndex = index;\n\t      }\n\t    });\n\t\n\t    if (lastDocumentIndex !== -1) {\n\t      network.offlineQueue.splice(0, lastDocumentIndex + 1).forEach(function (droppedRequest) {\n\t        network.emit('offlineQueuePop', droppedRequest.query);\n\t      });\n\t    }\n\t  }\n\t\n\t  if (network.queueMaxSize > 0 && network.offlineQueue.length > network.queueMaxSize) {\n\t    network.offlineQueue.splice(0, network.offlineQueue.length - network.queueMaxSize).forEach(function (droppedRequest) {\n\t      network.emit('offlineQueuePop', droppedRequest.query);\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Play all queued requests, in order.\n\t */\n\tfunction dequeue(network) {\n\t  var uniqueQueue = {},\n\t      dequeuingProcess = function dequeuingProcess() {\n\t    if (network.offlineQueue.length > 0) {\n\t      emitRequest(network, network.offlineQueue[0].query, network.offlineQueue[0].cb);\n\t      network.emit('offlineQueuePop', network.offlineQueue.shift());\n\t\n\t      setTimeout(function () {\n\t        dequeuingProcess();\n\t      }, Math.max(0, network.replayInterval));\n\t    }\n\t  };\n\t\n\t  if (network.offlineQueueLoader) {\n\t    if (typeof network.offlineQueueLoader !== 'function') {\n\t      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + _typeof(network.offlineQueueLoader));\n\t    }\n\t\n\t    var additionalQueue = network.offlineQueueLoader();\n\t    if (Array.isArray(additionalQueue)) {\n\t      network.offlineQueue = additionalQueue.concat(network.offlineQueue).filter(function (request) {\n\t        // throws if the query object does not contain required attributes\n\t        if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n\t          throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n\t        }\n\t\n\t        return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : uniqueQueue[request.query.requestId] = true;\n\t      });\n\t    } else {\n\t      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + (typeof additionalQueue === 'undefined' ? 'undefined' : _typeof(additionalQueue)));\n\t    }\n\t  }\n\t\n\t  dequeuingProcess();\n\t}\n\t\n\t/**\n\t * Clean history from requests made more than 10s ago\n\t */\n\tfunction cleanHistory(requestHistory) {\n\t  var now = Date.now();\n\t\n\t  Object.keys(requestHistory).forEach(function (key) {\n\t    if (requestHistory[key] < now - 10000) {\n\t      delete requestHistory[key];\n\t    }\n\t  });\n\t}\n\t\n\tmodule.exports = RTWrapper;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(3);\n\t\n\t/**\n\t * @param {Security} Security\n\t * @param {string} id\n\t * @param {Object} content\n\t * @constructor\n\t */\n\tfunction User(Security, id, content, meta) {\n\t  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteUser'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateUser'\n\t    },\n\t    credentials: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: User\n\t  }\n\t});\n\t\n\t/**\n\t * Set profiles in content\n\t * @param {array} profileIds - an array of profiles ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.setProfiles = function (profileIds) {\n\t  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n\t    throw new Error('Parameter \"profileIds\" must be an array of strings');\n\t  }\n\t\n\t  this.content.profileIds = profileIds;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {object} credentials\n\t */\n\tUser.prototype.setCredentials = function (credentials) {\n\t  if (typeof credentials !== 'object') {\n\t    throw new Error('Parameter \"credentials\" must be a object');\n\t  }\n\t\n\t  this.credentials = credentials;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a profile\n\t * @param {string} profileId - a profile ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.addProfile = function (profileId) {\n\t  if (typeof profileId !== 'string') {\n\t    throw new Error('Parameter \"profileId\" must be a string');\n\t  }\n\t\n\t  if (!this.content.profileIds) {\n\t    this.content.profileIds = [];\n\t  }\n\t\n\t  if (this.content.profileIds.indexOf(profileId) === -1) {\n\t    this.content.profileIds.push(profileId);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Creates this user into Kuzzle\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.create = function (options, cb) {\n\t  var\n\t    data = this.creationSerialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Replaces the latest version of this user in Kuzzle by the current content of this object.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.replace = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Saves this user as restricted into Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.saveRestricted = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.serialize = function () {\n\t  return {_id: this.id, body: this.content, meta: this.meta};\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.creationSerialize = function () {\n\t  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n\t};\n\t\n\t/**\n\t * Return the associated profiles IDs\n\t *\n\t * @return {array.<string>} the associated profiles IDs\n\t */\n\tUser.prototype.getProfileIds = function () {\n\t  return this.content.profileIds || [];\n\t};\n\t\n\t/**\n\t * Return the associated Profile objects\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tUser.prototype.getProfiles = function (options, cb) {\n\t  var \n\t    self = this,\n\t    fetchedProfiles = [],\n\t    errored = false;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\t\n\t  if (!self.content.profileIds) {\n\t    return cb(null, fetchedProfiles);\n\t  }\n\t\n\t  self.content.profileIds.forEach(function (profileId) {\n\t    self.Security.fetchProfile(profileId, options, function (error, profile) {\n\t      if (error) {\n\t        if (errored) {\n\t          return;\n\t        }\n\t\n\t        errored = true; // prevents multiple callback resolutions\n\t        return cb(error);\n\t      }\n\t\n\t      fetchedProfiles.push(profile);\n\t\n\t      if (fetchedProfiles.length === self.content.profileIds.length) {\n\t        cb(null, fetchedProfiles);\n\t      }\n\t    });\n\t  });\n\t};\n\t\n\tmodule.exports = User;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar KuzzleEventEmitter = __webpack_require__(1);\n\t\n\t/**\n\t * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n\t *\n\t * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n\t *\n\t * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n\t * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n\t * document change (because it is created, updated or deleted), then youll receive a notification about it.\n\t *\n\t */\n\t\n\tvar Room = function (_KuzzleEventEmitter) {\n\t  _inherits(Room, _KuzzleEventEmitter);\n\t\n\t  /*\n\t   * @constructor\n\t   * @param {object} collection - an instantiated and valid kuzzle object\n\t   * @param {object} [filters] - Filters in Kuzzle DSL format\n\t   * @param {object} [options] - subscription optional configuration\n\t   */\n\t  function Room(collection, filters, options) {\n\t    _classCallCheck(this, Room);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Room.__proto__ || Object.getPrototypeOf(Room)).call(this));\n\t\n\t    var _roomId = null;\n\t\n\t    // Define properties\n\t    Object.defineProperties(_this, {\n\t      // private properties\n\t      roomstate: {\n\t        // Values can be: inactive, subscribing, active\n\t        value: 'inactive',\n\t        writable: true\n\t      },\n\t      kuzzle: {\n\t        value: collection.kuzzle\n\t      },\n\t      isListening: {\n\t        value: false,\n\t        writable: true\n\t      },\n\t      //listeners\n\t      resubscribe: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t          _this.error = null;\n\t          _this.subscribe();\n\t        }\n\t      },\n\t      deactivate: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t        }\n\t      },\n\t      resubscribeConditional: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t\n\t          if (_this.autoResubscribe) {\n\t            _this.subscribe();\n\t          }\n\t        }\n\t      },\n\t      //enumerables\n\t      channel: {\n\t        value: null,\n\t        writable: true,\n\t        enumerable: true\n\t      },\n\t      scope: {\n\t        value: options && options.scope ? options.scope : 'all',\n\t        enumerable: true\n\t      },\n\t      state: {\n\t        value: options && options.state ? options.state : 'done',\n\t        enumerable: true\n\t      },\n\t      users: {\n\t        value: options && options.users ? options.users : 'none',\n\t        enumerable: true\n\t      },\n\t      // read-only properties\n\t      collection: {\n\t        value: collection,\n\t        enumerable: true\n\t      },\n\t      filters: {\n\t        value: filters ? filters : {},\n\t        enumerable: true\n\t      },\n\t      roomId: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _roomId;\n\t        },\n\t        set: function set(value) {\n\t          if (!_roomId) {\n\t            _roomId = value;\n\t          }\n\t        }\n\t      },\n\t      // writable properties\n\t      volatile: {\n\t        value: options && options.volatile ? options.volatile : {},\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      subscribeToSelf: {\n\t        value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      autoResubscribe: {\n\t        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : collection.kuzzle.autoResubscribe,\n\t        enumerable: true\n\t      }\n\t    });\n\t\n\t    if (_this.kuzzle.bluebird) {\n\t      var _ret;\n\t\n\t      return _ret = _this.kuzzle.bluebird.promisifyAll(_this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          var whitelist = ['count', 'subscribe', 'unsubscribe', 'onDone'];\n\t\n\t          return passes && whitelist.indexOf(name) !== -1;\n\t        }\n\t      }), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Returns the number of other subscriptions on that room.\n\t   *\n\t   * @param {responseCallback} cb - Handles the query response\n\t   */\n\t\n\t\n\t  _createClass(Room, [{\n\t    key: 'count',\n\t    value: function count(cb) {\n\t      this.kuzzle.callbackRequired('Room.count', cb);\n\t\n\t      var data = { body: { roomId: this.roomId } };\n\t\n\t      if (this.roomstate !== 'active') {\n\t        return cb(new Error('Cannot count subscriptions on an non-active room'));\n\t      }\n\t\n\t      this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n\t        cb(err, res && res.result.count);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Subscribes to Kuzzle \n\t     * (do nothing if a subscription is active or underway)\n\t     * \n\t     * @param options\n\t     * @param {responseCallback} cb - called when the subscription is ready.\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(options, cb) {\n\t      var _this2 = this;\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      if (cb) {\n\t        this.onDone(cb);\n\t      }\n\t\n\t      // If the room subscription is active, just call the callback.\n\t      if (this.roomstate === 'active') {\n\t        this.emit('done', null, this);\n\t        return this;\n\t      }\n\t\n\t      // If the room is already subscribing, wait for its activation.\n\t      if (this.roomstate === 'subscribing') {\n\t        return this;\n\t      }\n\t\n\t      // If the room is still inactive, start the subscription.\n\t      this.error = null;\n\t      this.roomstate = 'subscribing';\n\t\n\t      this.kuzzle.subscribe(this, options, function (error, result) {\n\t        if (error) {\n\t          if (error.message === 'Not Connected') {\n\t            return _this2.kuzzle.once('connected', _this2.resubscribe);\n\t          }\n\t\n\t          _this2.roomstate = 'inactive';\n\t          _this2.error = new Error('Error during Kuzzle subscription: ' + error.message);\n\t          _this2.emit('done', _this2.error);\n\t          return null;\n\t        }\n\t\n\t        _this2.roomId = result.roomId;\n\t        _this2.channel = result.channel;\n\t        _this2.roomstate = 'active';\n\t\n\t        if (!_this2.isListening) {\n\t          _this2.kuzzle.addListener('disconnected', _this2.deactivate);\n\t          _this2.kuzzle.addListener('tokenExpired', _this2.deactivate);\n\t          _this2.kuzzle.addListener('reconnected', _this2.resubscribeConditional);\n\t          _this2.isListening = true;\n\t        }\n\t\n\t        _this2.emit('done', null, _this2);\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unsubscribes from Kuzzle.\n\t     *\n\t     * Stop listening immediately.\n\t     * @param {responseCallback} cb - Handles the query response\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(cb) {\n\t      if (this.roomstate === 'subscribing') {\n\t        if (cb) {\n\t          cb(new Error('Cannot unsubscribe a room while a subscription attempt is underway'));\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (this.isListening) {\n\t        this.kuzzle.removeListener('disconnected', this.deactivate);\n\t        this.kuzzle.removeListener('tokenExpired', this.deactivate);\n\t        this.kuzzle.removeListener('reconnected', this.resubscribeConditional);\n\t        this.isListening = false;\n\t      }\n\t\n\t      if (this.roomstate === 'active') {\n\t        this.kuzzle.unsubscribe(this, cb);\n\t      } else if (cb) {\n\t        cb(null, this.roomId);\n\t      }\n\t\n\t      this.roomstate = 'inactive';\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Notify listeners\n\t     *\n\t     * @param {Object} data - data to send. Must contain `data.type` as eventName.\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'notify',\n\t    value: function notify(data) {\n\t      if (data.type === undefined) {\n\t        throw new Error('Room.notify: argument must match {type: <document|user>}');\n\t      }\n\t      if (!data.fromSelf || this.subscribeToSelf) {\n\t        this.emit(data.type, data);\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Registers a callback to be called with a subscription result\n\t     * @param {Function} cb\n\t     */\n\t\n\t  }, {\n\t    key: 'onDone',\n\t    value: function onDone(cb) {\n\t      if (!cb || typeof cb !== 'function') {\n\t        throw new Error('Room.onDone: a callback argument is required.');\n\t      }\n\t\n\t      if (this.error) {\n\t        cb(this.error);\n\t      } else if (this.roomstate === 'active') {\n\t        cb(null, this);\n\t      } else {\n\t        this.once('done', cb);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Room;\n\t}(KuzzleEventEmitter);\n\t\n\tmodule.exports = Room;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Document = __webpack_require__(2);\n\t\n\t/**\n\t * @param {Collection} collection\n\t * @param {object} filters\n\t * @param {object} options\n\t * @param {object} raw \n\t * @property {Collection} collection\n\t * @property {number} total\n\t * @property {Document[]} documents\n\t * @property {object} aggregations\n\t * @property {object} options\n\t * @property {object} filters\n\t * @property {number} fetched\n\t * @constructor\n\t */\n\t\n\tvar SearchResult = function () {\n\t  function SearchResult(collection, filters, options, raw) {\n\t    _classCallCheck(this, SearchResult);\n\t\n\t    Object.defineProperties(this, {\n\t      // read-only properties\n\t      collection: {\n\t        value: collection,\n\t        enumerable: true\n\t      },\n\t      total: {\n\t        value: raw.result.total,\n\t        enumerable: true\n\t      },\n\t      documents: {\n\t        value: raw.result.hits.map(function (doc) {\n\t          var d = new Document(collection, doc._id, doc._source, doc._meta);\n\t          d.version = doc._version;\n\t          return d;\n\t        }),\n\t        enumerable: true\n\t      },\n\t      aggregations: {\n\t        value: raw.result.aggregations || {},\n\t        enumerable: true\n\t      },\n\t      options: {\n\t        value: {\n\t          from: options.from,\n\t          size: options.size,\n\t          scrollId: raw.result._scroll_id\n\t        },\n\t        enumerable: true\n\t      },\n\t      filters: {\n\t        value: filters || {},\n\t        enumerable: true\n\t      },\n\t      // writable properties\n\t      fetched: {\n\t        value: raw.result.hits.length,\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    Object.freeze(this.filters);\n\t    Object.freeze(this.options);\n\t    Object.freeze(this.aggregations);\n\t\n\t    // promisifying\n\t    if (this.collection.kuzzle.bluebird) {\n\t      var whitelist = ['fetchNext'];\n\t\n\t      return this.collection.kuzzle.bluebird.promisifyAll(this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          return passes && whitelist.includes(name);\n\t        }\n\t      });\n\t    }\n\t\n\t    return this;\n\t  }\n\t\n\t  /**\n\t   * @param {function} cb\n\t   */\n\t\n\t\n\t  _createClass(SearchResult, [{\n\t    key: 'fetchNext',\n\t    value: function fetchNext(cb) {\n\t      var _this = this;\n\t\n\t      var updateAfterSearch = function updateAfterSearch(error, result) {\n\t        if (error) {\n\t          return cb(error);\n\t        }\n\t\n\t        result.fetched += _this.fetched;\n\t        cb(null, result);\n\t      };\n\t\n\t      this.collection.kuzzle.callbackRequired('SearchResult.fetchNext', cb);\n\t\n\t      if (this.fetched >= this.total) {\n\t        return cb(null, null);\n\t      }\n\t\n\t      // retrieve next results with scroll if original search use it\n\t      if (this.options.scrollId) {\n\t        this.collection.scroll(this.options.scrollId, null, this.filters || {}, updateAfterSearch);\n\t        return;\n\t      }\n\t\n\t      // retrieve next results using ES's search_after\n\t      if (this.options.size !== undefined && this.filters.sort) {\n\t        var filters = Object.assign({}, this.filters, { search_after: [] });\n\t\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = filters.sort[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var sortRule = _step.value;\n\t\n\t            filters.search_after.push(this.documents[this.documents.length - 1].content[Object.keys(sortRule)[0]]);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t\n\t        this.collection.search(filters, { size: this.options.size }, updateAfterSearch);\n\t        return;\n\t      }\n\t\n\t      // retrieve next results with from/size if original search use it\n\t      if (this.options.from !== undefined && this.options.size !== undefined) {\n\t        // check if we need to do next request to fetch all matching documents\n\t        var opts = {\n\t          from: this.options.from + this.options.size,\n\t          size: this.options.size\n\t        };\n\t\n\t        if (opts.from >= this.total) {\n\t          return cb(null, null);\n\t        }\n\t\n\t        this.collection.search(this.filters, opts, updateAfterSearch);\n\t        return;\n\t      }\n\t\n\t      cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n\t    }\n\t  }]);\n\t\n\t  return SearchResult;\n\t}();\n\t\n\tmodule.exports = SearchResult;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar RTWrapper = __webpack_require__(4);\n\t\n\tvar SocketIO = function (_RTWrapper) {\n\t  _inherits(SocketIO, _RTWrapper);\n\t\n\t  function SocketIO(host, options) {\n\t    _classCallCheck(this, SocketIO);\n\t\n\t    var _this = _possibleConstructorReturn(this, (SocketIO.__proto__ || Object.getPrototypeOf(SocketIO)).call(this, host, options));\n\t\n\t    _this.socket = null;\n\t    _this.forceDisconnect = false;\n\t    _this.eventsWrapper = {};\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Connect to the SocketIO server\n\t   */\n\t\n\t\n\t  _createClass(SocketIO, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\t\n\t      _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'connect', this).call(this);\n\t\n\t      this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n\t        reconnection: this.autoReconnect,\n\t        reconnectionDelay: this.reconnectionDelay,\n\t        forceNew: true\n\t      });\n\t\n\t      this.socket.on('connect', function () {\n\t        return _this2.clientConnected();\n\t      });\n\t      this.socket.on('connect_error', function (error) {\n\t        return _this2.clientNetworkError(error);\n\t      });\n\t\n\t      this.socket.on('disconnect', function () {\n\t        if (_this2.forceDisconnect) {\n\t          _this2.clientDisconnected();\n\t        } else {\n\t          var error = new Error('An error occurred, kuzzle may not be ready yet');\n\t          error.status = 500;\n\t\n\t          _this2.clientNetworkError(error);\n\t        }\n\t\n\t        _this2.forceDisconnect = false;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Registers a callback on an event.\n\t     *\n\t     * @param {string} event\n\t     * @param {function} callback\n\t     */\n\t\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(event, callback) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this._addEventWrapper(event, callback, once);\n\t      _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'addListener', this).call(this, event, callback, once);\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'prependListener',\n\t    value: function prependListener(event, callback) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this._addEventWrapper(event, callback, once);\n\t      return _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'prependListener', this).call(this, event, callback, once);\n\t    }\n\t\n\t    /**\n\t     * Unregisters a callback from an event.\n\t     *\n\t     * @param {string} event\n\t     * @param {function} callback\n\t     */\n\t\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(event, callback) {\n\t      if (this.eventsWrapper[event]) {\n\t        this.eventsWrapper[event].listeners.delete(callback);\n\t\n\t        if (this.eventsWrapper[event].listeners.size === 0) {\n\t          this.socket.off(event, this.eventsWrapper[event].wrapper);\n\t          delete this.eventsWrapper[event];\n\t        }\n\t\n\t        _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'removeListener', this).call(this, event, callback);\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unregisters all listeners either from an event, or from all events\n\t     *\n\t     * @param {string} [event]\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAllListeners',\n\t    value: function removeAllListeners(event) {\n\t      if (event !== undefined) {\n\t        if (this.eventsWrapper[event] !== undefined) {\n\t          var _iteratorNormalCompletion = true;\n\t          var _didIteratorError = false;\n\t          var _iteratorError = undefined;\n\t\n\t          try {\n\t            for (var _iterator = this.eventsWrapper[event].listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t              var listener = _step.value;\n\t\n\t              this.removeListener(event, listener);\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError = true;\n\t            _iteratorError = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion && _iterator.return) {\n\t                _iterator.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError) {\n\t                throw _iteratorError;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        var _iteratorNormalCompletion2 = true;\n\t        var _didIteratorError2 = false;\n\t        var _iteratorError2 = undefined;\n\t\n\t        try {\n\t          for (var _iterator2 = Object.keys(this.eventsWrapper)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t            var _event = _step2.value;\n\t\n\t            this.removeAllListeners(_event);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError2 = true;\n\t          _iteratorError2 = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t              _iterator2.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError2) {\n\t              throw _iteratorError2;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Sends a payload to the connected server\n\t     *\n\t     * @param {Object} payload\n\t     */\n\t\n\t  }, {\n\t    key: 'send',\n\t    value: function send(payload) {\n\t      this.socket.emit('kuzzle', payload);\n\t    }\n\t\n\t    /**\n\t     * Closes the connection\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      this.forceDisconnect = true;\n\t      this.state = 'offline';\n\t      this.socket.close();\n\t      this.socket = null;\n\t    }\n\t  }, {\n\t    key: '_addEventWrapper',\n\t    value: function _addEventWrapper(event, callback) {\n\t      var _this3 = this;\n\t\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!this.eventsWrapper[event]) {\n\t        var wrapper = function wrapper() {\n\t          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t            args[_key] = arguments[_key];\n\t          }\n\t\n\t          return _this3.emit.apply(_this3, [event].concat(args));\n\t        };\n\t\n\t        this.eventsWrapper[event] = {\n\t          wrapper: wrapper,\n\t          listeners: new Set()\n\t        };\n\t\n\t        if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n\t          if (once) {\n\t            this.socket.once(event, wrapper);\n\t          } else {\n\t            this.socket.on(event, wrapper);\n\t          }\n\t        }\n\t      }\n\t\n\t      this.eventsWrapper[event].listeners.add(callback);\n\t    }\n\t  }]);\n\t\n\t  return SocketIO;\n\t}(RTWrapper);\n\t\n\tmodule.exports = SocketIO;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar RTWrapper = __webpack_require__(4);\n\t\n\tvar WebSocketClient = void 0;\n\t\n\tvar WSNode = function (_RTWrapper) {\n\t  _inherits(WSNode, _RTWrapper);\n\t\n\t  function WSNode(host, options) {\n\t    _classCallCheck(this, WSNode);\n\t\n\t    var _this = _possibleConstructorReturn(this, (WSNode.__proto__ || Object.getPrototypeOf(WSNode)).call(this, host, options));\n\t\n\t    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"ws\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t    _this.client = null;\n\t    _this.lasturl = null;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Connect to the websocket server\n\t   */\n\t\n\t\n\t  _createClass(WSNode, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\t\n\t      var url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n\t          opts = typeof window !== 'undefined' ? undefined : { perMessageDeflate: false };\n\t\n\t      _get(WSNode.prototype.__proto__ || Object.getPrototypeOf(WSNode.prototype), 'connect', this).call(this);\n\t\n\t      if (url !== this.lasturl) {\n\t        this.wasConnected = false;\n\t        this.lasturl = url;\n\t      }\n\t\n\t      this.client = new WebSocketClient(url, opts);\n\t\n\t      this.client.onopen = function () {\n\t        _this2.clientConnected();\n\t      };\n\t\n\t      this.client.onclose = function (closeEvent, message) {\n\t        var status = void 0,\n\t            reason = message;\n\t\n\t        if (typeof closeEvent === 'number') {\n\t          status = closeEvent;\n\t        } else {\n\t          status = closeEvent.code;\n\t\n\t          if (closeEvent.reason) {\n\t            reason = closeEvent.reason;\n\t          }\n\t        }\n\t\n\t        if (status === 1000) {\n\t          _this2.clientDisconnected();\n\t        }\n\t        // do not forward a connection close error if no \n\t        // connection has been previously established\n\t        else if (_this2.wasConnected) {\n\t            var error = new Error(reason);\n\t            error.status = status;\n\t\n\t            _this2.clientNetworkError(error);\n\t          }\n\t      };\n\t\n\t      this.client.onerror = function (error) {\n\t        var err = error instanceof Error && error || new Error(error);\n\t\n\t        _this2.clientNetworkError(err);\n\t      };\n\t\n\t      this.client.onmessage = function (payload) {\n\t        var data = JSON.parse(payload.data || payload);\n\t\n\t        if (data.room) {\n\t          _this2.emit(data.room, data);\n\t        } else {\n\t          _this2.emit('discarded', data);\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Sends a payload to the connected server\n\t     *\n\t     * @param {Object} payload\n\t     */\n\t\n\t  }, {\n\t    key: 'send',\n\t    value: function send(payload) {\n\t      if (this.client && this.client.readyState === this.client.OPEN) {\n\t        this.client.send(JSON.stringify(payload));\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Closes the connection\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      this.state = 'offline';\n\t      this.removeAllListeners();\n\t      this.wasConnected = false;\n\t      if (this.client) {\n\t        this.client.close();\n\t      }\n\t      this.client = null;\n\t      this.stopRetryingToConnect = true;\n\t    }\n\t  }]);\n\t\n\t  return WSNode;\n\t}(RTWrapper);\n\t\n\tmodule.exports = WSNode;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSearchResult = __webpack_require__(7),\n\t  Document = __webpack_require__(2),\n\t  CollectionMapping = __webpack_require__(11),\n\t  Room = __webpack_require__(6);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n\t * or like a room for pub/sub messages.\n\t *\n\t * @property {string} collection\n\t * @property {string} index\n\t * @property {Kuzzle} kuzzle\n\t * @property {Array.<string>} collection\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @param {string} collection - name of the data collection to handle\n\t * @param {string} index - Index containing the data collection\n\t * @constructor\n\t */\n\tfunction Collection(kuzzle, collection, index) {\n\t  if (!index || !collection) {\n\t    throw new Error('The Collection object constructor needs an index and a collection arguments');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    index: {\n\t      value: index,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (controller, action) {\n\t      return {\n\t        controller: controller,\n\t        action: action,\n\t        collection: this.collection,\n\t        index: this.index\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['subscribe'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of documents matching the provided set of filters.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.count = function (filters, options, cb) {\n\t  var query = {body: filters};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.count', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new empty data collection, with no associated mapping.\n\t * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n\t * want to create and prepare data collections before storing documents in it.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.create = function (options, cb) {\n\t  var data = {},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n\t *        If the same document already exists:\n\t *          - resolves with an error if set to \"error\".\n\t *          - replaces the existing document if set to \"replace\"\n\t *\n\t * @param {string} [id] - (optional) document identifier\n\t * @param {object} document - either an instance of a Document object, or a document\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tCollection.prototype.createDocument = function (id, document, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'create';\n\t\n\t  if (id && typeof id !== 'string') {\n\t    cb = options;\n\t    options = document;\n\t    document = id;\n\t    id = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  if (options && options.ifExist) {\n\t    if (options.ifExist === 'replace') {\n\t      action = 'createOrReplace';\n\t    }\n\t    else if (options.ifExist !== 'error') {\n\t      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n\t    }\n\t  }\n\t\n\t  if (id) {\n\t    data._id = id;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    var doc;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    doc.version = res.result._version;\n\t    cb(null, doc);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete persistent documents.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Collection} this\n\t */\n\tCollection.prototype.deleteDocument = function (arg, options, cb) {\n\t  var\n\t    action,\n\t    data = {};\n\t\n\t  if (typeof arg === 'string') {\n\t    data._id = arg;\n\t    action = 'delete';\n\t  } else {\n\t    data.body = {query: arg};\n\t    action = 'deleteByQuery';\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      cb(err);\n\t    }\n\t    else {\n\t      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Deletes the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.deleteSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Returns a boolean indicating whether or not a document with provided ID exists.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} options [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.documentExists = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve a single stored document using its unique document ID.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.fetchDocument = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiates a CollectionMapping object containing the current mapping of this collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.getMapping = function (options, cb) {\n\t  var kuzzleMapping;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\t\n\t  kuzzleMapping = new CollectionMapping(this);\n\t  kuzzleMapping.refresh(options, cb);\n\t};\n\t\n\t/**\n\t * Create the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Create or replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create or replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Delete specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to delete\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Get specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Update the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to update\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n\t    cb(err, res && res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Retrieves the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.getSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Publish a realtime message\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} document - either a Document instance or a JSON object\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.publishMessage = function (document, options, cb) {\n\t  var data = {};\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replace an existing document with a new one.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to replace\n\t * @param {object} content - JSON object representing the new document version\n\t * @param {object} [options] - additional arguments\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Executes an advanced search on the data collection.\n\t *\n\t * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function.\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\t\n\tCollection.prototype.search = function (filters, options, cb) {\n\t  var\n\t    query = {body: filters},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.search', cb);\n\t\n\t  self.kuzzle.query(self.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(self, filters, options, result));\n\t  });\n\t};\n\t\n\t/**\n\t * A \"scroll\" option can be passed to search queries, creating persistent\n\t * paginated results.\n\t * This method can be used to manually get the next page of a search result,\n\t * instead of using KuzzleSearchResult.next()\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {object} [filters]\n\t * @param {responseCallback} cb\n\t */\n\tCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scroll: scrollId is required');\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(self, filters, options, result));\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieves next result of a search with scroll query.\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n\t  var\n\t    data = { scrollId: scrollId };\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scrollSpecifications: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\t\n\t  this.kuzzle.query(\n\t    { controller: 'collection', action: 'scrollSpecifications'},\n\t    data,\n\t    options,\n\t    function (err, res) {\n\t      cb (err, err ? undefined : res.result);\n\t    }\n\t  );\n\t};\n\t\n\t/**\n\t * Searches specifications across indexes/collections according to the provided filters\n\t *\n\t * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.searchSpecifications = function (filters, options, cb) {\n\t  var\n\t    data = { body: { query: filters } },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\t\n\t  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a subscription room to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @returns {*} KuzzleRoom object\n\t */\n\tCollection.prototype.room = function (filters, options) {\n\t  return new Room(this, filters, options);\n\t};\n\t\n\t/**\n\t * Subscribes to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @param {responseCallback} notificationCB - called for each new notification\n\t * @returns {*} KuzzleRoom object\n\t */\n\tCollection.prototype.subscribe = function (filters, options, notificationCB) {\n\t  var\n\t    evtName,\n\t    room;\n\t\n\t  if (!notificationCB && typeof options === 'function') {\n\t    notificationCB = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.subscribe', notificationCB);\n\t\n\t  evtName = (options && options.users && options.users !== 'none') ? 'user' : 'document';\n\t  room = new Room(this, filters, options);\n\t\n\t  room.subscribe().on(evtName, notificationCB);\n\t  return room;\n\t};\n\t\n\t/**\n\t * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n\t * This method is a lot faster than removing all documents using a query.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.truncate = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Update parts of a document\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to update\n\t * @param {object} content - JSON object containing changes to perform on the document\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n\t  var data = {\n\t      _id: documentId,\n\t      body: content\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options && options.retryOnConflict) {\n\t    data.retryOnConflict = options.retryOnConflict;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    (new Document(self, res.result._id)).refresh(cb);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Updates the current specifications of this collection\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Validates the provided specifications\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.valid);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - document id\n\t * @param {object} content - document content\n\t * @constructor\n\t */\n\tCollection.prototype.document = function (id, content) {\n\t  return new Document(this, id, content);\n\t};\n\t\n\t/**\n\t * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n\t * @constructor\n\t */\n\tCollection.prototype.collectionMapping = function (mapping) {\n\t  return new CollectionMapping(this, mapping);\n\t};\n\t\n\tmodule.exports = Collection;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n\t *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n\t *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n\t *  the amount of data you stored in a collection and the complexity of your database.\n\t *\n\t *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n\t *\n\t * @param {object} collection - Instance of the inherited Collection object\n\t * @param {object} [mapping] - mappings\n\t * @constructor\n\t */\n\tfunction CollectionMapping(collection, mapping) {\n\t  Object.defineProperties(this, {\n\t    //read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    mapping: {\n\t      value: mapping || {},\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['set'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Applies the new mapping to the data collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tCollectionMapping.prototype.apply = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      body: {\n\t        properties: this.mapping\n\t      }\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n\t    if (err) {\n\t      return cb && cb(err);\n\t    }\n\t\n\t    self.refresh(options, cb);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with the mapping stored in Kuzzle\n\t *\n\t * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tCollectionMapping.prototype.refresh = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    if (res.result[self.collection.index]) {\n\t      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n\t        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\t\n\t        // Mappings can be empty. The mapping property should never be \"undefined\"\n\t        if (self.mapping === undefined) {\n\t          self.mapping = {};\n\t        }\n\t      } else {\n\t        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n\t      }\n\t    } else {\n\t      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds or updates a field mapping.\n\t *\n\t * Changes made by this function wont be applied until you call the apply method\n\t *\n\t * @param {string} field - Name of the field from which the mapping is to be added or updated\n\t * @param {object} mapping - corresponding field mapping\n\t * @returns {CollectionMapping}\n\t */\n\tCollectionMapping.prototype.set = function (field, mapping) {\n\t  this.mapping[field] = mapping;\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = CollectionMapping;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t// Parameter mutualization\n\tvar\n\t  getId = {getter: true, required: ['_id']},\n\t  getIdField = {getter: true, required: ['_id', 'field']},\n\t  getKeys = {getter: true, required: ['keys']},\n\t  getMember = {getter: true, required: ['_id', 'member']},\n\t  getxScan = {\n\t    getter: true, \n\t    required: ['_id', 'cursor'], \n\t    opts: ['match', 'count'],\n\t    mapResults: mapScanResults\n\t  },\n\t  getZrange = {\n\t    getter: true,\n\t    required: ['_id', 'start', 'stop'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  getZrangeBy = {\n\t    getter: true,\n\t    required: ['_id', 'min', 'max'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  setId = {required: ['_id']},\n\t  setIdValue = {required: ['_id', 'value']};\n\t\n\t// Redis commands\n\tvar\n\t  commands = {\n\t    append: setIdValue,\n\t    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n\t    bitop: {required: ['_id', 'operation', 'keys']},\n\t    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n\t    dbsize: {getter: true},\n\t    decr: setId,\n\t    decrby: setIdValue,\n\t    del: {required: ['keys']},\n\t    exists: getKeys,\n\t    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n\t    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n\t    flushdb: {mapResults: mapNoResult},\n\t    geoadd: {required: ['_id', 'points']},\n\t    geodist: {\n\t      getter: true,\n\t      required: ['_id', 'member1', 'member2'],\n\t      opts: ['unit'],\n\t      mapResults: parseFloat\n\t    },\n\t    geohash: {getter: true, required: ['_id', 'members']},\n\t    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n\t    georadius: {\n\t      getter: true,\n\t      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    georadiusbymember: {\n\t      getter: true,\n\t      required: ['_id', 'member', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    get: getId,\n\t    getbit: {getter: true, required: ['_id', 'offset']},\n\t    getrange: {getter: true, required: ['_id', 'start', 'end']},\n\t    getset: setIdValue,\n\t    hdel: {required: ['_id', 'fields']},\n\t    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n\t    hget: getIdField,\n\t    hgetall: {getter: true, required: ['_id']},\n\t    hincrby: {required: ['_id', 'field', 'value']},\n\t    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n\t    hkeys: getId,\n\t    hlen: getId,\n\t    hmget: {getter: true, required: ['_id', 'fields']},\n\t    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n\t    hscan: getxScan,\n\t    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n\t    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n\t    hstrlen: getIdField,\n\t    hvals: getId,\n\t    incr: setId,\n\t    incrby: setIdValue,\n\t    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n\t    keys: {getter: true, required: ['pattern']},\n\t    lindex: {getter: true, required: ['_id', 'idx']},\n\t    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n\t    llen: getId,\n\t    lpop: setId,\n\t    lpush: {required: ['_id', 'values']},\n\t    lpushx: setIdValue,\n\t    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n\t    lrem: {required: ['_id', 'count', 'value']},\n\t    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n\t    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n\t    mget: getKeys,\n\t    mset: {required: ['entries'], mapResults: mapNoResult},\n\t    msetnx: {required: ['entries'], mapResults: Boolean},\n\t    object: {getter: true, required: ['_id', 'subcommand']},\n\t    persist: {required: ['_id'], mapResults: Boolean},\n\t    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n\t    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n\t    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n\t    pfcount: getKeys,\n\t    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n\t    ping: {getter: true},\n\t    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n\t    pttl: getId,\n\t    randomkey: {getter: true},\n\t    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n\t    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n\t    rpop: setId,\n\t    rpoplpush: {required: ['source', 'destination']},\n\t    rpush: {required: ['_id', 'values']},\n\t    rpushx: setIdValue,\n\t    sadd: {required: ['_id', 'members']},\n\t    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n\t    scard: getId,\n\t    sdiff: {getter: true, required: ['_id', 'keys']},\n\t    sdiffstore: {required: ['_id', 'keys', 'destination']},\n\t    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n\t    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n\t    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n\t    sinter: getKeys,\n\t    sinterstore: {required: ['destination', 'keys']},\n\t    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n\t    smembers: getId,\n\t    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n\t    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n\t    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n\t    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n\t    srem: {required: ['_id', 'members']},\n\t    sscan: getxScan,\n\t    strlen: getId,\n\t    sunion: getKeys,\n\t    sunionstore: {required: ['destination', 'keys']},\n\t    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n\t    touch: {required: ['keys']},\n\t    ttl: getId,\n\t    type: getId,\n\t    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n\t    zcard: getId,\n\t    zcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zincrby: {required: ['_id', 'member', 'value']},\n\t    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n\t    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zrange: getZrange,\n\t    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrangebyscore: getZrangeBy,\n\t    zrank: getMember,\n\t    zrem: {required: ['_id', 'members']},\n\t    zremrangebylex: {required: ['_id', 'min', 'max']},\n\t    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n\t    zremrangebyscore: {required: ['_id', 'min', 'max']},\n\t    zrevrange: getZrange,\n\t    zrevrangebyscore: getZrangeBy,\n\t    zrevrank: getMember,\n\t    zscan: getxScan,\n\t    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n\t    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n\t  };\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t * Kuzzle's memory storage is a separate data store from the database layer.\n\t * It is internaly based on Redis. You can access most of Redis functions (all\n\t * lowercased), except functions falling in the following categories:\n\t *\n\t *  - blocking functions\n\t *  - cluster commands\n\t *  - configuration commands\n\t *  - cursor functions\n\t *  - database administration commands\n\t *  - debugging functions\n\t *  - script based functions\n\t *  - transaction functions\n\t *\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @constructor\n\t */\n\tfunction MemoryStorage(kuzzle) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = [];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t// Dynamically builds this class' prototypes using the \"commands\" global variable\n\t(function () {\n\t  Object.keys(commands).forEach(function (command) {\n\t    MemoryStorage.prototype[command] = function () {\n\t      var\n\t        args = Array.prototype.slice.call(arguments),\n\t        options = null,\n\t        cb,\n\t        query = {\n\t          controller: 'ms',\n\t          action: command\n\t        },\n\t        data = {};\n\t\n\t      if (args.length && typeof args[args.length - 1] === 'function') {\n\t        cb = args.pop();\n\t      }\n\t\n\t      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\t\n\t      if (!commands[command].getter) {\n\t        data.body = {};\n\t      }\n\t\n\t      if (commands[command].required) {\n\t        commands[command].required.forEach(function (param) {\n\t          var value = args.shift();\n\t\n\t          if (value === undefined) {\n\t            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n\t          }\n\t\n\t          assignParameter(data, commands[command].getter, param, value);\n\t        });\n\t      }\n\t\n\t      if (args.length > 1) {\n\t        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n\t      }\n\t\n\t      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n\t        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n\t      }\n\t\n\t      if (args.length) {\n\t        options = Object.assign({}, args[0]);\n\t\n\t        if (Array.isArray(commands[command].opts)) {\n\t          commands[command].opts.forEach(function (opt) {\n\t            if (options[opt] !== null && options[opt] !== undefined) {\n\t              assignParameter(data, commands[command].getter, opt, options[opt]);\n\t              delete options[opt];\n\t            }\n\t          });\n\t        }\n\t      }\n\t\n\t      /*\n\t       Options function mapper does not necessarily need\n\t       options to be passed by clients.\n\t       */\n\t      if (typeof commands[command].opts === 'function') {\n\t        commands[command].opts(data, options || {});\n\t      }\n\t\n\t      this.kuzzle.query(query, data, options, cb && function (err, res) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t\n\t        if (commands[command].mapResults) {\n\t          return cb(null, commands[command].mapResults(res.result));\n\t        }\n\t\n\t        cb(null, res.result);\n\t      });\n\t\n\t      if (!commands[command].getter) {\n\t        return this;\n\t      }\n\t    };\n\t  });\n\t})();\n\t\n\t/**\n\t *\n\t * @param {object} data - target data object\n\t * @param {boolean} getter - tells if the command is a getter one\n\t * @param {string} name - parameter name\n\t * @param {*} value - parameter value\n\t */\n\tfunction assignParameter(data, getter, name, value) {\n\t  if (getter || name === '_id') {\n\t    data[name] = value;\n\t  }\n\t  else {\n\t    data.body[name] = value;\n\t  }\n\t}\n\t\n\t/**\n\t * Assign the provided options for the georadius* redis functions\n\t * to the request object, as expected by Kuzzle API\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignGeoRadiusOptions(data, options) {\n\t  var parsed = [];\n\t\n\t  Object.keys(options)\n\t    .filter(function (opt) {\n\t      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n\t    })\n\t    .forEach(function (opt) {\n\t      if (opt === 'withcoord' || opt === 'withdist') {\n\t        parsed.push(opt);\n\t        delete options[opt];\n\t      }\n\t      else if (opt === 'count' || opt === 'sort') {\n\t        if (opt === 'count') {\n\t          parsed.push('count');\n\t        }\n\t\n\t        parsed.push(options[opt]);\n\t      }\n\t\n\t      delete options[opt];\n\t    });\n\t\n\t  if (parsed.length > 0) {\n\t    data.options = parsed;\n\t  }\n\t}\n\t\n\t/**\n\t * Force the WITHSCORES option on z*range* routes\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignZrangeOptions(data, options) {\n\t  data.options = ['withscores'];\n\t\n\t  if (options.limit) {\n\t    data.limit = options.limit;\n\t    delete options.limit;\n\t  }\n\t}\n\t\n\t/**\n\t * Maps geopos results, from array<array<string>> to array<array<number>>\n\t *\n\t * @param {Array.<Array.<string>>} results\n\t * @return {Array.<Array.<Number>>}\n\t */\n\tfunction mapGeoposResults(results) {\n\t  return results.map(function (coords) {\n\t    return coords.map(function (latlon) {\n\t      return parseFloat(latlon);\n\t    });\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Maps georadius results to the format specified in the SDK documentation,\n\t * preventing different formats depending on the passed options\n\t *\n\t * Results can be either an array of point names, or an array\n\t * of arrays, each one of them containing the point name,\n\t * and additional informations depending on the passed options\n\t * (coordinates, distances)\n\t *\n\t * @param {Array} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapGeoRadiusResults(results) {\n\t  // Simple array of point names (no options provided)\n\t  if (!Array.isArray(results[0])) {\n\t    return results.map(function (point) {\n\t      return {name: point};\n\t    });\n\t  }\n\t\n\t  return results.map(function (point) {\n\t    // The point id is always the first item\n\t    var p = {\n\t        name: point[0]\n\t      },\n\t      i;\n\t\n\t    for (i = 1; i < point.length; i++) {\n\t      // withcoord result are in an array...\n\t      if (Array.isArray(point[i])) {\n\t        p.coordinates = point[i].map(function (coord) {\n\t          return parseFloat(coord);\n\t        });\n\t      }\n\t      else {\n\t        // ... and withdist are not\n\t        p.distance = parseFloat(point[i]);\n\t      }\n\t    }\n\t\n\t    return p;\n\t  });\n\t}\n\t\n\t/**\n\t * Map a string result to an array of strings.\n\t * Used to uniformize polymorphic results from redis\n\t *\n\t * @param {Array|string} results\n\t * @return {Array.<string>}\n\t */\n\tfunction mapStringToArray(results) {\n\t  return Array.isArray(results) ? results : [results];\n\t}\n\t\n\t/**\n\t * Map an array of strings to an array of integers\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Number>}\n\t */\n\tfunction mapArrayStringToArrayInt(results) {\n\t  return results.map(function (value) {\n\t    return parseInt(value);\n\t  });\n\t}\n\t\n\t/**\n\t * Disable results for routes like flushdb\n\t * @return {undefined}\n\t */\n\tfunction mapNoResult() {\n\t  return undefined;\n\t}\n\t\n\t/**\n\t * Map zrange results with WITHSCORES:\n\t * [\n\t *  \"member1\",\n\t *  \"score of member1\",\n\t *  \"member2\",\n\t *  \"score of member2\"\n\t * ]\n\t *\n\t * into the following format:\n\t * [\n\t *  {\"member\": \"member1\", \"score\": <score of member1>},\n\t *  {\"member\": \"member2\", \"score\": <score of member2>},\n\t * ]\n\t *\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapZrangeResults(results) {\n\t  var\n\t    buffer = null,\n\t    mapped = [];\n\t\n\t  results.forEach(function (value) {\n\t    if (buffer === null) {\n\t      buffer = value;\n\t    }\n\t    else {\n\t      mapped.push({member: buffer, score: parseFloat(value)});\n\t      buffer = null;\n\t    }\n\t  });\n\t\n\t  return mapped;\n\t}\n\t\n\t/**\n\t * Map *scan calls results, from:\n\t * [\n\t *   \"<cursor>\",\n\t *   [\n\t *     \"value1\",\n\t *     \"value2\", \n\t *     \"...\"\n\t *   ]\n\t * ]\n\t *\n\t * To:\n\t * {\n\t *   cursor: <cursor>,\n\t *   values: [\n\t *     \"value1\",\n\t *     \"value2\",\n\t *     \"...\"\n\t *   ]\n\t * }\n\t * \n\t * @param  {array.<string|array>} results \n\t * @return {object}\n\t */\n\tfunction mapScanResults(results) {\n\t  return {\n\t    cursor: results[0],\n\t    values: results[1]\n\t  };\n\t}\n\t\n\tmodule.exports = MemoryStorage;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t *\n\t * @param protocol\n\t * @param host\n\t * @param options\n\t * @returns {Object} Instantiated WebSocket/Socket.IO object\n\t */\n\t\n\tfunction network(protocol, host, options) {\n\t  switch (protocol) {\n\t    case 'websocket':\n\t      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n\t        throw new Error('Aborting: no websocket support detected.');\n\t      }\n\t      return new (__webpack_require__(9))(host, options);\n\t    case 'socketio':\n\t      if (!window.io) {\n\t        throw new Error('Aborting: no socket.io library loaded.');\n\t      }\n\t      return new (__webpack_require__(8))(host, options);\n\t    default:\n\t      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n\t  }\n\t}\n\t\n\tmodule.exports = network;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(3);\n\t\n\tfunction Profile(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteProfile'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateProfile'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['hydrate', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tProfile.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Profile\n\t  }\n\t});\n\t\n\t/**\n\t * Persist to the persistent layer the current profile\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.save = function (options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!this.content.policies) {\n\t    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.serialize();\n\t\n\t  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Add a policy in the policies list\n\t * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.addPolicy = function (policy) {\n\t\n\t  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n\t  }\n\t\n\t  if (!this.content.policies) {\n\t    this.content.policies = [];\n\t  }\n\t\n\t  this.content.policies.push(policy);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set policies list\n\t * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.setPolicies = function (policies) {\n\t\n\t  if (!Array.isArray(policies)) {\n\t    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t  }\n\t\n\t  policies.map(function (policy) {\n\t    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t    }\n\t  });\n\t\n\t  this.content.policies = policies;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this securityDocument\n\t */\n\tProfile.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Returns the list of policies associated to this profile.\n\t * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @return {object} an array of policies\n\t */\n\tProfile.prototype.getPolicies = function () {\n\t  return this.content.policies;\n\t};\n\t\n\tmodule.exports = Profile;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(3);\n\t\n\tfunction Role(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteRole'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateRole'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tRole.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Role\n\t  }\n\t});\n\t\n\t/**\n\t * Saves this role into Kuzzle.\n\t *\n\t * If this is a new role, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Role} this object\n\t */\n\tRole.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = Role;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  Role = __webpack_require__(15),\n\t  Profile = __webpack_require__(14),\n\t  User = __webpack_require__(5);\n\t\n\t/**\n\t * Kuzzle security constructor\n\t *\n\t * @param kuzzle\n\t * @returns {Security}\n\t * @constructor\n\t */\n\tfunction Security(kuzzle) {\n\t\n\t  Object.defineProperty(this, 'kuzzle', {\n\t    value: kuzzle\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (action) {\n\t      return {\n\t        controller: 'security',\n\t        action: action\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Retrieve a single Role using its unique role ID.\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchRole = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id) {\n\t    throw new Error('Id parameter is mandatory for fetchRole function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on roles according to a filter\n\t *\n\t * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t *\n\t */\n\tSecurity.prototype.searchRoles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = result.result.hits.map(function (doc) {\n\t      return new Role(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, roles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new role in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same role already exists: throw an error if sets to false.\n\t *        Replace the existing role otherwise\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createRole: cannot create a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a role in Kuzzle.\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'updateRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateRole: cannot update a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete role.\n\t *\n\t * There is a small delay between role deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Role id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteRole = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - role id\n\t * @param {object} content - role content\n\t * @param {object} meta - role metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.role = function(id, content, meta) {\n\t  return new Role(this, id, content, meta);\n\t};\n\t\n\t\n\t/**\n\t * Get a specific profile from kuzzle\n\t *\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchProfile = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchProfile function');\n\t  }\n\t\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n\t    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on profiles according to a filter\n\t *\n\t *\n\t * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchProfiles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new Profile(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new profile in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same profile already exists: throw an error if sets to false.\n\t *        Replace the existing profile otherwise\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - list of policies to attach to the new profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = { policies: policies };\n\t  }\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a profile in Kuzzle.\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - the list of policies to apply to this profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = {policies: policies};\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    var updatedContent = {};\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    Object.keys(res.result._source).forEach(function (property) {\n\t      updatedContent[property] = res.result._source[property];\n\t    });\n\t\n\t    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete profile.\n\t *\n\t * There is a small delay between profile deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteProfile = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollProfiles: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n\t    var profiles = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (profile) {\n\t      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\t\n\t      newProfile.version = profile._version;\n\t\n\t      profiles.push(newProfile);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      profiles: profiles,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - profile id\n\t * @param {object} content - profile content\n\t * @param {object} meta - profile metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.profile = function(id, content, meta) {\n\t  return new Profile(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Get a specific user from kuzzle using its unique ID\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchUser = function (id, options, cb) {\n\t  var\n\t    data = {_id: id},\n\t    self = this;\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchUser function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on user according to a filter\n\t *\n\t * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - same filters as documents filters\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchUsers = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId = null;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new User(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Replace an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.replaceUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new restricted user in Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profile` in `content` must only contains the profile id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (content.profileIds) {\n\t    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateUser: cannot update an user without an user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete user.\n\t *\n\t * There is a small delay between user deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteUser = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollUsers: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n\t    var users = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (user) {\n\t      var newUser = new User(self, user._id, user._source, user._meta);\n\t\n\t      newUser.version = user._version;\n\t\n\t      users.push(newUser);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      users: users,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - user id\n\t * @param {object} content - user content\n\t * @param {object} meta - user metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.user = function(id, content, meta) {\n\t  return new User(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Tells whether an action is allowed, denied or conditional based on the rights\n\t * rights provided as the first argument. An action is defined as a couple of\n\t * action and controller (mandatory), plus an index and a collection(optional).\n\t *\n\t * @param {object} rights - The rights rights associated to a user\n\t *                            (see getMyrights and getUserrights).\n\t * @param {string} controller - The controller to check the action onto.\n\t * @param {string} action - The action to perform.\n\t * @param {string} index - (optional) The name of index to perform the action onto.\n\t * @param {string} collection - (optional) The name of the collection to perform the action onto.\n\t *\n\t * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n\t *                   correspond to rights containing closures.\n\t *                   See also http://kuzzle.io/guide/#roles-definition\n\t */\n\tSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n\t  var filteredRights;\n\t\n\t  if (!rights || typeof rights !== 'object') {\n\t    throw new Error('rights parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!controller || typeof controller !== 'string') {\n\t    throw new Error('controller parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!action || typeof action !== 'string') {\n\t    throw new Error('action parameter is mandatory for isActionAllowed function');\n\t  }\n\t\n\t  // We filter in all the rights that match the request (including wildcards).\n\t  filteredRights = rights\n\t    .filter(function (right) {\n\t      return right.controller === controller || right.controller === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.action === action || right.action === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.index === index || right.index === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.collection === collection || right.collection === '*';\n\t    });\n\t\n\t  // Then, if at least one right allows the action, we return 'allowed'\n\t  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n\t    return 'allowed';\n\t  }\n\t  // If no right allows the action, we check for conditionals.\n\t  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n\t    return 'conditional';\n\t  }\n\t  // Otherwise we return 'denied'.\n\t  return 'denied';\n\t};\n\t\n\t\n\t/**\n\t * Gets the rights array of a given user.\n\t *\n\t * @param {string} userId The id of the user.\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {function} cb The callback containing the normalized array of rights.\n\t */\n\tSecurity.prototype.getUserRights = function (userId, options, cb) {\n\t  var\n\t    data = {_id: userId},\n\t    self = this;\n\t\n\t  if (!userId || typeof userId !== 'string') {\n\t    throw new Error('userId parameter is mandatory for getUserRights function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Create credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result._source);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete credentials of the specified <strategy> for the user <kuid> .\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieve a list of accepted fields per authentication strategy.\n\t *\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getAllCredentialFields = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve the list of accepted field names by the specified <strategy>.\n\t *\n\t * @param strategy\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Get credential information of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Check the existence of the specified <strategy>s credentials for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Updates credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Validate credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\tmodule.exports = Security;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\tvar rng;\n\t\n\tvar crypto = (window).crypto || (window).msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(18);\n\tvar bytesToUuid = __webpack_require__(17);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// kuzzle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8e46faa9aee312feeb8b","const\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('./eventEmitter'),\n  Collection = require('./Collection.js'),\n  Document = require('./Document.js'),\n  Security = require('./security/Security'),\n  MemoryStorage = require('./MemoryStorage'),\n  User = require('./security/User'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n */\nclass Kuzzle extends KuzzleEventEmitter {\n  constructor(host, options) {\n    super();\n\n    if (!host || host === '') {\n      throw new Error('host argument missing');\n    }\n\n    Object.defineProperties(this, {\n      // 'private' properties\n      eventActions: {\n        value: [\n          'connected',\n          'discarded',\n          'disconnected',\n          'loginAttempt',\n          'networkError',\n          'offlineQueuePush',\n          'offlineQueuePop',\n          'queryError',\n          'reconnected',\n          'tokenExpired'\n        ]\n      },\n      // configuration properties\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n        enumerable: true\n      },\n      defaultIndex: {\n        value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n        writable: true,\n        enumerable: true\n      },\n      jwt: {\n        value: undefined,\n        enumerable: true,\n        writable: true\n      },\n      protocol: {\n        value: (options && typeof options.protocol === 'string') ? options.protocol : 'websocket',\n        enumerable: true\n      },\n      sdkVersion: {\n        value: (typeof SDKVERSION === 'undefined') ? require('../package.json').version : SDKVERSION\n      },\n      volatile: {\n        value: {},\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      for (const opt of Object.keys(options)) {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    // Forward the subscribe query to the network wrapper\n    Object.defineProperty(this, 'subscribe', {\n      value: function(room, opts, subscribeCB) {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'subscribe',\n            index: room.collection.index,\n            collection: room.collection.collection,\n            volatile: this.volatile,\n            body: room.filters,\n            scope: room.scope,\n            state: room.state,\n            users: room.users\n          },\n          notificationCB = data => {\n            if (data.type === 'TokenExpired') {\n              this.unsetJwt();\n              return this.emit('tokenExpired');\n            }\n\n            if (data.type === 'document') {\n              const copy = Object.assign({}, data);\n              copy.document = new Document(room.collection, data.result._id, data.result._source, data.result._meta);\n              delete copy.result;\n              return room.notify(copy);\n            }\n\n            room.notify(data);\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkVersion: this.sdkVersion});\n\n        this.network.subscribe(object, opts, notificationCB, subscribeCB);\n      }\n    });\n\n    // Forward the unsubscribe query to the network wrapper\n    Object.defineProperty(this, 'unsubscribe', {\n      value: (room, unsubscribeCB) => {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'unsubscribe',\n            volatile: this.volatile,\n            body: {roomId: room.roomId}\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkVersion: this.sdkVersion});\n\n        this.network.unsubscribe(object, room.channel, unsubscribeCB);\n      }\n    });\n\n    /**\n     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n     * and is called by these methods\n     */\n    Object.defineProperty(this, 'callbackRequired', {\n      value: (errorMessagePrefix, callback) => {\n        if (!callback || typeof callback !== 'function') {\n          throw new Error(`${errorMessagePrefix}: a callback argument is required for read queries`);\n        }\n      }\n    });\n\n    /**\n     * Create an attribute security that embed all methods to manage Role, Profile and User\n     */\n    Object.defineProperty(this, 'security', {\n      value: new Security(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'memoryStorage', {\n      value: new MemoryStorage(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'collections',{\n      value: {},\n      writable: true\n    });\n\n    Object.defineProperty(this, 'eventTimeout',{\n      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n    });\n\n    Object.defineProperty(this, 'protectedEvents', {\n      value: {\n        connected: {timeout: this.eventTimeout},\n        error: {timeout: this.eventTimeout},\n        disconnected: {timeout: this.eventTimeout},\n        reconnected: {timeout: this.eventTimeout},\n        tokenExpired: {timeout: this.eventTimeout},\n        loginAttempt: {timeout: this.eventTimeout}\n      }\n    });\n\n    this.network = networkWrapper(this.protocol, host, options);\n\n    // Properties related to the network layer\n    // Accessing a property irrelevant for a given protocol\n    // (e.g. \"autoReconnect\" for the HTTP layer) should\n    // throw an exception\n    Object.defineProperties(this, {\n      autoQueue: {\n        enumerable: true,\n        get: () => this.network.autoQueue,\n        set: value => {\n          checkPropertyType('autoQueue', 'boolean', value);\n          this.network.autoQueue = value;\n        }\n      },\n      autoReconnect: {\n        enumerable: true,\n        get: () => this.network.autoReconnect\n      },\n      autoReplay: {\n        enumerable: true,\n        get: () => this.network.autoReplay,\n        set: value => {\n          checkPropertyType('autoReplay', 'boolean', value);\n          this.network.autoReplay = value;\n        }\n      },\n      host: {\n        enumerable: true,\n        get: () => this.network.host\n      },\n      offlineQueue: {\n        enumerable: true,\n        get: () => this.network.offlineQueue\n      },\n      offlineQueueLoader: {\n        enumerable: true,\n        get: () => this.network.offlineQueueLoader,\n        set: value => {\n          if (value !== null) {\n            checkPropertyType('offlineQueueLoader', 'function', value);\n          }\n          this.network.offlineQueueLoader = value;\n        }\n      },\n      port: {\n        enumerable: true,\n        get: () => this.network.port\n      },\n      queueFilter: {\n        enumerable: true,\n        get: () => this.network.queueFilter,\n        set: value => {\n          checkPropertyType('queueFilter', 'function', value);\n          this.network.queueFilter = value;\n        }\n      },\n      queueMaxSize: {\n        enumerable: true,\n        get: () => this.network.queueMaxSize,\n        set: value => {\n          checkPropertyType('queueMaxSize', 'number', value);\n          this.network.queueMaxSize = value;\n        }\n      },\n      queueTTL: {\n        enumerable: true,\n        get: () => this.network.queueTTL,\n        set: value => {\n          checkPropertyType('queueTTL', 'number', value);\n          this.network.queueTTL = value;\n        }\n      },\n      replayInterval: {\n        enumerable: true,\n        get: () => this.network.replayInterval,\n        set: value => {\n          checkPropertyType('replayInterval', 'number', value);\n          this.network.replayInterval = value;\n        }\n      },\n      reconnectionDelay: {\n        enumerable: true,\n        get: () => this.network.reconnectionDelay\n      },\n      sslConnection: {\n        eumerable: true,\n        get: () => this.network.ssl\n      }\n    });\n\n    this.network.addListener('offlineQueuePush', data => this.emit('offlineQueuePush', data));\n    this.network.addListener('offlineQueuePop', data => this.emit('offlineQueuePop', data));\n    this.network.addListener('queryError', (err, query) => this.emit('queryError', err, query));\n\n    this.network.addListener('tokenExpired', () => {\n      this.unsetJwt();\n      this.emit('tokenExpired');\n    });\n\n    if (this.bluebird) {\n      return this.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n            'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n            'checkToken', 'whoAmI', 'updateSelf', 'getMyRights', 'getMyCredentials',\n            'createMyCredentials', 'deleteMyCredentials', 'updateMyCredentials', 'validateMyCredentials',\n            'createIndex', 'refreshIndex', 'getAutoRefresh', 'setAutoRefresh', 'connect'\n          ];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n  * Emit an event to all registered listeners\n  * An event cannot be emitted multiple times before a timeout has been reached.\n  */\n  emit (eventName, ...payload) {\n    const\n      now = Date.now(),\n      protectedEvent = this.protectedEvents[eventName];\n\n    if (protectedEvent) {\n      if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n        return false;\n      }\n      protectedEvent.lastEmitted = now;\n    }\n\n    super.emit(eventName, ...payload);\n  }\n\n\n  /**\n   * Connects to a Kuzzle instance using the provided host name\n   * @param {function} [cb] Connection callback\n   */\n  connect (cb) {\n    if (this.network.state !== 'offline') {\n      if (cb) {\n        cb(null, this);\n      }\n      return;\n    }\n\n    this.network.connect();\n\n    this.network.addListener('connect', () => {\n      this.emit('connected');\n\n      if (cb) {\n        cb(null, this);\n      }\n    });\n\n    this.network.addListener('networkError', error => {\n      const connectionError = new Error(`Unable to connect to kuzzle proxy server at ${this.network.host}:${this.network.port}`);\n\n      connectionError.internal = error;\n      this.emit('networkError', connectionError);\n\n      if (cb) {\n        cb(connectionError);\n      }\n    });\n\n    this.network.addListener('disconnect', () => {\n      this.disconnect();\n      this.emit('disconnected');\n    });\n\n    this.network.addListener('reconnect', () => {\n      if (this.jwt) {\n        this.checkToken(this.jwt, (err, res) => {\n          // shouldn't obtain an error but let's invalidate the token anyway\n          if (err || !res.valid) {\n            this.unsetJwt();\n          }\n\n          this.emit('reconnected');\n        });\n      } else {\n        this.emit('reconnected');\n      }\n    });\n\n    this.network.on('discarded', data => this.emit('discarded', data));\n  }\n\n  /**\n   * Set the jwt used to query kuzzle\n   * @param token\n   * @returns {Kuzzle}\n   */\n  setJwt (token) {\n    if (typeof token === 'string') {\n      this.jwt = token;\n    } else if (typeof token === 'object') {\n      if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n        this.jwt = token.result.jwt;\n      } else {\n        this.emit('loginAttempt', {\n          success: false,\n          error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n        });\n\n        return this;\n      }\n    } else {\n      this.emit('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n      return this;\n    }\n\n    this.emit('loginAttempt', {success: true});\n    return this;\n  }\n\n  /**\n   * Unset the jwt used to query kuzzle\n   * @returns {Kuzzle}\n   */\n  unsetJwt () {\n    this.jwt = undefined;\n    return this;\n  }\n\n  /**\n   * Get the jwt used by kuzzle\n   * @returns {Kuzzle}\n   */\n  getJwt () {\n    return this.jwt;\n  }\n\n  /**\n   * Send login request to kuzzle with credentials\n   * If login success, store the jwt into kuzzle object\n   *\n   * @param strategy\n   * @param credentials\n   * @param expiresIn\n   * @param cb\n   */\n  login (strategy, ...args) {\n    if (!strategy || typeof strategy !== 'string') {\n      throw new Error('Kuzzle.login: strategy required');\n    }\n\n    const \n      request = {\n        strategy,\n        body: {}\n      };\n\n    let cb = null;\n\n    // Handle arguments (credentials, expiresIn, cb)\n    if (args[0]) {\n      if (typeof args[0] === 'object') {\n        request.body = args[0];\n      } else if (typeof args[0] === 'number' || typeof args[0] === 'string') {\n        request.expiresIn = args[0];\n      } else if (typeof args[0] === 'function') {\n        cb = args[0];\n      }\n    }\n    if (args[1]) {\n      if (typeof args[1] === 'number' || typeof args[1] === 'string') {\n        request.expiresIn = args[1];\n      } else if (typeof args[1] === 'function') {\n        cb = args[1];\n      }\n    }\n    if (args[2] && typeof args[2] === 'function') {\n      cb = args[2];\n    }\n\n    this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, (error, response) => {\n      if (!error) {\n        if (response.result.jwt) {\n          this.setJwt(response.result.jwt);\n        }\n\n        cb && cb(null, response.result);\n      }\n      else {\n        cb && cb(error);\n        this.emit('loginAttempt', {success: false, error: error.message});\n      }\n    });\n  }\n\n  /**\n   * Create credentials of the specified <strategy> for the current user.\n   *\n   * @param credentials\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  createMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result._source);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Delete credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  deleteMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Get credential information of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   */\n  getMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Update credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentals\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  updateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Validate credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentials\n   * @param options\n   * @param cb\n   */\n  validateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Create a kuzzle index\n   *\n   * @param {string} index\n   * @param {object} [options]\n   * @param {responseCallback} cb\n   * @returns {Kuzzle}\n   */\n  createIndex (index, options, cb) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.createIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'index', action: 'create', index}, {}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Send logout request to kuzzle with jwt.\n   *\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  logout (cb) {\n    const\n      request = {\n        action: 'logout',\n        controller: 'auth',\n        requestId: uuidv4(),\n        body: {}\n      };\n\n    this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, error => {\n      if (typeof cb === 'function') {\n        cb(error, this);\n      }\n    });\n\n    return this.unsetJwt();\n  }\n\n  /**\n   * Checks whether a given jwt token still represents a valid session in Kuzzle.\n   *\n   * @param  {string}   token     The jwt token to check\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  checkToken (token, cb) {\n    const\n      request = {\n        body: {\n          token\n        }\n      };\n\n    this.callbackRequired('Kuzzle.checkToken', cb);\n\n    this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, (err, res) => {\n      cb(err, err ? undefined : res.result);\n    });\n  }\n\n  /**\n   * Fetches the current user.\n   *\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  whoAmI (cb) {\n    this.callbackRequired('Kuzzle.whoAmI', cb);\n\n    this.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, (err, res) => {\n      cb(err, err ? undefined : new User(this.security, res.result._id, res.result._source, res.result._meta));\n    });\n  }\n\n  /**\n   * Gets the rights array of the currently logged user.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param  {function} cb The callback containing the normalized array of rights.\n   */\n  getMyRights (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getMyRights', cb);\n\n    this.query({controller: 'auth', action:'getMyRights'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Update current user in Kuzzle.\n   *\n   * @param {object} content - a plain javascript object representing the user's modification\n   * @param {object} [options] - (optional) arguments\n   * @param {responseCallback} [cb] - (optional) Handles the query response\n   * @returns {Kuzzle} this object\n   */\n  updateSelf (content, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateSelf'}, {body: content}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n   * insertion.\n   *\n   * @param {string} event - name of the global event to subscribe to\n   * @param {function} listener - callback to invoke each time an event is fired\n   */\n  addListener (event, listener) {\n    if (this.eventActions.indexOf(event) === -1) {\n      throw new Error(`[${event}] is not a known event. Known events: ${this.eventActions.toString()}`);\n    }\n\n    return super.addListener(event, listener);\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method returns all available statistics from Kuzzle.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAllStatistics (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n    this.query({controller:'server', action: 'getAllStats'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n   *\n   * @param {number} startTime -  Epoch time. Starting time from which the frames are to be retrieved\n   * @param {number} stopTime -  Epoch time. End time from which the frames are to be retrieved\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getStatistics (...args) {\n    let\n      startTime,\n      stopTime,\n      options,\n      cb;\n\n    switch (args.length) {\n      case 1:\n        cb = args[0];\n        startTime = null;\n        stopTime = null;\n        options = null;\n        break;\n      case 2:\n        if (typeof args[0] === 'object') {\n          [options, cb] = args;\n        } else {\n          [startTime, cb] = args;\n        }\n        break;\n      case 3:\n        if (typeof args[1] === 'object') {\n          [startTime, options, cb] = args;\n        } else {\n          [startTime, stopTime, cb] = args;\n        }\n        break;\n      case 4:\n        [startTime, stopTime, options, cb] = args;\n        break;\n      default:\n        throw new Error('Bad arguments list. Usage: kuzzle.getStatistics([startTime,] [stopTime,] [options,] callback)');\n    }\n\n    this.callbackRequired('Kuzzle.getStatistics', cb);\n\n    const queryCB = (err, res) => {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, startTime ? res.result.hits : [res.result]);\n    };\n\n    let query = {};\n    if (startTime) {\n      query = stopTime ? {startTime, stopTime} : {startTime};\n    }\n\n    this.query({controller: 'server', action: startTime ? 'getStats' : 'getLastStats'}, query, options, queryCB);\n  }\n\n  /**\n   * Create a new instance of a Collection object.\n   * If no index is specified, takes the default index.\n   *\n   * @param {string} collection - The name of the data collection you want to manipulate\n   * @param {string} [index] - The name of the data index containing the data collection\n   * @returns {Collection} A Collection instance\n   */\n  collection (collection, index) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Unable to create a new data collection object: no index specified');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    if (typeof index !== 'string' || typeof collection !== 'string') {\n      throw new Error('Invalid index or collection argument: string expected');\n    }\n\n    if (!this.collections[index]) {\n      this.collections[index] = {};\n    }\n\n    if (!this.collections[index][collection]) {\n      this.collections[index][collection] = new Collection(this, collection, index);\n    }\n\n    return this.collections[index][collection];\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   *\n   * @returns {Kuzzle}\n   */\n  flushQueue () {\n    this.network.flushQueue();\n    return this;\n  }\n\n  /**\n   * Returns the list of known persisted data collections.\n   *\n   * @param {string} [index] - Index containing collections to be listed\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listCollections (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.listCollections: index required');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.listCollections', cb);\n\n    const query = {type: options && options.type || 'all'};\n\n    this.query({index, controller: 'collection', action: 'list'}, query, options, (err, res) => {\n      cb(err, err ? undefined : res.result.collections);\n    });\n  }\n\n  /**\n   * Returns the list of existing indexes in Kuzzle\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listIndexes (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.listIndexes', cb);\n\n    this.query({controller: 'index', action: 'list'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.indexes);\n    });\n  }\n\n  /**\n   * Disconnects from Kuzzle and invalidate this instance.\n   */\n  disconnect () {\n    this.network.close();\n\n    for (const collection of Object.keys(this.collections)) {\n      delete this.collections[collection];\n    }\n  }\n\n  /**\n   * Returns the server informations\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getServerInfo (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n    this.query({controller: 'server', action: 'info'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.serverInfo);\n    });\n  }\n\n  /**\n   * Forces an index refresh\n   *\n   * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   * @returns {Kuzzle}\n   */\n  refreshIndex (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.refreshIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.query({index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Returns de current autoRefresh status for the given index\n   *\n   * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optinal arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAutoRefresh (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.getAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n    this.query({index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n  }\n\n  /**\n   * (Un)Sets the autoRefresh flag on the given index\n   *\n   * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n   * @param {boolean} autoRefresh - The autoRefresh value to set\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query result\n   * @returns {object} this\n   */\n  setAutoRefresh (...args) {\n    var\n      index,\n      autoRefresh,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'boolean':\n          autoRefresh = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.setAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (autoRefresh === undefined) {\n      throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n    }\n\n    this.query({index, controller: 'index', action: 'setAutoRefresh'}, {body: {autoRefresh}}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Return the current Kuzzle's UTC Epoch time, in milliseconds\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  now (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.now', cb);\n\n    this.query({controller: 'server', action: 'now'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.now);\n    });\n  }\n\n  /**\n   * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n   * Base method used to send read queries to Kuzzle\n   *\n   * Takes an optional argument object with the following properties:\n   *    - volatile (object, default: null):\n   *        Additional information passed to notifications to other users\n   *\n   * @param {object} queryArgs - Query configuration\n   * @param {object} query - The query data\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} [cb] - Handles the query response\n   */\n  query (queryArgs, query, options, cb) {\n    const\n      object = {\n        action: queryArgs.action,\n        controller: queryArgs.controller,\n        volatile: this.volatile\n      };\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    } else if (!cb && !options && typeof query === 'function') {\n      cb = query;\n      query = {};\n      options = null;\n    }\n\n    if (options) {\n      for (const prop of ['refresh', 'from', 'size', 'scroll', 'scrollId']) {\n        if (options[prop] !== undefined) {\n          object[prop] = options[prop];\n        }\n      }\n\n      if (options.volatile && typeof options.volatile === 'object') {\n        Object.assign(object.volatile, options.volatile);\n      }\n    }\n\n    if (!query || typeof query !== 'object' || Array.isArray(query)) {\n      throw new Error('Invalid query parameter: ' + query);\n    }\n\n    Object.assign(object.volatile, query.volatile, {sdkVersion: this.sdkVersion});\n\n    for (const attr of Object.keys(query)) {\n      if (attr !== 'volatile') {\n        object[attr] = query[attr];\n      }\n    }\n\n    /*\n     * Do not add the token for the checkToken route, to avoid getting a token error when\n     * a developer simply wish to verify his token\n     */\n    if (this.jwt !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n      object.jwt = this.jwt;\n    }\n\n    if (queryArgs.collection) {\n      object.collection = queryArgs.collection;\n    }\n\n    if (queryArgs.index) {\n      object.index = queryArgs.index;\n    }\n\n    if (!object.requestId) {\n      object.requestId = uuidv4();\n    }\n\n    this.network.query(object, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Starts the requests queuing.\n   */\n  startQueuing () {\n    this.network.startQueuing();\n    return this;\n  }\n\n  /**\n   * Stops the requests queuing.\n   */\n  stopQueuing () {\n    this.network.stopQueuing();\n    return this;\n  }\n\n  /**\n   * @DEPRECATED\n   * See Kuzzle.prototype.playQueue();\n   */\n  replayQueue () {\n    return this.playQueue();\n  }\n\n  /**\n   * Plays the requests queued during offline mode.\n   */\n  playQueue () {\n    this.network.playQueue();\n    return this;\n  }\n\n  /**\n   * Sets the default Kuzzle index\n   *\n   * @param index\n   * @returns this\n   */\n  setDefaultIndex (index) {\n    if (typeof index !== 'string') {\n      throw new Error(`Invalid default index: [${index}] (an index name is expected)`);\n    }\n\n    if (index.length === 0) {\n      throw new Error('Cannot set an empty index as the default index');\n    }\n\n    this.defaultIndex = index;\n\n    return this;\n  }\n}\n\nfunction checkPropertyType(prop, typestr, value) {\n  const wrongType = typestr === 'array' ? !Array.isArray(value) : typeof value !== typestr;\n\n  if (wrongType) {\n    throw new Error(`Can only assign a ${typestr} value to property \"${prop}\"`);\n  }\n}\n\nmodule.exports = Kuzzle;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kuzzle.js","class Listener {\n  constructor(fn, once = false) {\n    this.fn = fn;\n    this.once = once;\n  }\n}\n\nclass KuzzleEventEmitter {\n  constructor() {\n    this._events = {};\n  }\n\n  _exists (listeners, fn) {\n    return Boolean(listeners.find(listener => listener.fn === fn));\n  }\n\n  listeners (eventName) {\n    if (this._events[eventName] === undefined) {\n      return [];\n    }\n\n    return this._events[eventName].map(listener => listener.fn);\n  }\n\n  addListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    const listenerType = typeof listener;\n\n    if (listenerType !== 'function') {\n      throw new Error(`Invalid listener type: expected a function, got a ${listenerType}`);\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName].push(new Listener(listener, once));\n    }\n\n    return this;\n  }\n\n  on (eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  prependListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n    }\n\n    return this;\n  }\n\n  addOnceListener (eventName, listener) {\n    return this.addListener(eventName, listener, true);\n  }\n\n  once (eventName, listener) {\n    return this.addOnceListener(eventName, listener);\n  }\n\n  prependOnceListener (eventName, listener) {\n    return this.prependListener(eventName, listener, true);\n  }\n\n  removeListener (eventName, listener) {\n    const listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n\n    const index = listeners.findIndex(l => l.fn === listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    return this;\n  }\n\n  removeAllListeners (eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  }\n\n  emit (eventName, ...payload) {\n    const listeners = this._events[eventName];\n\n    if (listeners === undefined) {\n      return false;\n    }\n\n    const onceListeners = [];\n\n    for (const listener of listeners) {\n      listener.fn(...payload);\n\n      if (listener.once) {\n        onceListeners.push(listener.fn);\n      }\n    }\n\n    for (const toDelete of onceListeners) {\n      this.removeListener(eventName, toDelete);\n    }\n\n    return true;\n  }\n\n  eventNames () {\n    return Object.keys(this._events);\n  }\n\n  listenerCount (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  }\n}\n\nmodule.exports = KuzzleEventEmitter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/eventEmitter/index.js","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * Document is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {Collection} collection - an instanciated Collection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @param {object} [meta] - Initializes this document with the provided meta\n * @constructor\n */\nfunction Document(collection, documentId, content, meta) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: collection,\n      enumerable: false\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: false\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    meta: {\n      value: meta || {},\n      enumerable: true,\n      writable: false\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  if (this.version) {\n    data._version = this.version;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Checks if this document exists in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.exists = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('Document.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\nmodule.exports = Document;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Document.js\n// module id = 2\n// module chunks = 0","function SecurityDocument(Security, id, content, meta) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: Security.kuzzle\n    },\n    Security: {\n      value: Security\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    meta: {\n      value: meta || {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {SecurityDocument} this\n */\nSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {SecurityDocument} this\n */\nSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = SecurityDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/SecurityDocument.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nconst\n  KuzzleEventEmitter = require('../../../eventEmitter');\n\nclass RTWrapper extends KuzzleEventEmitter {\n\n  constructor (host, options) {\n    super();\n\n    Object.defineProperties(this, {\n      cleanHistoryTimer: {\n        value: null,\n        writable: true\n      },\n      host: {\n        value: host,\n        enumerable: true\n      },\n      port: {\n        value: (options && typeof options.port === 'number') ? options.port : 7512,\n        enumerable: true\n      },\n      ssl: {\n        value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n        enumerable: true\n      },\n      queuing: {\n        value: false,\n        writable: true\n      },\n      reconnectionDelay: {\n        value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n        enumerable: true\n      },\n      // configuration properties\n      autoReconnect: {\n        value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n        enumerable: true\n      },\n      autoQueue: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      autoReplay: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      state: {\n        value: 'offline',\n        enumerable: true,\n        writable: true\n      },\n      /*\n        Offline queue use the following format:\n              [\n                {\n                  ts: <query timestamp>,\n                  query: 'query',\n                  cb: callbackFunction\n                }\n              ]\n       */\n      offlineQueue: {\n        value: [],\n        enumerable: true,\n        writable: true\n      },\n      queueFilter: {\n        value: null,\n        enumerable: true,\n        writable: true\n      },\n      queueMaxSize: {\n        value: 500,\n        enumerable: true,\n        writable: true\n      },\n      queueTTL: {\n        value: 120000,\n        enumerable: true,\n        writable: true\n      },\n      replayInterval: {\n        value: 10,\n        enumerable: true,\n        writable: true\n      },\n      offlineQueueLoader: {\n        value: null,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      Object.keys(options).forEach(opt => {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      });\n\n      if (options.offlineMode === 'auto' && this.autoReconnect) {\n        this.autoQueue = this.autoReplay = true;\n      }\n    }\n\n    Object.defineProperty(this, 'requestHistory', {\n      value: {},\n      writable: true\n    });\n\n    this.wasConnected = false;\n    this.stopRetryingToConnect = false;\n    this.retrying = false;\n  }\n\n  connect() {\n    this.state = 'connecting';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected() {\n    this.state = 'connected';\n    this.emit(this.wasConnected && 'reconnect' || 'connect');\n    this.wasConnected = true;\n    this.stopRetryingToConnect = false;\n\n    if (this.autoQueue) {\n      this.stopQueuing();\n    }\n\n    if (this.autoReplay) {\n      this.playQueue();\n    }\n\n    if (!this.cleanHistoryTimer) {\n      this.cleanHistoryTimer = setInterval(() => { \n        cleanHistory(this.requestHistory); \n      }, 1000);\n    }\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  clientDisconnected() {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.clearHistoryTimer();\n    this.emit('disconnect');\n  }\n\n  /**\n   * Called when the client's connection is closed with an error state\n   *\n   * @param {Error} error\n   */\n  clientNetworkError(error) {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.clearHistoryTimer();\n\n    this.emit('networkError', error);\n    if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n      this.retrying = true;\n      setTimeout(() => {\n        this.retrying = false;\n        this.connect(this.host);\n      }, this.reconnectionDelay);\n    } else {\n      this.emit('disconnect');\n    }\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   */\n  flushQueue() {\n    this.offlineQueue = [];\n  }\n\n  /**\n   * Replays the requests queued during offline mode.\n   */\n  playQueue() {\n    if (this.state === 'connected') {\n      cleanQueue(this);\n      dequeue(this);\n    }\n  }\n\n  /**\n   * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  startQueuing() {\n    this.queuing = true;\n  }\n\n  /**\n   * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  stopQueuing() {\n    this.queuing = false;\n  }\n\n  subscribe(object, options, notificationCB, cb) {\n    if (this.state !== 'connected') {\n      return cb(new Error('Not Connected'));\n    }\n    this.query(object, options, (error, response) => {\n      if (error) {\n        return cb(error);\n      }\n      this.on(response.result.channel, data => {\n        data.fromSelf = this.requestHistory[data.requestId] !== undefined;\n        notificationCB(data);\n      });\n      cb(null, response.result);\n    });\n  }\n\n  unsubscribe(object, channel, cb) {\n    this.removeAllListeners(channel);\n    this.query(object, null, (err, res) => {\n      if (cb) {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  query(object, options, cb) {\n    let queuable = options && (options.queuable !== false) || true;\n\n    if (this.queueFilter) {\n      queuable = queuable && this.queueFilter(object);\n    }\n\n    if (this.queuing && queuable) {\n      cleanQueue(this, object, cb);\n      this.emit('offlineQueuePush', {query: object, cb: cb});\n      return this.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n    }\n\n    if (this.state === 'connected') {\n      return emitRequest(this, object, cb);\n    }\n\n    return discardRequest(object, cb);\n  }\n\n  clearHistoryTimer() {\n    if (this.cleanHistoryTimer) {\n      clearInterval(this.cleanHistoryTimer);\n      this.cleanHistoryTimer = null;\n    }\n  }\n}\n/**\n * Emit a request to Kuzzle\n *\n * @param {RTWrapper} network\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (network, request, cb) {\n  if (request.jwt !== undefined || cb) {\n    network.once(request.requestId, response => {\n      let error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        network.emit('tokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        network.emit('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n  // Track requests made to allow Room.subscribeToSelf to work\n  network.requestHistory[request.requestId] = Date.now();\n  network.send(request);\n}\n\nfunction discardRequest(object, cb) {\n  if (cb) {\n    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n  }\n}\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n * @param {RTWrapper} network\n */\nfunction cleanQueue (network) {\n  const now = Date.now();\n  let lastDocumentIndex = -1;\n\n  if (network.queueTTL > 0) {\n    network.offlineQueue.forEach((query, index) => {\n      if (query.ts < now - network.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      network.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(droppedRequest => {\n          network.emit('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (network.queueMaxSize > 0 && network.offlineQueue.length > network.queueMaxSize) {\n    network.offlineQueue\n      .splice(0, network.offlineQueue.length - network.queueMaxSize)\n      .forEach(droppedRequest => {\n        network.emit('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue (network) {\n  const\n    uniqueQueue = {},\n    dequeuingProcess = () => {\n      if (network.offlineQueue.length > 0) {\n        emitRequest(network, network.offlineQueue[0].query, network.offlineQueue[0].cb);\n        network.emit('offlineQueuePop', network.offlineQueue.shift());\n\n        setTimeout(() => {\n          dequeuingProcess();\n        }, Math.max(0, network.replayInterval));\n      }\n    };\n\n  if (network.offlineQueueLoader) {\n    if (typeof network.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof network.offlineQueueLoader);\n    }\n\n    const additionalQueue = network.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      network.offlineQueue = additionalQueue\n        .concat(network.offlineQueue)\n        .filter(request => {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\n/**\n * Clean history from requests made more than 10s ago\n */\nfunction cleanHistory (requestHistory) {\n  var\n    now = Date.now();\n\n  Object.keys(requestHistory).forEach(function (key) {\n    if (requestHistory[key] < now - 10000) {\n      delete requestHistory[key];\n    }\n  });\n}\n\nmodule.exports = RTWrapper;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/abstract/realtime.js","var\n  KuzzleSecurityDocument = require('./SecurityDocument');\n\n/**\n * @param {Security} Security\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction User(Security, id, content, meta) {\n  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    },\n    credentials: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: User\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {User} this\n */\nUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * @param {object} credentials\n */\nUser.prototype.setCredentials = function (credentials) {\n  if (typeof credentials !== 'object') {\n    throw new Error('Parameter \"credentials\" must be a object');\n  }\n\n  this.credentials = credentials;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {User} this\n */\nUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Creates this user into Kuzzle\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.create = function (options, cb) {\n  var\n    data = this.creationSerialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n\n/**\n * Replaces the latest version of this user in Kuzzle by the current content of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.replace = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n\n  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content, meta: this.meta};\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.creationSerialize = function () {\n  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array.<string>} the associated profiles IDs\n */\nUser.prototype.getProfileIds = function () {\n  return this.content.profileIds || [];\n};\n\n/**\n * Return the associated Profile objects\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nUser.prototype.getProfiles = function (options, cb) {\n  var \n    self = this,\n    fetchedProfiles = [],\n    errored = false;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\n  if (!self.content.profileIds) {\n    return cb(null, fetchedProfiles);\n  }\n\n  self.content.profileIds.forEach(function (profileId) {\n    self.Security.fetchProfile(profileId, options, function (error, profile) {\n      if (error) {\n        if (errored) {\n          return;\n        }\n\n        errored = true; // prevents multiple callback resolutions\n        return cb(error);\n      }\n\n      fetchedProfiles.push(profile);\n\n      if (fetchedProfiles.length === self.content.profileIds.length) {\n        cb(null, fetchedProfiles);\n      }\n    });\n  });\n};\n\nmodule.exports = User;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/User.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nconst\n  KuzzleEventEmitter = require('./eventEmitter');\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then youll receive a notification about it.\n *\n */\nclass Room extends KuzzleEventEmitter {\n  /*\n   * @constructor\n   * @param {object} collection - an instantiated and valid kuzzle object\n   * @param {object} [filters] - Filters in Kuzzle DSL format\n   * @param {object} [options] - subscription optional configuration\n   */\n  constructor(collection, filters, options) {\n    super();\n\n    let _roomId = null;\n\n    // Define properties\n    Object.defineProperties(this, {\n      // private properties\n      roomstate: {\n        // Values can be: inactive, subscribing, active\n        value: 'inactive',\n        writable: true\n      },\n      kuzzle: {\n        value: collection.kuzzle\n      },\n      isListening: {\n        value: false,\n        writable: true\n      },\n      //listeners\n      resubscribe: {\n        value: () => {\n          this.roomstate = 'inactive';\n          this.error = null;\n          this.subscribe();\n        }\n      },\n      deactivate: {\n        value: () => {\n          this.roomstate = 'inactive';\n        }\n      },\n      resubscribeConditional: {\n        value: () => {\n          this.roomstate = 'inactive';\n          \n          if (this.autoResubscribe) {\n            this.subscribe();\n          }\n        }\n      },\n      //enumerables\n      channel: {\n        value: null,\n        writable: true,\n        enumerable: true\n      },\n      scope: {\n        value: options && options.scope ? options.scope : 'all',\n        enumerable: true\n      },\n      state: {\n        value: options && options.state ? options.state : 'done',\n        enumerable: true\n      },\n      users: {\n        value: options && options.users ? options.users : 'none',\n        enumerable: true\n      },\n      // read-only properties\n      collection: {\n        value: collection,\n        enumerable: true\n      },\n      filters: {\n        value: filters ? filters : {},\n        enumerable: true,\n      },\n      roomId: {\n        enumerable: true,\n        get: () => _roomId,\n        set: value => {\n          if (!_roomId) {\n            _roomId = value;\n          }\n        }\n      },\n      // writable properties\n      volatile: {\n        value: (options && options.volatile) ? options.volatile : {},\n        enumerable: true,\n        writable: true\n      },\n      subscribeToSelf: {\n        value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n        enumerable: true,\n        writable: true\n      },\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : collection.kuzzle.autoResubscribe,\n        enumerable: true\n      }\n    });\n\n    if (this.kuzzle.bluebird) {\n      return this.kuzzle.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['count', 'subscribe', 'unsubscribe', 'onDone'];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the number of other subscriptions on that room.\n   *\n   * @param {responseCallback} cb - Handles the query response\n   */\n  count(cb) {\n    this.kuzzle.callbackRequired('Room.count', cb);\n\n    const data = {body: {roomId: this.roomId}};\n\n    if (this.roomstate !== 'active') {\n      return cb(new Error('Cannot count subscriptions on an non-active room'));\n    }\n\n    this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n      cb(err, res && res.result.count);\n    });\n  }\n\n  /**\n   * Subscribes to Kuzzle \n   * (do nothing if a subscription is active or underway)\n   * \n   * @param options\n   * @param {responseCallback} cb - called when the subscription is ready.\n   * @return {*} this\n   */\n  subscribe(options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    if (cb) {\n      this.onDone(cb);\n    }\n\n    // If the room subscription is active, just call the callback.\n    if (this.roomstate === 'active') {\n      this.emit('done', null, this);\n      return this;\n    }\n\n    // If the room is already subscribing, wait for its activation.\n    if (this.roomstate === 'subscribing') {\n      return this;\n    }\n\n    // If the room is still inactive, start the subscription.\n    this.error = null;\n    this.roomstate = 'subscribing';\n\n    this.kuzzle.subscribe(this, options, (error, result) => {\n      if (error) {\n        if (error.message === 'Not Connected') {\n          return this.kuzzle.once('connected', this.resubscribe);\n        }\n\n        this.roomstate = 'inactive';\n        this.error = new Error('Error during Kuzzle subscription: ' + error.message);\n        this.emit('done', this.error);\n        return null;\n      }\n\n      this.roomId = result.roomId;\n      this.channel = result.channel;\n      this.roomstate = 'active';\n\n      if (!this.isListening) {\n        this.kuzzle.addListener('disconnected', this.deactivate);\n        this.kuzzle.addListener('tokenExpired', this.deactivate);\n        this.kuzzle.addListener('reconnected', this.resubscribeConditional);\n        this.isListening = true;\n      }\n\n      this.emit('done', null, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Unsubscribes from Kuzzle.\n   *\n   * Stop listening immediately.\n   * @param {responseCallback} cb - Handles the query response\n   * @return {*} this\n   */\n  unsubscribe(cb) {\n    if (this.roomstate === 'subscribing') {\n      if (cb) {\n        cb(new Error('Cannot unsubscribe a room while a subscription attempt is underway'));\n      }\n\n      return this;\n    }\n\n    if (this.isListening) {\n      this.kuzzle.removeListener('disconnected', this.deactivate);\n      this.kuzzle.removeListener('tokenExpired', this.deactivate);\n      this.kuzzle.removeListener('reconnected', this.resubscribeConditional);\n      this.isListening = false;\n    }\n\n    if (this.roomstate === 'active') {\n      this.kuzzle.unsubscribe(this, cb);\n    }\n    else if (cb) {\n      cb(null, this.roomId);\n    }\n\n    this.roomstate = 'inactive';\n\n    return this;\n  }\n\n  /**\n   * Notify listeners\n   *\n   * @param {Object} data - data to send. Must contain `data.type` as eventName.\n   * @return {*} this\n   */\n  notify(data) {\n    if (data.type === undefined) {\n      throw new Error('Room.notify: argument must match {type: <document|user>}');\n    }\n    if (!data.fromSelf || this.subscribeToSelf) {\n      this.emit(data.type, data);\n    }\n    return this;\n  }\n\n  /**\n   * Registers a callback to be called with a subscription result\n   * @param {Function} cb\n   */\n  onDone(cb) {\n    if (!cb || typeof cb !== 'function') {\n      throw new Error('Room.onDone: a callback argument is required.');\n    }\n\n    if (this.error) {\n      cb(this.error);\n    }\n    else if (this.roomstate === 'active') {\n      cb(null, this);\n    }\n    else {\n      this.once('done', cb);\n    }\n\n    return this;\n  }\n}\n\nmodule.exports = Room;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Room.js","const Document = require('./Document');\n\n/**\n * @param {Collection} collection\n * @param {object} filters\n * @param {object} options\n * @param {object} raw \n * @property {Collection} collection\n * @property {number} total\n * @property {Document[]} documents\n * @property {object} aggregations\n * @property {object} options\n * @property {object} filters\n * @property {number} fetched\n * @constructor\n */\nclass SearchResult {\n  constructor (collection, filters, options, raw) {\n    Object.defineProperties(this, {\n      // read-only properties\n      collection: {\n        value: collection,\n        enumerable: true\n      },\n      total: {\n        value: raw.result.total,\n        enumerable: true\n      },\n      documents: {\n        value: raw.result.hits.map(doc => {\n          const d = new Document(collection, doc._id, doc._source, doc._meta);\n          d.version = doc._version;\n          return d;\n        }),\n        enumerable: true\n      },\n      aggregations: {\n        value: raw.result.aggregations || {},\n        enumerable: true\n      },\n      options: {\n        value: {\n          from: options.from,\n          size: options.size,\n          scrollId: raw.result._scroll_id\n        },\n        enumerable: true\n      },\n      filters: {\n        value: filters || {},\n        enumerable: true\n      },\n      // writable properties\n      fetched: {\n        value: raw.result.hits.length,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    Object.freeze(this.filters);\n    Object.freeze(this.options);\n    Object.freeze(this.aggregations);\n\n    // promisifying\n    if (this.collection.kuzzle.bluebird) {\n      const whitelist = ['fetchNext'];\n\n      return this.collection.kuzzle.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: (name, func, target, passes) => passes && whitelist.includes(name)\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {function} cb\n   */\n  fetchNext (cb) {\n    const updateAfterSearch = (error, result) => {\n      if (error) {\n        return cb(error);\n      }\n\n      result.fetched += this.fetched;\n      cb(null, result);\n    };\n    \n    this.collection.kuzzle.callbackRequired('SearchResult.fetchNext', cb);\n\n    if (this.fetched >= this.total) {\n      return cb(null, null);\n    }\n\n    // retrieve next results with scroll if original search use it\n    if (this.options.scrollId) {\n      this.collection.scroll(this.options.scrollId, null, this.filters || {}, updateAfterSearch);\n      return;\n    }\n\n    // retrieve next results using ES's search_after\n    if (this.options.size !== undefined && this.filters.sort) {\n      const filters = Object.assign({}, this.filters, {search_after: []});\n\n      for (const sortRule of filters.sort) {\n        filters.search_after.push(this.documents[this.documents.length - 1].content[Object.keys(sortRule)[0]]);\n      }\n\n      this.collection.search(filters, {size: this.options.size}, updateAfterSearch);\n      return;\n    }\n\n    // retrieve next results with from/size if original search use it\n    if (this.options.from !== undefined && this.options.size !== undefined) {\n      // check if we need to do next request to fetch all matching documents\n      const opts = {\n        from: this.options.from + this.options.size,\n        size: this.options.size\n      };\n\n      if (opts.from >= this.total) {\n        return cb(null, null);\n      }\n\n      this.collection.search(this.filters, opts, updateAfterSearch);\n      return;\n    }\n\n    cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n  }\n}\n\nmodule.exports = SearchResult;\n\n\n\n// WEBPACK FOOTER //\n// ./src/SearchResult.js","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nclass SocketIO extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    this.socket = null;\n    this.forceDisconnect = false;\n    this.eventsWrapper = {};\n  }\n\n  /**\n   * Connect to the SocketIO server\n   */\n  connect() {\n    super.connect();\n\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: this.autoReconnect,\n      reconnectionDelay: this.reconnectionDelay,\n      forceNew: true\n    });\n\n    this.socket.on('connect', () => this.clientConnected());\n    this.socket.on('connect_error', error => this.clientNetworkError(error));\n\n    this.socket.on('disconnect', () => {\n      if (this.forceDisconnect) {\n        this.clientDisconnected();\n      } else {\n        const error = new Error('An error occurred, kuzzle may not be ready yet');\n        error.status = 500;\n\n        this.clientNetworkError(error);\n      }\n\n      this.forceDisconnect = false;\n    });\n  }\n\n  /**\n   * Registers a callback on an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  addListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    super.addListener(event, callback, once);\n\n    return this;\n  }\n\n  prependListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    return super.prependListener(event, callback, once);\n  }\n\n  /**\n   * Unregisters a callback from an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  removeListener(event, callback) {\n    if (this.eventsWrapper[event]) {\n      this.eventsWrapper[event].listeners.delete(callback);\n\n      if (this.eventsWrapper[event].listeners.size === 0) {\n        this.socket.off(event, this.eventsWrapper[event].wrapper);\n        delete this.eventsWrapper[event];\n      }\n\n      super.removeListener(event, callback);\n    }\n\n    return this;\n  }\n\n  /**\n   * Unregisters all listeners either from an event, or from all events\n   *\n   * @param {string} [event]\n   */\n  removeAllListeners(event) {\n    if (event !== undefined) {\n      if (this.eventsWrapper[event] !== undefined) {\n        for (const listener of this.eventsWrapper[event].listeners) {\n          this.removeListener(event, listener);\n        }\n      }\n    } else {\n      for (const _event of Object.keys(this.eventsWrapper)) {\n        this.removeAllListeners(_event);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send(payload) {\n    this.socket.emit('kuzzle', payload);\n  }\n\n  /**\n   * Closes the connection\n   */\n  close() {\n    this.forceDisconnect = true;\n    this.state = 'offline';\n    this.socket.close();\n    this.socket = null;\n  }\n\n  _addEventWrapper(event, callback, once = false) {\n    if (!this.eventsWrapper[event]) {\n      const wrapper = (...args) => this.emit(event, ...args);\n\n      this.eventsWrapper[event] = {\n        wrapper,\n        listeners: new Set()\n      };\n\n      if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n        if (once) {\n          this.socket.once(event, wrapper);\n        } else {\n          this.socket.on(event, wrapper);\n        }\n      }\n    }\n\n    this.eventsWrapper[event].listeners.add(callback);\n  }\n}\n\nmodule.exports = SocketIO;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/socketio.js","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nlet WebSocketClient;\n\nclass WSNode extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n    this.client = null;\n    this.lasturl = null;\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    const\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      opts = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    super.connect();\n\n    if (url !== this.lasturl) {\n      this.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new WebSocketClient(url, opts);\n\n    this.client.onopen = () => {\n      this.clientConnected();\n    };\n\n    this.client.onclose = (closeEvent, message) => {\n      let\n        status,\n        reason = message;\n\n      if (typeof closeEvent === 'number') {\n        status = closeEvent;\n      }\n      else {\n        status = closeEvent.code;\n\n        if (closeEvent.reason) {\n          reason = closeEvent.reason;\n        }\n      }\n\n      if (status === 1000) {\n        this.clientDisconnected();\n      }\n      // do not forward a connection close error if no \n      // connection has been previously established\n      else if (this.wasConnected) {\n        const error = new Error(reason);\n        error.status = status;\n\n        this.clientNetworkError(error);\n      }\n    };\n\n    this.client.onerror = error => {\n      const err = (error instanceof Error) && error || new Error(error);\n\n      this.clientNetworkError(err);\n    };\n\n    this.client.onmessage = payload => {\n      const data = JSON.parse(payload.data || payload);\n\n      if (data.room) {\n        this.emit(data.room, data);\n      }\n      else {\n        this.emit('discarded', data);\n      }\n    };\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.state = 'offline';\n    this.removeAllListeners();\n    this.wasConnected = false;\n    if (this.client) {\n      this.client.close();\n    }\n    this.client = null;\n    this.stopRetryingToConnect = true;\n  }\n}\n\nmodule.exports = WSNode;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/websocket.js","var\n  KuzzleSearchResult = require('./SearchResult'),\n  Document = require('./Document'),\n  CollectionMapping = require('./CollectionMapping'),\n  Room = require('./Room');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction Collection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The Collection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.count = function (filters, options, cb) {\n  var query = {body: filters};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.count', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.create = function (options, cb) {\n  var data = {},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n *        If the same document already exists:\n *          - resolves with an error if set to \"error\".\n *          - replaces the existing document if set to \"replace\"\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a Document object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options && options.ifExist) {\n    if (options.ifExist === 'replace') {\n      action = 'createOrReplace';\n    }\n    else if (options.ifExist !== 'error') {\n      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n    }\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Collection} this\n */\nCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = {query: arg};\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Deletes the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.deleteSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Returns a boolean indicating whether or not a document with provided ID exists.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} options [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.documentExists = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Instantiates a CollectionMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\n  kuzzleMapping = new CollectionMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Create the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Create or replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create or replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Delete specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to delete\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Get specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Update the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to update\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n    cb(err, res && res.result);\n  });\n\n  return self;\n};\n\n/**\n * Retrieves the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.getSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a Document instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nCollection.prototype.search = function (filters, options, cb) {\n  var\n    query = {body: filters},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.search', cb);\n\n  self.kuzzle.query(self.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, new KuzzleSearchResult(self, filters, options, result));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Collection.scroll: scrollId is required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\n  request.scrollId = scrollId;\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, new KuzzleSearchResult(self, filters, options, result));\n  });\n};\n\n/**\n * Retrieves next result of a search with scroll query.\n *\n * @param {string} scrollId\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n  var\n    data = { scrollId: scrollId };\n\n  if (!scrollId) {\n    throw new Error('Collection.scrollSpecifications: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\n  this.kuzzle.query(\n    { controller: 'collection', action: 'scrollSpecifications'},\n    data,\n    options,\n    function (err, res) {\n      cb (err, err ? undefined : res.result);\n    }\n  );\n};\n\n/**\n * Searches specifications across indexes/collections according to the provided filters\n *\n * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.searchSpecifications = function (filters, options, cb) {\n  var\n    data = { body: { query: filters } },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\n  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Create a subscription room to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.room = function (filters, options) {\n  return new Room(this, filters, options);\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} notificationCB - called for each new notification\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.subscribe = function (filters, options, notificationCB) {\n  var\n    evtName,\n    room;\n\n  if (!notificationCB && typeof options === 'function') {\n    notificationCB = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.subscribe', notificationCB);\n\n  evtName = (options && options.users && options.users !== 'none') ? 'user' : 'document';\n  room = new Room(this, filters, options);\n\n  room.subscribe().on(evtName, notificationCB);\n  return room;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.retryOnConflict) {\n    data.retryOnConflict = options.retryOnConflict;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new Document(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n/**\n * Updates the current specifications of this collection\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Validates the provided specifications\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result.valid);\n  });\n};\n\n/**\n * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nCollection.prototype.document = function (id, content) {\n  return new Document(this, id, content);\n};\n\n/**\n * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n * @constructor\n */\nCollection.prototype.collectionMapping = function (mapping) {\n  return new CollectionMapping(this, mapping);\n};\n\nmodule.exports = Collection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Collection.js\n// module id = 10\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} collection - Instance of the inherited Collection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction CollectionMapping(collection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nCollectionMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = {\n      body: {\n        properties: this.mapping\n      }\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nCollectionMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function wont be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {CollectionMapping}\n */\nCollectionMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\nmodule.exports = CollectionMapping;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CollectionMapping.js\n// module id = 11\n// module chunks = 0","// Parameter mutualization\nvar\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true, \n    required: ['_id', 'cursor'], \n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']};\n\n// Redis commands\nvar\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    flushdb: {mapResults: mapNoResult},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: {required: ['_id', 'field', 'value']},\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n    hscan: getxScan,\n    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n    mget: getKeys,\n    mset: {required: ['entries'], mapResults: mapNoResult},\n    msetnx: {required: ['entries'], mapResults: Boolean},\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: {required: ['_id'], mapResults: Boolean},\n    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction MemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = [];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(function () {\n  Object.keys(commands).forEach(function (command) {\n    MemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (args.length && typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\n      if (!commands[command].getter) {\n        data.body = {};\n      }\n\n      if (commands[command].required) {\n        commands[command].required.forEach(function (param) {\n          var value = args.shift();\n\n          if (value === undefined) {\n            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n          }\n\n          assignParameter(data, commands[command].getter, param, value);\n        });\n      }\n\n      if (args.length > 1) {\n        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n      }\n\n      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n      }\n\n      if (args.length) {\n        options = Object.assign({}, args[0]);\n\n        if (Array.isArray(commands[command].opts)) {\n          commands[command].opts.forEach(function (opt) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(data, commands[command].getter, opt, options[opt]);\n              delete options[opt];\n            }\n          });\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof commands[command].opts === 'function') {\n        commands[command].opts(data, options || {});\n      }\n\n      this.kuzzle.query(query, data, options, cb && function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (commands[command].mapResults) {\n          return cb(null, commands[command].mapResults(res.result));\n        }\n\n        cb(null, res.result);\n      });\n\n      if (!commands[command].getter) {\n        return this;\n      }\n    };\n  });\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  var parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions(data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults(results) {\n  return results.map(function (coords) {\n    return coords.map(function (latlon) {\n      return parseFloat(latlon);\n    });\n  });\n}\n\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    var p = {\n        name: point[0]\n      },\n      i;\n\n    for (i = 1; i < point.length; i++) {\n      // withcoord result are in an array...\n      if (Array.isArray(point[i])) {\n        p.coordinates = point[i].map(function (coord) {\n          return parseFloat(coord);\n        });\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(point[i]);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray(results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt(results) {\n  return results.map(function (value) {\n    return parseInt(value);\n  });\n}\n\n/**\n * Disable results for routes like flushdb\n * @return {undefined}\n */\nfunction mapNoResult() {\n  return undefined;\n}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults(results) {\n  var\n    buffer = null,\n    mapped = [];\n\n  results.forEach(function (value) {\n    if (buffer === null) {\n      buffer = value;\n    }\n    else {\n      mapped.push({member: buffer, score: parseFloat(value)});\n      buffer = null;\n    }\n  });\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\", \n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n * \n * @param  {array.<string|array>} results \n * @return {object}\n */\nfunction mapScanResults(results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MemoryStorage.js\n// module id = 12\n// module chunks = 0","/**\n *\n * @param protocol\n * @param host\n * @param options\n * @returns {Object} Instantiated WebSocket/Socket.IO object\n */\n\nfunction network(protocol, host, options) {\n  switch (protocol) {\n    case 'websocket':\n      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n        throw new Error('Aborting: no websocket support detected.');\n      }\n      return new (require('./protocols/websocket'))(host, options);\n    case 'socketio':\n      if (!window.io) {\n        throw new Error('Aborting: no socket.io library loaded.');\n      }\n      return new (require('./protocols/socketio'))(host, options);\n    default:\n      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n  }\n}\n\nmodule.exports = network;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/index.js\n// module id = 13\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Profile(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nProfile.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Profile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Profile} this\n */\nProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {Profile} this\n */\nProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {Profile} this\n */\nProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = Profile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Profile.js\n// module id = 14\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Role(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nRole.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Role\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Role} this object\n */\nRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = Role;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Role.js\n// module id = 15\n// module chunks = 0","var\n  Role = require('./Role'),\n  Profile = require('./Profile'),\n  User = require('./User');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {Security}\n * @constructor\n */\nfunction Security(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.fetchRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for fetchRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new Role(self, doc._id, doc._source, doc._meta);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @param {object} meta - role metadata\n * @constructor\n */\nSecurity.prototype.role = function(id, content, meta) {\n  return new Role(this, id, content, meta);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new Profile(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {array} policies - list of policies to attach to the new profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = { policies: policies };\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {array} policies - the list of policies to apply to this profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = {policies: policies};\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollProfiles: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n    var profiles = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (profile) {\n      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\n      newProfile.version = profile._version;\n\n      profiles.push(newProfile);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      profiles: profiles,\n      scrollId: scrollId\n    });\n  });\n};\n\n/**\n * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @param {object} meta - profile metadata\n * @constructor\n */\nSecurity.prototype.profile = function(id, content, meta) {\n  return new Profile(this, id, content, meta);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created wont be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId = null;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new User(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Replace an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.replaceUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (content.profileIds) {\n    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollUsers: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n    var users = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (user) {\n      var newUser = new User(self, user._id, user._source, user._meta);\n\n      newUser.version = user._version;\n\n      users.push(newUser);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      users: users,\n      scrollId: scrollId\n    });\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @param {object} meta - user metadata\n * @constructor\n */\nSecurity.prototype.user = function(id, content, meta) {\n  return new User(this, id, content, meta);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the user <kuid> .\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a list of accepted fields per authentication strategy.\n *\n * @param options\n * @param cb\n */\nSecurity.prototype.getAllCredentialFields = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Retrieve the list of accepted field names by the specified <strategy>.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Get credential information of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Check the existence of the specified <strategy>s credentials for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Updates credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n */\nSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\nmodule.exports = Security;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Security.js\n// module id = 16\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/bytesToUuid.js\n// module id = 17\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/rng-browser.js\n// module id = 18\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v4.js\n// module id = 19\n// module chunks = 0"],"sourceRoot":""}