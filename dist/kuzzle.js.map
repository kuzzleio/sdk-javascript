{"version":3,"sources":["webpack://Kuzzle/webpack/universalModuleDefinition","webpack://Kuzzle/webpack/bootstrap","webpack://Kuzzle/./src/controllers/searchResult/base.js","webpack://Kuzzle/./src/controllers/security/user.js","webpack://Kuzzle/./src/eventEmitter/index.js","webpack://Kuzzle/./src/controllers/security/role.js","webpack://Kuzzle/./src/controllers/security/profile.js","webpack://Kuzzle/./src/networkWrapper/protocols/abstract/common.js","webpack://Kuzzle/./src/uuidv4.js","webpack://Kuzzle/./src/networkWrapper/protocols/abstract/realtime.js","webpack://Kuzzle/./src/Kuzzle.js","webpack://Kuzzle/./src/controllers/auth.js","webpack://Kuzzle/./src/controllers/collection.js","webpack://Kuzzle/./src/controllers/searchResult/specifications.js","webpack://Kuzzle/./src/controllers/document.js","webpack://Kuzzle/./src/controllers/searchResult/document.js","webpack://Kuzzle/./src/controllers/index.js","webpack://Kuzzle/./src/controllers/realtime/index.js","webpack://Kuzzle/./src/controllers/realtime/room.js","webpack://Kuzzle/./src/controllers/server.js","webpack://Kuzzle/./src/controllers/security/index.js","webpack://Kuzzle/./src/controllers/searchResult/role.js","webpack://Kuzzle/./src/controllers/searchResult/profile.js","webpack://Kuzzle/./src/controllers/searchResult/user.js","webpack://Kuzzle/./src/controllers/memoryStorage.js","webpack://Kuzzle/./src/networkWrapper/index.js","webpack://Kuzzle/./src/networkWrapper/protocols/http.js","webpack://Kuzzle/./src/networkWrapper/protocols/websocket.js","webpack://Kuzzle/./src/networkWrapper/protocols/socketio.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","[object Object]","kuzzle","request","options","response","this","fetched","hits","length","total","controller","searchAction","scrollAction","Promise","resolve","scroll","query","assign","scrollId","then","size","sort","search_after","hit","push","_source","keys","from","reject","Error","_kuzzle","id","content","meta","profileIds","security","mGetProfiles","Listener","fn","once","_events","listeners","Boolean","find","listener","eventName","undefined","map","listenerType","_exists","addListener","concat","addOnceListener","prependListener","index","findIndex","splice","payload","onceListeners","toDelete","removeListener","_id","controllers","policies","mGetRoles","policy","roleId","uuidv4","KuzzleEventEmitter","_host","_port","_ssl","AbstractWrapper","host","super","port","sslConnection","autoReplay","autoQueue","offlineQueue","offlineQueueLoader","queueFilter","queueMaxSize","queueTTL","queuing","replayInterval","state","forEach","opt","getOwnPropertyDescriptor","writable","ssl","wasConnected","emit","stopQueuing","playQueue","startQueuing","isReady","_cleanQueue","_dequeue","queuable","ts","Date","now","_emitRequest","JSON","stringify","lastDocumentIndex","droppedRequest","uniqueQueue","dequeuingProcess","catch","shift","setTimeout","Math","max","additionalQueue","Array","isArray","filter","requestId","action","error","message","status","send","prop","b","a","random","toString","replace","_autoReconnect","_reconnectionDelay","RTWrapper","autoReconnect","reconnectionDelay","offlineMode","stopRetryingToConnect","retrying","clientConnected","connect","AuthController","CollectionController","DocumentController","IndexController","RealtimeController","ServerController","SecurityController","MemoryStorageController","networkWrapper","events","protectedEvents","connected","disconnected","reconnected","tokenExpired","loginAttempt","_autoResubscribe","_eventTimeout","_jwt","_protocol","_version","_auth","_collection","_document","_index","_ms","_realtime","_security","_server","Kuzzle","autoResubscribe","eventTimeout","protocol","defaultIndex","network","volatile","data","err","jwt","auth","_checkPropertyType","collection","document","token","result","ms","queuMaxSize","realtime","server","version","protectedEvent","lastEmitted","connectionError","internal","collections","checkToken","res","valid","on","event","indexOf","flushQueue","close","sdkInstanceId","sdkVersion","typestr","User","body","strategy","credentials","user","_meta","expiresIn","success","SpecificationsSearchResult","topions","SearchResultBase","DocumentSearchResult","includeTrash","count","refresh","documents","ids","retryOnConflict","indexes","autoRefresh","Room","subscriptions","filters","channels","roomId","callback","room","subscribe","rooms","removeListeners","channel","subscribeToSelf","_channelListener","bind","_reSubscribeListener","fromSelf","exists","Role","RoleSearchResult","Profile","ProfileSearchResult","UserSearchResult","profile","role","next","getId","required","getIdField","getKeys","getMember","getxScan","opts","mapResults","mapScanResults","getZrange","assignZrangeOptions","mapZrangeResults","getZrangeBy","setId","setIdValue","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","mapNoResult","geoadd","geodist","parseFloat","geohash","geopos","results","coords","georadius","assignGeoRadiusOptions","mapGeoRadiusResults","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","set","setex","setnx","sinter","sinterstore","sismember","smembers","smove","spop","mapStringToArray","srandmember","srem","sscan","strlen","sunion","sunionstore","time","parseInt","touch","ttl","type","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","assignParameter","parsed","limit","point","elem","coordinates","distance","mapped","member","score","cursor","values","args","command","param","WebSocket","io","AbtractWrapper","_routes","routes","login","verb","url","bulk","import","create","createFirstAdmin","createRestrictedUser","createUser","HttpWrapper","http","customRoutes","_sendHttpRequest","serverInfo","api","headers","Content-Type","queryArgs","key","authorization","route","method","regex","matches","exec","queryString","v","join","disconnect","path","XMLHttpRequest","httpClient","e","code","parse","xhr","console","log","open","header","setRequestHeader","onload","json","responseText","WebSocketClient","client","lasturl","perMessageDeflate","onopen","onclose","closeEvent","reason","clientDisconnected","clientNetworkError","onerror","CLOSING","CLOSED","readyState","onmessage","OPEN","removeAllListeners","socket","forceDisconnect","eventsWrapper","reconnection","forceNew","_addEventWrapper","delete","off","wrapper","_event","Set","add"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","class SearchResultBase {\n\n  /**\n   *\n   * @param {Kuzzle} kuzzle\n   * @param {object} request\n   * @param {object} options\n   * @param {object} response\n   */\n  constructor (kuzzle, request = {}, options = {}, response = {}) {\n    this.kuzzle = kuzzle;\n    this.request = request;\n    this.options = options;\n    this.response = response;\n\n    this.fetched = response.hits && response.hits.length || 0;\n    this.total = response.total && response.total || 0;\n\n    this.controller = request.controller;\n    this.searchAction = 'search';\n    this.scrollAction = 'scroll';\n  }\n\n  next () {\n    if (this.fetched >= this.total) {\n      return Promise.resolve(null);\n    }\n\n    if (this.request.scroll) {\n      return this.kuzzle.query(Object.assign({}, this.request, {\n        scrollId: this.response.scrollId\n      }), options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          return this;\n        });\n    }\n\n    if (this.request.size && this.request.sort) {\n      const\n        request = Object.assign({}, this.request, {\n          search_after: []\n        }),\n        hit = this.response.hits && this.response.hits[this.response.hits.length -1];\n\n      for (const sort of this.request.sort) {\n        if (typeof sort === 'string') {\n          request.search_after.push(hit._source[sort]);\n        }\n        else {\n          request.search_after.push(hit._source[Object.keys(sort)[0]]);\n        }\n      }\n\n      return this.kuzzle.query(request, this.options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          return this;\n        });\n    }\n\n    if (this.request.from && this.request.size) {\n      if (this.request.from >= this.response.total) {\n        return Promise.resolve(null);\n      }\n\n      return this.kuzzle.query(Object.assign({}, this.request, {\n        from: this.fetched + 1\n      }), this.options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          return this;\n        });\n    }\n\n    return Promise.reject(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n  }\n}\n\nmodule.exports = SearchResultBase;\n","let\n  _kuzzle;\n\nclass User {\n  /**\n   *\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n\n    this.id = null;\n    this.content = {};\n    this.meta = {};\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  get profileIds () {\n    return this.content.profileIds || [];\n  }\n\n  /**\n   * @returns {Promise<[Profile]>}\n   */\n  getProfiles () {\n    return this.kuzzle.security.mGetProfiles(this.profileIds);\n  }\n\n}\n\nmodule.exports = User;\n\n","class Listener {\n  constructor(fn, once = false) {\n    this.fn = fn;\n    this.once = once;\n  }\n}\n\nclass KuzzleEventEmitter {\n  constructor() {\n    this._events = {};\n  }\n\n  _exists (listeners, fn) {\n    return Boolean(listeners.find(listener => listener.fn === fn));\n  }\n\n  listeners (eventName) {\n    if (this._events[eventName] === undefined) {\n      return [];\n    }\n\n    return this._events[eventName].map(listener => listener.fn);\n  }\n\n  addListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    const listenerType = typeof listener;\n\n    if (listenerType !== 'function') {\n      throw new Error(`Invalid listener type: expected a function, got a ${listenerType}`);\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName].push(new Listener(listener, once));\n    }\n\n    return this;\n  }\n\n  on (eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  prependListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n    }\n\n    return this;\n  }\n\n  addOnceListener (eventName, listener) {\n    return this.addListener(eventName, listener, true);\n  }\n\n  once (eventName, listener) {\n    return this.addOnceListener(eventName, listener);\n  }\n\n  prependOnceListener (eventName, listener) {\n    return this.prependListener(eventName, listener, true);\n  }\n\n  removeListener (eventName, listener) {\n    const listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n\n    const index = listeners.findIndex(l => l.fn === listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    return this;\n  }\n\n  removeAllListeners (eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  }\n\n  emit (eventName, ...payload) {\n    const listeners = this._events[eventName];\n\n    if (listeners === undefined) {\n      return false;\n    }\n\n    const onceListeners = [];\n\n    for (const listener of listeners) {\n      listener.fn(...payload);\n\n      if (listener.once) {\n        onceListeners.push(listener.fn);\n      }\n    }\n\n    for (const toDelete of onceListeners) {\n      this.removeListener(eventName, toDelete);\n    }\n\n    return true;\n  }\n\n  eventNames () {\n    return Object.keys(this._events);\n  }\n\n  listenerCount (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  }\n}\n\nmodule.exports = KuzzleEventEmitter;\n","let _kuzzle;\n\nclass Role {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n\n    this._id = null;\n    this.controllers = {};\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n}\n\nmodule.exports = Role;\n\n","let _kuzzle;\n\nclass Profile {\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n\n    this._id = null;\n    this.policies = [];\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  getRoles (options = {}) {\n    return this.kuzzle.security.mGetRoles(this.policies.map(policy => policy.roleId), options);\n  }\n}\n\nmodule.exports = Profile;\n\n","'use strict';\n\nconst\n  uuidv4 = require('../../../uuidv4'),\n  KuzzleEventEmitter = require('../../../eventEmitter');\n\nconst\n  _id = uuidv4();\n// read-only properties\nlet\n  _host,\n  _port,\n  _ssl;\n\nclass AbstractWrapper extends KuzzleEventEmitter {\n\n  constructor (host, options) {\n    super();\n\n    _host = host;\n    _port = options && typeof options.port === 'number' ? options.port : 7512;\n    _ssl = options && typeof options.sslConnection === 'boolean' ? options.sslConnection : false;\n\n    this.autoReplay = false;\n    this.autoQueue = false;\n    this.offlineQueue = [];\n    this.offlineQueueLoader = null;\n    this.queueFilter = null;\n    this.queueMaxSize = 500;\n    this.queueTTL = 120000;\n    this.queuing = false;\n    this.replayInterval = 10;\n    this.state = 'offline';\n\n    if (options) {\n      Object.keys(options).forEach(opt => {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      });\n    }\n  }\n\n  get id () {\n    return _id;\n  }\n\n  get host () {\n    return _host;\n  }\n\n  get port () {\n    return _port;\n  }\n\n  get ssl () {\n    return _ssl;\n  }\n\n  /**\n   * @abstract\n   * @returns {Promise<any>}\n   */\n  connect () {\n    throw new Error('Method \"connect\" is not implemented');\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected (state, wasConnected) {\n    this.state = state || 'ready';\n    this.emit(wasConnected && 'reconnect' || 'connect');\n\n    if (this.autoQueue) {\n      this.stopQueuing();\n    }\n\n    if (this.autoReplay) {\n      this.playQueue();\n    }\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  disconnect() {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   */\n  flushQueue () {\n    this.offlineQueue = [];\n  }\n\n  /**\n   * Replays the requests queued during offline mode.\n   */\n  playQueue () {\n    if (this.isReady()) {\n      this._cleanQueue();\n      this._dequeue();\n    }\n  }\n\n  /**\n   * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  startQueuing () {\n    this.queuing = true;\n  }\n\n  /**\n   * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  stopQueuing () {\n    this.queuing = false;\n  }\n\n  query (request, options) {\n    let queuable = options && (options.queuable !== false) || true;\n\n    if (this.queueFilter) {\n      queuable = queuable && this.queueFilter(request);\n    }\n\n    if (this.queuing && queuable) {\n      this._cleanQueue();\n      this.emit('offlineQueuePush', {request});\n      return new Promise((resolve, reject) => {\n        this.offlineQueue.push({\n          resolve,\n          reject,\n          request,\n          ts: Date.now()\n        });\n      });\n    }\n\n    if (this.isReady()) {\n      return this._emitRequest(request);\n    }\n\n    return Promise.reject(new Error(`Unable to execute request: not connected to a Kuzzle server.\nDiscarded request: ${JSON.stringify(request)}`));\n  }\n\n  isReady () {\n    return this.state === 'ready';\n  }\n\n  /**\n   * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n   */\n  _cleanQueue () {\n    const now = Date.now();\n    let lastDocumentIndex = -1;\n\n    if (this.queueTTL > 0) {\n      this.offlineQueue.forEach((query, index) => {\n        if (query.ts < now - this.queueTTL) {\n          lastDocumentIndex = index;\n        }\n      });\n\n      if (lastDocumentIndex !== -1) {\n        this.offlineQueue\n          .splice(0, lastDocumentIndex + 1)\n          .forEach(droppedRequest => {\n            this.emit('offlineQueuePop', droppedRequest.query);\n          });\n      }\n    }\n\n    if (this.queueMaxSize > 0 && this.offlineQueue.length > this.queueMaxSize) {\n      this.offlineQueue\n        .splice(0, this.offlineQueue.length - this.queueMaxSize)\n        .forEach(droppedRequest => {\n          this.emit('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  /**\n   * Play all queued requests, in order.\n   */\n  _dequeue () {\n    const\n      uniqueQueue = {},\n      dequeuingProcess = () => {\n        if (this.offlineQueue.length > 0) {\n          this._emitRequest(this.offlineQueue[0].request)\n            .then(this.offlineQueue[0].resolve)\n            .catch(this.offlineQueue[0].reject);\n          this.emit('offlineQueuePop', this.offlineQueue.shift());\n\n          setTimeout(() => {\n            dequeuingProcess();\n          }, Math.max(0, this.replayInterval));\n        }\n      };\n\n    if (this.offlineQueueLoader) {\n      if (typeof this.offlineQueueLoader !== 'function') {\n        throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof this.offlineQueueLoader);\n      }\n\n      const additionalQueue = this.offlineQueueLoader();\n      if (Array.isArray(additionalQueue)) {\n        this.offlineQueue = additionalQueue\n          .concat(this.offlineQueue)\n          .filter(request => {\n            // throws if the query object does not contain required attributes\n            if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n              throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n            }\n\n            return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n          });\n      } else {\n        throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n      }\n    }\n\n    dequeuingProcess();\n  }\n\n  _emitRequest (request) {\n    return new Promise((resolve, reject) => {\n      this.once(request.requestId, response => {\n        if (request.action !== 'logout'\n          && response.error\n          && response.error.message === 'Token expired'\n        ) {\n          const error = new Error(response.error.message);\n          Object.assign(error, response.error);\n          error.status = response.status;\n          this.emit('queryError', error, request);\n\n          return reject(error);\n        }\n\n        return resolve(response);\n      });\n\n      this.send(request);\n    });\n  }\n}\n\n// make public getters enumerable\nfor (const prop of [\n  'host',\n  'id',\n  'port',\n  'ssl'\n]) {\n  Object.defineProperty(AbstractWrapper.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = AbstractWrapper;\n","// golfed version of uuid-v4\n// uuid node module relies on crypto, which is a bit fat to embed\n//\n// cf amazing https://gist.github.com/jed/982883\n\nconst b = (a) => a\n  ? (\n    a ^\n    Math.random()\n    * 16\n    >> a/4\n  ).toString(16)\n  : (\n    [1e7] +\n    -1e3 +\n    -4e3 +\n    -8e3 +\n    -1e11\n  ).replace(\n    /[018]/g,\n    b\n  );\n\nmodule.exports = b;\n","'use strict';\n\nconst\n  AbstractWrapper = require('./common');\n\nlet\n  _autoReconnect,\n  _reconnectionDelay;\n\nclass RTWrapper extends AbstractWrapper {\n\n  constructor (host, options) {\n    super(host, options);\n\n    _autoReconnect = options && typeof options.autoReconnect === 'boolean' ? options.autoReconnect : true;\n    _reconnectionDelay = options && typeof options.reconnectionDelay === 'number' ? options.reconnectionDelay : 1000;\n\n    if (options && options.offlineMode === 'auto' && this.autoReconnect) {\n      this.autoQueue = this.autoReplay = true;\n    }\n\n    this.wasConnected = false;\n    this.stopRetryingToConnect = false;\n    this.retrying = false;\n  }\n\n  get autoReconnect () {\n    return _autoReconnect;\n  }\n\n  get reconnectionDelay () {\n    return _reconnectionDelay;\n  }\n\n  connect() {\n    this.state = 'connecting';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected() {\n    super.clientConnected('connected', this.wasConnected);\n\n    this.state = 'connected';\n    this.wasConnected = true;\n    this.stopRetryingToConnect = false;\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  clientDisconnected() {\n    this.emit('disconnect');\n  }\n\n  /**\n   * Called when the client's connection is closed with an error state\n   *\n   * @param {Error} error\n   */\n  clientNetworkError(error) {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.emit('networkError', error);\n    if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n      this.retrying = true;\n      setTimeout(() => {\n        this.retrying = false;\n        this.connect(this.host);\n      }, this.reconnectionDelay);\n    } else {\n      this.emit('disconnect');\n    }\n  }\n\n  isReady() {\n    return this.state === 'connected';\n  }\n}\n\n// make public properties enumerable\nfor (const prop of [\n  'autoReconnect',\n  'reconnectionDelay'\n]) {\n  Object.defineProperty(RTWrapper.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = RTWrapper;\n","const\n  KuzzleEventEmitter = require('./eventEmitter'),\n  AuthController = require('./controllers/auth'),\n  CollectionController = require('./controllers/collection'),\n  DocumentController = require('./controllers/document'),\n  IndexController = require('./controllers/index'),\n  RealtimeController = require('./controllers/realtime'),\n  ServerController = require('./controllers/server'),\n  SecurityController = require('./controllers/security'),\n  MemoryStorageController = require('./controllers/memoryStorage'),\n  networkWrapper = require('./networkWrapper'),\n  uuidv4 = require('./uuidv4');\n\nconst\n  events = [\n    'connected',\n    'discarded',\n    'disconnected',\n    'loginAttempt',\n    'networkError',\n    'offlineQueuePush',\n    'offlineQueuePop',\n    'queryError',\n    'reconnected',\n    'tokenExpired'\n  ],\n  protectedEvents = {\n    connected: {},\n    error: {},\n    disconnected: {},\n    reconnected: {},\n    tokenExpired: {},\n    loginAttempt: {}\n  };\n\nlet\n  _autoResubscribe,\n  _eventTimeout,\n  _jwt,\n  _protocol,\n  _version,\n  _auth,\n  _collection,\n  _document,\n  _index,\n  _ms,\n  _realtime,\n  _security,\n  _server;\n\nclass Kuzzle extends KuzzleEventEmitter {\n\n  /**\n   * @param host - Server name or IP Address to the Kuzzle instance\n   * @param [options] - Connection options\n   */\n  constructor(host, options = {}) {\n    super();\n\n    if (!host || host === '') {\n      throw new Error('host argument missing');\n    }\n\n    _autoResubscribe = typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true;\n    _eventTimeout = typeof options.eventTimeout === 'number' ? options.eventTimeout : 200;\n    _protocol = typeof options.protocol === 'string' ? options.protocol : 'websocket';\n    _version = typeof SDKVERSION === 'undefined' ? require('../package').version : SDKVERSION;\n\n    // controllers\n    _auth = new AuthController(this);\n    _collection = new CollectionController(this);\n    _document = new DocumentController(this);\n    _index = new IndexController(this);\n    _ms = new MemoryStorageController(this);\n    _realtime = new RealtimeController(this);\n    _security = new SecurityController(this);\n    _server = new ServerController(this);\n\n    this.defaultIndex = typeof options.defaultIndex === 'string' ? options.defaultIndex : undefined;\n    this.network = networkWrapper(this.protocol, host, options);\n    this.volatile = {};\n\n    if (options) {\n      for (const opt of Object.keys(options)) {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    this.network.addListener('offlineQueuePush', data => this.emit('offlineQueuePush', data));\n    this.network.addListener('offlineQueuePop', data => this.emit('offlineQueuePop', data));\n    this.network.addListener('queryError', (err, query) => this.emit('queryError', err, query));\n\n    this.network.addListener('tokenExpired', () => {\n      this.jwt = undefined;\n      this.emit('tokenExpired');\n    });\n  }\n\n  get auth () {\n    return _auth;\n  }\n\n  get autoQueue () {\n    return this.network.autoQueue;\n  }\n\n  set autoQueue (value) {\n    this._checkPropertyType('autoQueue', 'boolean', value);\n    this.network.autoQueue = value;\n  }\n\n  get autoReconnect () {\n    return this.network.autoReconnect;\n  }\n\n  set autoReconnect (value) {\n    this._checkPropertyType('autoReconnect', 'boolean', value);\n    this.network.autoReconnect = value;\n  }\n\n  get autoReplay () {\n    return this.network.autoReplay;\n  }\n\n  set autoReplay (value) {\n    this._checkPropertyType('autoReplay', 'boolean', value);\n    this.network.autoReplay = value;\n  }\n\n  get autoResubscribe () {\n    return _autoResubscribe;\n  }\n\n  get collection () {\n    return _collection;\n  }\n\n  get document () {\n    return _document;\n  }\n\n  get eventTimeout () {\n    return _eventTimeout;\n  }\n\n  get index () {\n    return _index;\n  }\n\n  get jwt () {\n    return _jwt;\n  }\n\n  set jwt (token) {\n    if (token === undefined) {\n      _jwt = undefined;\n    }\n    else if (typeof token === 'string') {\n      _jwt = token;\n    }\n    else if (typeof token === 'object'\n      && token.result\n      && token.result.jwt\n      && typeof token.result.jwt === 'string'\n    ) {\n      _jwt = token.result.jwt;\n    }\n\n    throw new Error(`Invalid token argument: ${token}`);\n  }\n\n  get host () {\n    return this.network.host;\n  }\n\n  get ms () {\n    return _ms;\n  }\n\n  get offlineQueue () {\n    return this.network.offlineQueue;\n  }\n\n  get offlineQueueLoader () {\n    return this.network.offlineQueueLoader;\n  }\n\n  set offlineQueueLoader (value) {\n    this._checkPropertyType('offlineQueueLoader', 'function', value);\n    this.network.offlineQueueLoader = value;\n  }\n\n  get port () {\n    return this.network.port;\n  }\n\n  get protocol () {\n    return _protocol;\n  }\n\n  get queueFilter () {\n    return this.network.queueFilter;\n  }\n\n  set queueFilter (value) {\n    this._checkPropertyType('queueFilter', 'function', value);\n    this.network.queueFilter = value;\n  }\n\n  get queueMaxSize () {\n    return this.network.queuMaxSize();\n  }\n\n  set queueMaxSize (value) {\n    this._checkPropertyType('queueMaxSize');\n    this.network.queueMaxSize = value;\n  }\n\n  get queueTTL () {\n    return this.network.queueTTL;\n  }\n\n  set queueTTL (value) {\n    this._checkPropertyType('queueTTL', 'number', value);\n    this.network.queueTTL = value;\n  }\n\n  get realtime () {\n    return _realtime;\n  }\n\n  get reconnectionDelay () {\n    return this.network.reconnectionDelay;\n  }\n\n  get replayInterval () {\n    return this.network.replayInterval;\n  }\n\n  set replayInterval (value) {\n    this._checkPropertyType('replayInterval', 'number', value);\n    this.network.replayInterval = value;\n  }\n\n  get security () {\n    return _security;\n  }\n\n  get server () {\n    return _server;\n  }\n\n  get sslConnection () {\n    return this.network.sslConnection;\n  }\n\n  get version () {\n    return _version;\n  }\n\n  /**\n  * Emit an event to all registered listeners\n  * An event cannot be emitted multiple times before a timeout has been reached.\n  */\n  emit (eventName, ...payload) {\n    const\n      now = Date.now(),\n      protectedEvent = protectedEvents[eventName];\n\n    if (protectedEvent) {\n      if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - this.eventTimeout) {\n        return false;\n      }\n      protectedEvent.lastEmitted = now;\n    }\n\n    super.emit(eventName, ...payload);\n  }\n\n  /**\n   * Connects to a Kuzzle instance using the provided host name\n   * @param {function} [cb] Connection callback\n   */\n  connect () {\n    if (this.network.isReady()) {\n      return Promise.resolve(this);\n    }\n\n    this.network.addListener('connect', () => {\n      this.emit('connected');\n    });\n\n    this.network.addListener('networkError', error => {\n      const connectionError = new Error(`Unable to connect to kuzzle proxy server at ${this.network.host}:${this.network.port}`);\n\n      connectionError.internal = error;\n      this.emit('networkError', connectionError);\n    });\n\n    this.network.addListener('disconnect', () => {\n      for (const collection of Object.keys(this.collections)) {\n        delete this.collections[collection];\n      }\n\n      this.emit('disconnected');\n    });\n\n    this.network.addListener('reconnect', () => {\n      if (this.jwt) {\n        this.checkToken(this.jwt, (err, res) => {\n          // shouldn't obtain an error but let's invalidate the token anyway\n          if (err || !res.valid) {\n            this.jwt = undefined;\n          }\n\n          this.emit('reconnected');\n        });\n      } else {\n        this.emit('reconnected');\n      }\n    });\n\n    this.network.on('discarded', data => this.emit('discarded', data));\n\n    return this.network.connect();\n  }\n\n  /**\n   * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n   * insertion.\n   *\n   * @param {string} event - name of the global event to subscribe to\n   * @param {function} listener - callback to invoke each time an event is fired\n   */\n  addListener (event, listener) {\n    if (events.indexOf(event) === -1) {\n      throw new Error(`[${event}] is not a known event. Known events: ${events.toString()}`);\n    }\n\n    return super.addListener(event, listener);\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   *\n   * @returns {Kuzzle}\n   */\n  flushQueue () {\n    this.network.flushQueue();\n    return this;\n  }\n\n  /**\n   * Disconnects from Kuzzle and invalidate this instance.\n   */\n  disconnect () {\n    this.network.close();\n\n    for (const collection of Object.keys(this.collections)) {\n      delete this.collections[collection];\n    }\n  }\n\n  /**\n   * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n   * Base method used to send read queries to Kuzzle\n   *\n   * Takes an optional argument object with the following properties:\n   *    - volatile (object, default: null):\n   *        Additional information passed to notifications to other users\n   *\n   * @param {object} request\n   * @param {object} [options] - Optional arguments\n   * @returns {Promise<object>}\n   */\n  query (request = {}, options = {}) {\n    if (!request || typeof request !== 'object' || Array.isArray(request)) {\n      return Promise.reject(new Error(`Invalid request: ${JSON.stringify(request)}`));\n    }\n\n    if (!request.requestId) {\n      request.requestId = uuidv4();\n    }\n\n    // we follow the api but allow some more logical \"mistakes\"\n    if (request.options) {\n      request.options = 'wait_for';\n    }\n\n    if (!request.volatile) {\n      request.volatile = {};\n    }\n    if (!request.volatile || typeof request.volatile !== 'object' || Array.isArray(request.volatile)) {\n      return Promise.reject(new Error('Invalid volatile argument received. Must be an object.'));\n    }\n    request.volatile.sdkInstanceId= this.network.id;\n    request.volatile.sdkVersion = this.sdkVersion;\n\n    /*\n     * Do not add the token for the checkToken route, to avoid getting a token error when\n     * a developer simply wish to verify his token\n     */\n    if (this.jwt !== undefined\n      && request.controller !== 'auth'\n      && request.action !== 'checkToken'\n    ) {\n      request.jwt = this.jwt;\n    }\n\n    return this.network.query(request, options)\n      .then(response => response.result);\n  }\n\n  /**\n   * Starts the requests queuing.\n   */\n  startQueuing () {\n    this.network.startQueuing();\n    return this;\n  }\n\n  /**\n   * Stops the requests queuing.\n   */\n  stopQueuing () {\n    this.network.stopQueuing();\n    return this;\n  }\n\n  /**\n   * @DEPRECATED\n   * See Kuzzle.prototype.playQueue();\n   */\n  replayQueue () {\n    return this.playQueue();\n  }\n\n  /**\n   * Plays the requests queued during offline mode.\n   */\n  playQueue () {\n    this.network.playQueue();\n    return this;\n  }\n\n  /**\n   * Sets the default Kuzzle index\n   *\n   * @param index\n   * @returns this\n   */\n  setDefaultIndex (index) {\n    if (typeof index !== 'string') {\n      throw new Error(`Invalid default index: [${index}] (an index name is expected)`);\n    }\n\n    if (index.length === 0) {\n      throw new Error('Cannot set an empty index as the default index');\n    }\n\n    this.defaultIndex = index;\n\n    return this;\n  }\n\n  _checkPropertyType (prop, typestr, value) {\n    const wrongType = typestr === 'array' ? !Array.isArray(value) : typeof value !== typestr;\n\n    if (wrongType) {\n      throw new Error(`Expected ${prop} to be a ${typestr}, ${typeof value} received`);\n    }\n  }\n}\n\n\nfor (const prop of ['autoResubscribe']) {\n  Object.defineProperty(Kuzzle.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = Kuzzle;\n","const User = require('./security/user');\n\nlet _kuzzle;\n\n/**\n * Auth controller\n *\n * @param kuzzle\n * @constructor\n */\nclass AuthController {\n\n  /**\n   * constructor\n   * @param kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  /**\n   * Checks whether a given jwt token still represents a valid session in Kuzzle.\n   *\n   * @param  {string}   token     The jwt token to check\n   * @return {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  checkToken (token) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'checkToken',\n      body: {token}\n    }, {queuable: false});\n  }\n\n  /**\n   * Create credentials of the specified <strategy> for the current user.\n   *\n   * @param credentials\n   * @param strategy\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  createMyCredentials (strategy, credentials, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'createMyCredentials',\n      body: credentials\n    }, options);\n  }\n\n  /**\n   * Check the existence of the specified <strategy>'s credentials for the current user.\n   *\n   * @param strategy\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  credentialsExist (strategy, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'credentialsExist'\n    }, options);\n  }\n\n  /**\n   * Delete credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  deleteMyCredentials (strategy, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'deleteMyCredentials'\n    }, options);\n  }\n\n  /**\n   * Fetches the current user.\n   *\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getCurrentUser (options = {}) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'getCurrentUser'\n    }, options)\n      .then(result => {\n        const user = new User(this.kuzzle);\n        user.id = result.id;\n        user.content = result._source;\n        user.meta = result._meta;\n\n        return user;\n      });\n  }\n\n  /**\n   * Get credential information of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getMyCredentials(strategy, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'auth',\n      action: 'getMyCredentials'\n    }, options);\n  }\n\n  /**\n   * Gets the rights array of the currently logged user.\n   *\n   * @param {object} [options] - Optional parameters\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getMyRights (options = {}) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'getMyRights'\n    }, options)\n      .then(res => res.hits);\n  }\n\n  /**\n   * Get all the strategies registered in Kuzzle by all auth plugins\n   *\n   * @param {object} [options] - Optional parameters\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  getStrategies (options = {}) {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'getStrategies'\n    }, options);\n  }\n\n  /**\n   * Send login request to kuzzle with credentials\n   * If login success, store the jwt into kuzzle object\n   *\n   * @param strategy\n   * @param credentials\n   * @param expiresIn\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  login (strategy, credentials, expiresIn) {\n    if (typeof strategy !== 'string' || strategy === '') {\n      return Promise.reject(new Error('auth.login: strategy required'));\n    }\n\n    const\n      request = {\n        strategy,\n        expiresIn,\n        body: credentials || {},\n        controller: 'auth',\n        action: 'login'\n      };\n\n    return this.kuzzle.query(request, {queuable: false})\n      .then(result => {\n        try {\n          this.kuzzle.jwt = result.jwt;\n          this.kuzzle.emit('loginAttempt', {success: true});\n        }\n        catch (err) {\n          return Promise.reject(err);\n        }\n        return result.jwt;\n      })\n      .catch(err => {\n        this.kuzzle.emit('loginAttempt', {success: false, error: err.message});\n        throw err;\n      });\n  }\n\n  /**\n   * Send logout request to kuzzle with jwt.\n   *\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  logout () {\n    return this.kuzzle.query({\n      controller: 'auth',\n      action: 'logout'\n    }, {queuable: false})\n      .then(() => {\n        this.kuzzle.jwt = undefined;\n      });\n  }\n\n  /**\n   * Update credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentals\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  updateMyCredentials (strategy, credentials, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      body: credentials,\n      controller: 'auth',\n      action: 'updateMyCredentials'\n    }, options);\n  }\n\n  /**\n   * Update current user in Kuzzle.\n   *\n   * @param {object} body - a plain javascript object representing the user's modification\n   * @param {object} [options] - (optional) arguments\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  updateSelf (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'auth',\n      action: 'updateSelf'\n    }, options);\n  }\n\n  /**\n   * Validate credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentials\n   * @param options\n   * @returns {Promise|*|PromiseLike<T>|Promise<T>}\n   */\n  validateMyCredentials (strategy, credentials, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      body: credentials,\n      controller: 'auth',\n      action: 'validateMyCredentials'\n    }, options);\n  }\n\n}\n\nmodule.exports = AuthController;\n","const\n  SpecificationsSearchResult = require('./searchResult/specifications');\n\nlet _kuzzle;\n\nclass CollectionController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  create (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.create: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.create: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'create'\n    }, options);\n  }\n\n  deleteSpecification (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.deleteSpecification: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.deleteSpecification: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'deleteSpecification'\n    }, options);\n  }\n\n  exists (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.exists: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.exists: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'exists'\n    }, options);\n  }\n\n  getMapping (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.getMapping: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.getMapping: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'getMapping'\n    }, options);\n  }\n\n  getSpecifications (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.getSpecifications: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.getSpecifications: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'getSpecifications'\n    }, options);\n  }\n\n  list (index, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.list: index is required'));\n    }\n\n    const request = {\n      index,\n      controller: 'collection',\n      action: 'list',\n      from: options.from,\n      size: options.size\n    };\n    delete options.from;\n    delete topions.size;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  searchSpecifications (body = {}, options = {}) {\n    const request = {\n      body,\n      controller: 'collection',\n      action: 'searchSpecifications'\n    };\n    for (const opt of ['from', 'size', 'scroll']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(response => new SpecificationsSearchResult(this.kuzzle, query, options, response));\n  }\n\n  truncate (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.truncate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.truncate: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'colleciton',\n      action: 'truncate'\n    }, options);\n  }\n\n  updateMapping (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.updateMapping: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.updateMapping: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'collection',\n      action: 'updateMapping'\n    }, options);\n  }\n\n  updateSpecifications (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.updateSpecifications: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.updateSpecifications: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'collection',\n      action: 'updateSpecifications'\n    }, options);\n  }\n\n  validateSpecifications (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'collection',\n      action: 'validateSpecifications'\n    }, options);\n  }\n}\n\nmodule.exports = CollectionController;\n","const SearchResultBase = require('./base');\n\nclass SpecificationsSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.controller = 'collection';\n    this.searchAction = 'searchSpecifications';\n    this.scrollAction = 'scrollSpecifications';\n  }\n}\n\nmodule.exports = SpecificationsSearchResult;\n","const\n  DocumentSearchResult = require('./searchResult/document');\n\nlet _kuzzle;\n\nclass DocumentController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  count (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.count: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.count: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'count',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options)\n      .then(response => response.count);\n  }\n\n  create (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.create: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.create: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'create',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  createOrReplace (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: _id is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'createOrReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  delete (index, collection, _id, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.delete: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.delete: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.delete: _id is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'delete',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  deleteByQuery(index, collection, body = {}, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.deleteByQuery: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.deleteByQuery: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'deleteByQuery',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  get (index, collection, _id, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.get: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.get: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      controller: 'document',\n      action: 'get',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mCreate (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mCreate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mCreate: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mCreate: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mCreate',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mCreateOrReplace (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mCreateOrReplace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mCreateOrReplace: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mCreateOrReplace: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mCreateOrReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mDelete (index, collection, ids, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mDelete: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mDelete: collection is required'));\n    }\n    if (!Array.isArray(ids)) {\n      return Promise.reject(new Error('Kuzzle.document.mDelete: ids must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {ids},\n      controller: 'document',\n      action: 'mDelete',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mGet (index, collection, ids, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mGet: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mGet: collection is required'));\n    }\n    if (!Array.isArray(ids)) {\n      return Promise.reject(new Error('Kuzzle.document.mGet: ids must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {ids},\n      controller: 'document',\n      action: 'mGet',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mReplace (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mReplace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mReplace: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mReplace: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n    return this.kuzzle.query(request, options);\n  }\n\n  mUpdate (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mUpdate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mUpdate: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mUpdate: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mUpdate',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  replace (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.replace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.replace: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.replace: _id is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.replace: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'replace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  search (index, collection, body = {}, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.search: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.search: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'search',\n    };\n    for (const opt of ['from', 'size', 'scroll', 'sort', 'includeTrash']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(response => new DocumentSearchResult(this.kuzzle, request, options, response));\n  }\n\n  update (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.update: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.update: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.update: _id is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.update: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'update',\n      refresh: options.refresh,\n      retryOnConflict: options.retryOnConflict\n    };\n    delete options.refresh;\n    delete options.retryOnConflict;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  validate (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.validate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.validate: collection is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.validate: body is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'validate'\n    }, options);\n  }\n}\n\nmodule.exports = DocumentController;\n","const\n  SearchResultBase = require('./base');\n\nclass DocumentsSearchResult extends SearchResultBase {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   * @param {object} query\n   * @param {object} options\n   * @param {object} response\n   */\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.searchAction = 'search';\n    this.scrollAction = 'scroll';\n  }\n}\n\nmodule.exports = DocumentsSearchResult;\n","let _kuzzle;\n\nclass IndexController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  create (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.create: index required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'create'\n    }, options);\n  }\n\n  delete (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.delete: index required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'delete'\n    }, options);\n  }\n\n  exists (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.exists: index required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'exists'\n    }, options);\n  }\n\n  getAutoRefresh (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.getAutoRefresh: index is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'getAutoRefresh'\n    }, options);\n  }\n\n  list (options) {\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'list'\n    }, options);\n  }\n\n  mDelete (indexes, options) {\n    if (!Array.isArray(indexes)) {\n      return Promise.reject(new Error('Kuzzle.index.mDelete: indexes must be an array'));\n    }\n\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'mDelete'\n    }, {\n      body: {\n        indexes\n      }\n    }, options);\n  }\n\n  refresh (index, options) {\n    if (!index || index === '') {\n      return Promise.reject(new Error('Kuzzle.index.refresh: index is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'refresh'\n    }, options);\n  }\n\n  refreshInternal (options) {\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'refreshInternal'\n    }, options);\n  }\n\n  setAutoRefresh (index, autoRefresh, options) {\n    if (autoRefresh === undefined && typeof index === 'boolean') {\n      autoRefresh = index;\n      index = this.kuzzle.defaultIndex;\n    }\n\n    if (!index || index === '') {\n      return Promise.reject(new Error('Kuzzle.index.setAutoRefresh: index is required'));\n    }\n\n    if (typeof autoRefresh !== 'boolean') {\n      return Promise.reject(new Error('Kuzzle.index.setAutoRefresh: autoRefresh must be a boolean'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'setAutoRefresh',\n      body: {\n        autoRefresh\n      }\n    }, options);\n  }\n}\n\nmodule.exports = IndexController;\n","const\n  Room = require('./room');\n\nlet _kuzzle;\n\nclass RealTimeController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n\n    this.subscriptions = {\n      filters: {},\n      channels: {}\n    };\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  count (roomId, options = {}) {\n    if (!roomId) {\n      return Promise.reject(new Error('Kuzzle.realtime.count: roomId is required'));\n    }\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'count',\n      body: {roomId}\n    }, options);\n  }\n\n  join (roomId, options = {}) {\n    if (!roomId) {\n      return Promise.reject(new Error('Kuzzle.realtime.join: roomId is required'));\n    }\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'join',\n      body: {roomId}\n    }, options);\n  }\n\n  list (options = {}) {\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'list'\n    }, options);\n  }\n\n  publish (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: collection is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'publish'\n    };\n\n    return this.kuzzle.query(request, options);\n  }\n\n  subscribe (index, collection, body, callback, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.realtime.subscribe: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.realtime.subscribe: collection is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.realtime.subscribe: body is required'));\n    }\n    if (!callback || typeof callback !== 'function') {\n      return Promise.reject(new Error('Kuzzle.realtime.subscribe: a callback function is required'));\n    }\n\n    const room = new Room(this.kuzzle, index, collection, body, callback, options);\n\n    return room.subscribe()\n      .then(response => {\n        if (!this.subscriptions[room.id]) {\n          this.subscriptions[room.id] = [];\n        }\n        this.subscriptions[room.id].push(room);\n        return response;\n      });\n  }\n\n  unsubscribe (roomId, options = {}) {\n    const rooms = this.subscriptions[roomId];\n\n    if (!rooms) {\n      return Promise.reject(new Error(`not subscribed to ${roomId}`));\n    }\n\n    for (const room of rooms) {\n      room.removeListeners();\n    }\n    delete this.subscriptions[roomId];\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'unsubscribe',\n      body: {roomId}\n    }, options);\n  }\n\n  validate (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: collection is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: body is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'validate'\n    }, options);\n  }\n\n}\n\nmodule.exports = RealTimeController;\n","class Room {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   * @param {string} index\n   * @param {string} collection\n   * @param {object} body\n   * @param {function} callback\n   * @param {object} options\n   */\n  constructor (kuzzle, index, collection, body, callback, options = {}) {\n    this.kuzzle = kuzzle;\n    this.index = index;\n    this.collection = collection;\n    this.callback = callback;\n    this.options = options;\n\n    this.id = null;\n    this.channel = null;\n\n    // format complete request from body & options\n    this.request = {\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'subscribe'\n    };\n    for (const opt of ['state', 'scope', 'users', 'volatile']) {\n      this.request[opt] = this.options[opt];\n      delete this.options[opt];\n    }\n\n    this.autoResubscribe = typeof options.autoResubscribe === 'boolean'\n      ? options.autoResubscribe\n      : kuzzle.autoResubscribe;\n    this.subscribeToSelf = typeof options.subscribeToSelf === 'boolean'\n      ? options.subscribeToSelf\n      : true;\n\n    // force bind for further event listener calls\n    this._channelListener = this._channelListener.bind(this);\n    this._reSubscribeListener = this._reSubscribeListener.bind(this);\n  }\n\n  subscribe () {\n    return this.kuzzle.query(this.request, this.options)\n      .then(response => {\n        this.id = response.roomId;\n        this.channel = response.channel;\n\n        // we rely on kuzzle event emitter to not duplicate the listeners here\n        this.kuzzle.network.on(this.channel, this._channelListener);\n\n        this.kuzzle.addListener('reconnected', this._reSubscribeListener);\n\n        return response;\n      });\n  }\n\n  removeListeners () {\n    this.kuzzle.removeListener('reconnected', this._reSubscribeListener);\n\n    if (this.channel) {\n      this.kuzzle.network.removeListener(this.channel, this._channelListener);\n    }\n  }\n\n  _channelListener (data) {\n    const fromSelf = data.volatile !== undefined && data.volatile.sdkInstanceId === this.kuzzle.network.id;\n    if (this.subscribeToSelf || !fromSelf) {\n      this.callback(data);\n    }\n  }\n\n  _reSubscribeListener () {\n    if (this.autoResubscribe) {\n      return this.subscribe();\n    }\n  }\n}\n\nmodule.exports = Room;\n","let _kuzzle;\n\nclass ServerController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  adminExists (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'adminExists'\n    }, options)\n      .then(result => result.exists);\n  }\n\n  getAllStats (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getAllStats'\n    }, options);\n  }\n\n  getConfig (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getConfig'\n    }, options);\n  }\n\n  getLastStats (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getLastStats'\n    }, options);\n  }\n\n  info (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'info'\n    }, options);\n  }\n\n  now (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'now'\n    }, options)\n      .then(result => result.now);\n  }\n}\n\nmodule.exports = ServerController;\n","const\n  Role = require('./role'),\n  RoleSearchResult = require('../searchResult/role'),\n  Profile = require('./profile'),\n  ProfileSearchResult = require('../searchResult/profile'),\n  User = require('./user'),\n  UserSearchResult = require('../searchResult/user');\n\nlet\n  _kuzzle;\n\n\nclass SecurityController {\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n\n  createCredentials (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'createCredentials'\n    }, options);\n  }\n\n  createFirstAdmin (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'createFirstAdmin'\n    }, options);\n  }\n\n  createOrReplaceProfile (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'createOrReplaceProfile'\n    }, options);\n  }\n\n  createOrReplaceRole (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'createOrReplaceRole'\n    }, options);\n  }\n\n  createProfile (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'createProfile'\n    }, options);\n  }\n\n  createRole (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'createRole'\n    }, options);\n  }\n\n  createUser (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'createUser'\n    }, options);\n  }\n\n  deleteCredentials (strategy, _id, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'deleteCredentials'\n    }, options);\n  }\n\n  deleteProfile (_id, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'deleteProfile'\n    }, options);\n  }\n\n  deleteUser (_id, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'deleteUser'\n    }, options);\n  }\n\n  getAllCredentialFields (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getAllCredentialFields'\n    }, options);\n  }\n\n  getCredentialFields (strategy, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      controller: 'security',\n      action: 'getCredentialFields'\n    }, options);\n  }\n\n  getCredentials (strategy, _id, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'getCredentials'\n    }, options);\n  }\n\n  getCredentialsById (strategy, _id, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'getCrednetialsById'\n    }, options);\n  }\n\n  getProfile (_id, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getProfile'\n    }, options)\n      .then(result => {\n        const profile = new Profile(this.kuzzle);\n\n        profile._id = result._id;\n        profile.policies = result._source.policies;\n\n        return profile;\n      });\n  }\n\n  getProfileMapping (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getProfileMapping'\n    }, options);\n  }\n\n  getProfileRights (_id, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getProfileRights'\n    }, options);\n  }\n\n  getRole (_id, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getRole'\n    }, options)\n      .then(result => {\n        const role = new Role(this.kuzzle);\n\n        role._id = result._id;\n        role.controllers = result._source.controllers;\n\n        return role;\n      });\n  }\n\n  getRoleMapping (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getRoleMapping'\n    }, options);\n  }\n\n  getUser (_id, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getUser'\n    }, options)\n      .then(result => {\n        const user = new User(this.kuzzle);\n\n        user._id = result._id;\n        user.content = result._source;\n        user.meta = result._meta;\n\n        return user;\n      });\n  }\n\n  getUserMapping (options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'getUserMapping'\n    }, options);\n  }\n\n  getUserRights (_id, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      controller: 'security',\n      action: 'getuserRights'\n    }, options)\n      .then(result => result.hits);\n  }\n\n  hasCredentials (strategy, _id, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      controller: 'security',\n      action: 'hasCredentials'\n    }, options);\n  }\n\n  mDeleteProfiles (ids, options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'mDeleteProfiles',\n      body: {ids}\n    }, options);\n  }\n\n  mDeleteRoles (ids, options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'mDeleteRoles',\n      body: {ids}\n    }, options);\n  }\n\n  mDeleteUsers (ids, options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'mDeleteUsers',\n      body: {ids}\n    }, options);\n  }\n\n  mGetProfiles (ids, options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'mGetProfiles',\n      body: {ids}\n    }, options)\n      .then(result => result.hits.map(hit => {\n        const profile = new Profile(this.kuzzle);\n\n        profile._id = hit._id;\n        profile.policies = hit._source.policies;\n\n        return profile;\n      }));\n  }\n\n  mGetRoles (ids, options = {}) {\n    return this.kuzzle.query({\n      controller: 'security',\n      action: 'mGetRoles',\n      body: {ids}\n    }, options)\n      .then(result => result.hits.map(hit => {\n        const role = new Role(this.kuzzle);\n\n        role._id = hit._id;\n        role.controllers = hit._source.controllers;\n\n        return role;\n      }));\n  }\n\n  replaceUser (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'replaceUser'\n    }, options)\n      .then(result => {\n        const user = new User(this.kuzzle);\n\n        user._id = result._id;\n        user.content = result._source;\n        user.meta = result._meta;\n\n        return user;\n      });\n  }\n\n  searchProfiles (body, options= {}) {\n    const request = {\n      body,\n      controller: 'security',\n      action: 'searchProfiles'\n    };\n\n    return this.kuzzle.query(request, options)\n      .then(result => new ProfileSearchResult(this.kuzzle, request, options, result));\n  }\n\n  searchRoles (body, options = {}) {\n    const request = {\n      body,\n      controller: 'security',\n      action: 'searchRoles'\n    };\n\n    return this.kuzzle.query(request, options)\n      .then(result => new RoleSearchResult(this.kuzzle, request, options, result));\n  }\n\n  searchUsers (body, options = {}) {\n    const request = {\n      body,\n      controller: 'security',\n      action: 'searchUsers'\n    };\n\n    return this.kuzzle.query(request, options)\n      .then(result => new UserSearchResult(this.kuzzle, request, options, result));\n  }\n\n  updateCredentials (strategy, _id, body, options = {}) {\n    return this.kuzzle.query({\n      strategy,\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateCredentials'\n    }, options);\n  }\n\n  updateProfile (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateProfile'\n    }, options);\n  }\n\n  updateProfileMapping (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'security',\n      action: 'updateProfileMapping'\n    }, options);\n  }\n\n  updateRole (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateRole'\n    }, options);\n  }\n\n  updateRoleMapping (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'security',\n      action: 'updateRoleMapping'\n    }, options);\n  }\n\n  updateUser (_id, body, options = {}) {\n    return this.kuzzle.query({\n      _id,\n      body,\n      controller: 'security',\n      action: 'updateUser'\n    }, options);\n  }\n\n  updateUserMapping (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'security',\n      action: 'updateUserMapping'\n    }, options);\n  }\n\n  validateCredentials (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'security',\n      action: 'validateCredentials'\n    }, options);\n  }\n}\n\nmodule.exports = SecurityController;\n","const\n  Role = require('../security/role'),\n  SearchResultBase = require('./base');\n\nclass RoleSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.searchAction = 'searchRoles';\n    this.scrollAction = 'scrollRoles';\n  }\n\n  next () {\n    return super.next()\n      .then(result => {\n        if (!result) {\n          return result;\n        }\n\n        return result.hits.map(hit => {\n          const role = new Role(this.kuzzle);\n\n          role._id = hit._id;\n          role.controllers = hit._source.controllers;\n\n          return role;\n        });\n      });\n  }\n}\n\nmodule.exports = RoleSearchResult;\n","const\n  Profile = require('../security/profile'),\n  SearchResultBase = require('./base');\n\nclass ProfileSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, request, options, response) {\n    super(kuzzle, request, options, response);\n\n    this.searchAction = 'searchProfiles';\n    this.scrollAction = 'scrollProfiles';\n  }\n\n  next () {\n    return super.next()\n      .then(result => {\n        if (!result) {\n          return result;\n        }\n\n        return result.hits.map(hit => {\n          const profile = new Profile(this.kuzzle);\n\n          profile._id = hit._id;\n          profile.policies = hit._source.policies;\n\n          return profile;\n        });\n      });\n  }\n}\n\nmodule.exports = ProfileSearchResult;\n","const\n  SearchResultBase = require('./base'),\n  User = require('../security/user');\n\nclass UserSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.searchAction = 'searchUsers';\n    this.scrollAction = 'scrollUsers';\n  }\n\n  next () {\n    return super.next()\n      .then(result => {\n        if (!result) {\n          return result;\n        }\n\n        return result.hits.map(hit => {\n          const user = new User(this.kuzzle);\n\n          user._id = hit._id;\n          user.content = hit._source;\n          user.meta = hit._meta;\n\n          return user;\n        });\n      });\n  }\n}\n\nmodule.exports = UserSearchResult;\n","// Parameter mutualization\nconst\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true, \n    required: ['_id', 'cursor'], \n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']};\n\n// Redis commands\nconst\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    flushdb: {mapResults: mapNoResult},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: {required: ['_id', 'field', 'value']},\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n    hscan: getxScan,\n    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n    mget: getKeys,\n    mset: {required: ['entries'], mapResults: mapNoResult},\n    msetnx: {required: ['entries'], mapResults: Boolean},\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: {required: ['_id'], mapResults: Boolean},\n    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\nlet\n  _kuzzle;\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nclass MemoryStorageController {\n\n  constructor (kuzzle) {\n    _kuzzle = kuzzle;\n  }\n\n  get kuzzle () {\n    return _kuzzle;\n  }\n}\n\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(() => {\n  for (const action of Object.keys(commands)) {\n    // eslint-disable-next-line no-loop-func\n    MemoryStorageController.prototype[action] = (...args) => {\n      const\n        command = commands[action],\n        request = {\n          action,\n          controller: 'ms'\n        },\n        options = {};\n\n      if (!command.getter) {\n        request.body = {};\n      }\n\n      for (const param of command.required || []) {\n        const value = args.shift();\n\n        if (value === undefined) {\n          throw new Error(`ms.${action}: missing parameter ${param}`);\n        }\n\n        assignParameter(request, command.getter, param, value);\n      }\n\n      if (args.length > 1) {\n        throw new Error(`ms.${action}: too many parameters provided`);\n      }\n\n      if (args.length) {\n        if (typeof args[0] !== 'object' || Array.isArray(args[0])) {\n          throw new Error(`ms.${action}: invalid optional paramater (expected an object`);\n        }\n\n        Object.assign(options, args[0]);\n\n        if (Array.isArray(command.opts)) {\n          for (const opt of command.opts) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(request, command.getter, opt, options[opt]);\n              delete options[opt];\n            }\n          }\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof command.opts === 'function') {\n        command.opts(data, options);\n      }\n\n      return this.kuzzle.query(request, options)\n        .then(res => {\n          if (command.mapResults) {\n            return command.mapResults(res.result);\n          }\n          return res.result;\n        });\n    };\n  }\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  const parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions (data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults (results) {\n  return results.map(coords => coords.map(parseFloat));\n}\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    const p = {\n      name: point.shift()\n    };\n\n    for (const elem of point) {\n      if (Array.isArray(elem)) {\n        // withcoord result are in an array...\n        p.coordinates = elem.map(parseFloat);\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(elem);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray(results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt (results) {\n  return results.map(parseInt);\n}\n\n/**\n * Disable results for routes like flushdb\n * @return {undefined}\n */\nfunction mapNoResult () {}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults (results) {\n  const mapped = [];\n\n  for (let i = 0; i < results.length; i += 2) {\n    mapped.push({\n      member: results[i],\n      score: parseFloat(results[i + 1])\n    });\n  }\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\", \n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n * \n * @param  {array.<string|array>} results \n * @return {object}\n */\nfunction mapScanResults (results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorageController;\n","/**\n *\n * @param protocol\n * @param host\n * @param options\n * @returns {AbstractWrapper} Instantiated WebSocket/Socket.IO object\n */\n\nfunction network (protocol, host, options) {\n  switch (protocol) {\n    case 'http':\n      return new (require('./protocols/http'))(host, options);\n    case 'websocket':\n      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n        throw new Error('Aborting: no websocket support detected.');\n      }\n      return new (require('./protocols/websocket'))(host, options);\n    case 'socketio':\n      if (!window.io) {\n        throw new Error('Aborting: no socket.io library loaded.');\n      }\n      return new (require('./protocols/socketio'))(host, options);\n    default:\n      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n  }\n}\n\nmodule.exports = network;\n","'use strict';\n\nconst\n  AbtractWrapper = require('./abstract/common');\n\nconst\n  _routes = {\n    routes: {\n      auth: {\n        login: {\n          verb: 'POST',\n          url: '/_login/:strategy'\n        }\n      },\n      bulk: {\n        import: {\n          verb: 'POST',\n          url: '/:index/:collection/_bulk'\n        }\n      },\n      document: {\n        create: {\n          verb: 'POST',\n          url: '/:index/:collection/_create'\n        }\n      },\n      security: {\n        createFirstAdmin: {\n          verb: 'POST',\n          url: '/_createFirstAdmin'\n        },\n        createRestrictedUser: {\n          verb: 'POST',\n          url: '/users/_createRestricted'\n        },\n        createUser: {\n          verb: 'POST',\n          url: '/users/_create'\n        }\n      }\n    }\n  };\n\n\nclass HttpWrapper extends AbtractWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    // Application-side HTTP route overrides:\n    if (options.http && options.http.customRoutes) {\n      for (const controller in options.http.customRoutes) {\n        if (options.http.customRoutes.hasOwnProperty(controller)) {\n          this.http.routes[controller] = Object.assign(this.http.routes[controller] || {}, options.http.customRoutes[controller]);\n        }\n      }\n    }\n  }\n\n  get http () {\n    return _routes;\n  }\n\n  get protocol () {\n    return this.ssl ? 'https' : 'http';\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    if (this.state === 'ready') {\n      return Promise.resolve();\n    }\n\n    return this._sendHttpRequest('GET', '/')\n      .then(res => {\n        // Get HTTP Routes from Kuzzle serverInfo\n        // (if more than 1 available route for a given action, get the first one):\n        const routes = res.result.serverInfo.kuzzle.api.routes;\n        for (const controller of Object.keys(routes)) {\n          if (this.http.routes[controller] === undefined) {\n            this.http.routes[controller] = {};\n          }\n\n          for (const action of Object.keys(routes[controller])) {\n            if (this.http.routes[controller][action] === undefined\n              && Array.isArray(routes[controller][action].http)\n              && routes[controller][action].http.length > 0) {\n\n              this.http.routes[controller][action] = routes[controller][action].http[0];\n            }\n          }\n        }\n\n        // Client is ready\n        this.clientConnected();\n      })\n      .catch(err => {\n        this.emit('networkError', err);\n        throw err;\n      });\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} data\n   * @returns {Promise<any>}\n   */\n  send (data) {\n    const\n      payload = {\n        action: undefined,\n        body: undefined,\n        collection: undefined,\n        controller: undefined,\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        index: undefined,\n        meta: undefined,\n        requestId: undefined,\n      },\n      queryArgs = {};\n\n    for (const key of Object.keys(data)) {\n      const value = data[key];\n\n      if (key === 'body') {\n        payload.body = JSON.stringify(value);\n      }\n      else if (key === 'jwt') {\n        payload.headers.authorization = 'Bearer ' + value;\n      }\n      else if (key === 'volatile') {\n        payload.headers['x-kuzzle-volatile'] = JSON.stringify(value);\n      }\n      else if (payload.hasOwnProperty(key)) {\n        payload[key] = value;\n      }\n      else {\n        queryArgs[key] = value;\n      }\n    }\n\n    //payload.headers['Content-Length'] = Buffer.byteLength(payload.body || '');\n\n    const\n      route = this.http.routes[payload.controller] && this.http.routes[payload.controller][payload.action];\n\n    if (route === undefined) {\n      const error = new Error(`No route found for ${payload.controller}/${payload.action}`);\n      return this.emit(payload.requestId, {status: 400, error});\n    }\n\n    const\n      method = route.verb,\n      regex = /\\/:([^/]*)/;\n\n    let\n      url = route.url,\n      matches = regex.exec(url);\n\n    while (matches) {\n      url = url.replace(regex, '/' + data[ matches[1] ]);\n      delete(queryArgs[ matches[1] ]);\n      matches = regex.exec(url);\n    }\n\n    // inject queryString arguments:\n    const queryString = [];\n    for (const key of Object.keys(queryArgs)) {\n      const value = queryArgs[key];\n\n      if (Array.isArray(value)) {\n        queryString.push(...value.map(v => `${key}=${v}`));\n\n      }\n      else {\n        queryString.push(`${key}=${value}`);\n      }\n    }\n\n    if (queryString.length > 0) {\n      url += '?' + queryString.join('&');\n    }\n\n    return this._sendHttpRequest(method, url, payload)\n      .then(response => this.emit(payload.requestId, response))\n      .catch(error => this.emit(payload.requestId, {error}));\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.disconnect();\n  }\n\n  _sendHttpRequest (method, path, payload = {}) {\n    if (typeof XMLHttpRequest === 'undefined') {\n      // NodeJS implementation, using http.request:\n\n      const httpClient = require('min-req-promise');\n      const url = `${this.protocol}://${this.host}:${this.port}${path}`;\n\n      return httpClient.request(url, method, {\n        headers: payload.headers,\n        body: payload.body\n      })\n        .then(response => JSON.parse(response.body));\n    }\n\n    // Browser implementation, using XMLHttpRequest:\n    return new Promise((resolve, reject) => {\n      const\n        xhr = new XMLHttpRequest(),\n        url = `${this.protocol}://${this.host}:${this.port}${path}`;\n\n      console.log(payload); // eslint-disable-line no-console\n      xhr.open(method, url);\n\n      for (const header of Object.keys(payload.headers || {})) {\n        xhr.setRequestHeader(header, payload.headers[header]);\n      }\n\n      xhr.onload = () => {\n        try {\n          const json = JSON.parse(xhr.responseText);\n          resolve(json);\n        }\n        catch (err) {\n          reject(err);\n        }\n      };\n\n      xhr.send(payload.body);\n    });\n  }\n\n}\n\nfor (const prop of [\n  'protocol'\n]) {\n  Object.defineProperty(HttpWrapper.prototype, prop, {enumerable: true});\n}\n\nmodule.exports = HttpWrapper;\n","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nlet WebSocketClient;\n\nclass WSNode extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : require('uws');\n    this.client = null;\n    this.lasturl = null;\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    return new Promise((resolve, reject) => {\n      const\n        url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n        opts = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n      super.connect();\n\n      if (url !== this.lasturl) {\n        this.wasConnected = false;\n        this.lasturl = url;\n      }\n\n      this.client = new WebSocketClient(url, opts);\n\n      this.client.onopen = () => {\n        this.clientConnected();\n        return resolve();\n      };\n\n      this.client.onclose = (closeEvent, message) => {\n        let\n          status,\n          reason = message;\n\n        if (typeof closeEvent === 'number') {\n          status = closeEvent;\n        }\n        else {\n          status = closeEvent.code;\n\n          if (closeEvent.reason) {\n            reason = closeEvent.reason;\n          }\n        }\n\n        if (status === 1000) {\n          this.clientDisconnected();\n        }\n        // do not forward a connection close error if no\n        // connection has been previously established\n        else if (this.wasConnected) {\n          const error = new Error(reason);\n          error.status = status;\n\n          this.clientNetworkError(error);\n        }\n      };\n\n      this.client.onerror = error => {\n        const err = (error instanceof Error) && error || new Error(error);\n\n        this.clientNetworkError(err);\n\n        if ([this.client.CLOSING, this.client.CLOSED].indexOf(this.client.readyState) > -1) {\n          return reject(err);\n        }\n      };\n\n      this.client.onmessage = payload => {\n        const data = JSON.parse(payload.data || payload);\n\n        // for responses, data.room == requestId\n        if (data.room) {\n          this.emit(data.room, data);\n        }\n        else {\n          this.emit('discarded', data);\n        }\n      };\n\n    });\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.state = 'offline';\n    this.removeAllListeners();\n    this.wasConnected = false;\n    if (this.client) {\n      this.client.close();\n    }\n    this.client = null;\n    this.stopRetryingToConnect = true;\n    this.disconnect();\n  }\n}\n\nmodule.exports = WSNode;\n","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nclass SocketIO extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    this.socket = null;\n    this.forceDisconnect = false;\n    this.eventsWrapper = {};\n  }\n\n  /**\n   *\n   * @returns {Promise<any>}\n   */\n  connect () {\n    return new Promise((resolve, reject) => {\n      super.connect();\n\n      this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n        reconnection: this.autoReconnect,\n        reconnectionDelay: this.reconnectionDelay,\n        forceNew: true\n      });\n\n      this.socket.on('connect', () => resolve(this.clientConnected()));\n      this.socket.on('connect_error', error => {\n        this.clientNetworkError(error);\n        reject(error);\n      });\n\n      this.socket.on('disconnect', () => {\n        if (this.forceDisconnect) {\n          this.clientDisconnected();\n        } else {\n          const error = new Error('An error occurred, kuzzle may not be ready yet');\n          error.status = 500;\n\n          this.clientNetworkError(error);\n          reject(error);\n        }\n\n        this.forceDisconnect = false;\n      });\n\n    });\n  }\n\n  /**\n   * Registers a callback on an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   * @param {boolean} once\n   */\n  addListener (event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    super.addListener(event, callback, once);\n\n    return this;\n  }\n\n  prependListener (event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    return super.prependListener(event, callback, once);\n  }\n\n  /**\n   * Unregisters a callback from an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  removeListener (event, callback) {\n    if (this.eventsWrapper[event]) {\n      this.eventsWrapper[event].listeners.delete(callback);\n\n      if (this.eventsWrapper[event].listeners.size === 0) {\n        this.socket.off(event, this.eventsWrapper[event].wrapper);\n        delete this.eventsWrapper[event];\n      }\n\n      super.removeListener(event, callback);\n    }\n\n    return this;\n  }\n\n  /**\n   * Unregisters all listeners either from an event, or from all events\n   *\n   * @param {string} [event]\n   */\n  removeAllListeners (event) {\n    if (event !== undefined) {\n      if (this.eventsWrapper[event] !== undefined) {\n        for (const listener of this.eventsWrapper[event].listeners) {\n          this.removeListener(event, listener);\n        }\n      }\n    } else {\n      for (const _event of Object.keys(this.eventsWrapper)) {\n        this.removeAllListeners(_event);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send(payload) {\n    this.socket.emit('kuzzle', payload);\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.forceDisconnect = true;\n    this.state = 'offline';\n    this.socket.close();\n    this.socket = null;\n    this.disconnect();\n  }\n\n  _addEventWrapper (event, callback, once = false) {\n    if (!this.eventsWrapper[event]) {\n      const wrapper = (...args) => this.emit(event, ...args);\n\n      this.eventsWrapper[event] = {\n        wrapper,\n        listeners: new Set()\n      };\n\n      if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n        if (once) {\n          this.socket.once(event, wrapper);\n        } else {\n          this.socket.on(event, wrapper);\n        }\n      }\n    }\n\n    this.eventsWrapper[event].listeners.add(callback);\n  }\n}\n\nmodule.exports = SocketIO;\n"],"sourceRoot":""}