{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kuzzle.js","webpack:///webpack/bootstrap d2654b12cf08324a5af1","webpack:///./src/Kuzzle.js","webpack:///./src/eventEmitter/index.js","webpack:///./src/security/SecurityDocument.js","webpack:///./src/networkWrapper/protocols/abstract/realtime.js","webpack:///./src/Document.js","webpack:///./src/security/User.js","webpack:///./src/Room.js","webpack:///./src/networkWrapper/protocols/socketio.js","webpack:///./src/networkWrapper/protocols/websocket.js","webpack:///./src/Collection.js","webpack:///./src/CollectionMapping.js","webpack:///./src/MemoryStorage.js","webpack:///./src/SearchResult.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/security/Profile.js","webpack:///./src/security/Role.js","webpack:///./src/security/Security.js","webpack:///./~/uuid/lib/bytesToUuid.js","webpack:///./~/uuid/lib/rng-browser.js","webpack:///./~/uuid/v4.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","checkPropertyType","prop","typestr","wrongType","Array","isArray","_typeof","Error","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","uuidv4","KuzzleEventEmitter","Collection","Document","Security","MemoryStorage","User","networkWrapper","Kuzzle","_KuzzleEventEmitter","host","options","cb","_this","connectCB","eventActions","autoResubscribe","defaultIndex","jwt","protocol","sdkVersion","volatile","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","keys","next","done","opt","hasOwnProperty","err","return","room","opts","subscribeCB","_this2","requestId","controller","action","index","collection","body","filters","scope","state","users","notificationCB","data","type","unsetJwt","emit","copy","assign","document","result","_id","_source","_meta","notify","network","subscribe","unsubscribeCB","roomId","unsubscribe","channel","errorMessagePrefix","callback","eventTimeout","connected","timeout","error","disconnected","reconnected","tokenExpired","loginAttempt","autoQueue","set","autoReconnect","autoReplay","offlineQueue","offlineQueueLoader","port","queueFilter","queueMaxSize","queueTTL","replayInterval","reconnectionDelay","sslConnection","eumerable","ssl","addListener","query","connect","bluebird","_ret","promisifyAll","suffix","filter","name","func","passes","whitelist","indexOf","eventName","_get2","now","Date","protectedEvent","protectedEvents","lastEmitted","_len","arguments","payload","_key","apply","concat","_this3","connectionError","internal","disconnect","checkToken","res","valid","on","token","success","JSON","stringify","strategy","_this4","request","expiresIn","queuable","response","message","setJwt","credentials","_this5","callbackRequired","_this6","security","hits","content","event","listener","toString","timestamp","queryCB","startTime","collections","flushQueue","_len2","args","_key2","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","arg","indexes","close","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","serverInfo","_len3","_key3","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","_len4","_key4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","autoRefresh","_len5","_key5","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","queryArgs","_arr","_i","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","attr","startQueuing","stopQueuing","playQueue","Listener","fn","once","_events","listeners","Boolean","find","map","listenerType","_exists","push","addOnceListener","prependListener","findIndex","l","splice","onceListeners","toDelete","removeListener","SecurityDocument","meta","kuzzle","setContent","serialize","delete","buildQueryArgs","deleteActionName","update","updateActionName","emitRequest","status","requestHistory","send","discardRequest","cleanQueue","lastDocumentIndex","forEach","ts","droppedRequest","dequeue","uniqueQueue","dequeuingProcess","shift","setTimeout","Math","max","additionalQueue","cleanHistory","RTWrapper","cleanHistoryTimer","queuing","offlineMode","wasConnected","stopRetryingToConnect","retrying","setInterval","clearHistoryTimer","fromSelf","removeAllListeners","clearInterval","documentId","dataCollection","version","_version","exists","refresh","newDocument","save","publish","replace","ids","values","KuzzleSecurityDocument","setProfiles","profileIds","setCredentials","addProfile","profileId","creationSerialize","saveRestricted","getProfileIds","getProfiles","fetchedProfiles","errored","fetchProfile","profile","Room","_roomId","roomstate","isListening","resubscribe","deactivate","resubscribeConditional","subscribeToSelf","count","onDone","SocketIO","_RTWrapper","socket","forceDisconnect","eventsWrapper","window","io","reconnection","forceNew","clientConnected","clientNetworkError","clientDisconnected","_addEventWrapper","size","off","wrapper","_event","Set","add","WebSocketClient","WSNode","WebSocket","e","code","client","lasturl","url","perMessageDeflate","onopen","onclose","closeEvent","reason","onerror","onmessage","parse","readyState","OPEN","blacklist","KuzzleSearchResult","CollectionMapping","createDocument","ifExist","doc","deleteDocument","deleteSpecifications","documentExists","fetchDocument","getMapping","kuzzleMapping","mCreateDocument","documents","mCreateOrReplaceDocument","mDeleteDocument","documentIds","mGetDocument","mReplaceDocument","mUpdateDocument","getSpecifications","publishMessage","replaceDocument","search","_scroll_id","scrollId","total","aggregations","previous","scroll","scrollSpecifications","searchSpecifications","evtName","truncate","updateDocument","retryOnConflict","updateSpecifications","specifications","validateSpecifications","collectionMapping","mapping","properties","mappings","field","assignParameter","assignGeoRadiusOptions","parsed","assignZrangeOptions","limit","mapGeoposResults","results","coords","latlon","parseFloat","mapGeoRadiusResults","point","coordinates","coord","distance","mapStringToArray","mapArrayStringToArrayInt","parseInt","mapNoResult","mapZrangeResults","buffer","mapped","member","score","mapScanResults","cursor","getId","required","getIdField","getKeys","getMember","getxScan","mapResults","getZrange","getZrangeBy","setId","setIdValue","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","geoadd","geodist","geohash","geopos","georadius","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","setex","setnx","sinter","sinterstore","sismember","smembers","smove","sort","spop","srandmember","srem","sscan","strlen","sunion","sunionstore","time","touch","ttl","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","command","slice","pop","param","SearchResult","fetchedDocument","fetchNext","getTotal","from","search_after","sortRule","getDocuments","getAggregations","getOptions","getFilters","getCollection","getFetchedDocument","Profile","policies","addPolicy","policy","roleId","setPolicies","getPolicies","Role","fetchRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","role","searchProfiles","profiles","createProfile","updateProfile","updatedContent","deleteProfile","scrollProfiles","newProfile","fetchUser","searchUsers","createUser","replaceUser","createRestrictedUser","updateUser","deleteUser","scrollUsers","user","newUser","isActionAllowed","rights","filteredRights","right","some","item","getUserRights","userId","createCredentials","kuid","deleteCredentials","getAllCredentialFields","getCredentialFields","getCredentials","hasCredentials","updateCredentials","validateCredentials","bytesToUuid","buf","offset","bth","byteToHex","substr","rng","crypto","msCrypto","getRandomValues","rnds8","Uint8Array","rnds","r","random","v4","ii"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! Kuzzle javascript SDK version 5.0.10 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar uuidv4 = __webpack_require__(19),\n\t    KuzzleEventEmitter = __webpack_require__(1),\n\t    Collection = __webpack_require__(9),\n\t    Document = __webpack_require__(4),\n\t    Security = __webpack_require__(16),\n\t    MemoryStorage = __webpack_require__(11),\n\t    User = __webpack_require__(5),\n\t    networkWrapper = __webpack_require__(13);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle object constructor.\n\t *\n\t * @constructor\n\t * @param host - Server name or IP Address to the Kuzzle instance\n\t * @param [options] - Connection options\n\t * @param {responseCallback} [cb] - Handles connection response\n\t */\n\t\n\tvar Kuzzle = function (_KuzzleEventEmitter) {\n\t  _inherits(Kuzzle, _KuzzleEventEmitter);\n\t\n\t  function Kuzzle(host, options, cb) {\n\t    _classCallCheck(this, Kuzzle);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Kuzzle.__proto__ || Object.getPrototypeOf(Kuzzle)).call(this));\n\t\n\t    if (!cb && typeof options === 'function') {\n\t      cb = options;\n\t      options = null;\n\t    }\n\t\n\t    if (!host || host === '') {\n\t      throw new Error('host argument missing');\n\t    }\n\t\n\t    Object.defineProperties(_this, {\n\t      // 'private' properties\n\t      connectCB: {\n\t        value: cb\n\t      },\n\t      eventActions: {\n\t        value: ['connected', 'discarded', 'disconnected', 'loginAttempt', 'networkError', 'offlineQueuePush', 'offlineQueuePop', 'queryError', 'reconnected', 'tokenExpired']\n\t      },\n\t      // configuration properties\n\t      autoResubscribe: {\n\t        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n\t        enumerable: true\n\t      },\n\t      defaultIndex: {\n\t        value: options && typeof options.defaultIndex === 'string' ? options.defaultIndex : undefined,\n\t        writable: true,\n\t        enumerable: true\n\t      },\n\t      jwt: {\n\t        value: undefined,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      protocol: {\n\t        value: options && typeof options.protocol === 'string' ? options.protocol : 'websocket',\n\t        enumerable: true\n\t      },\n\t      sdkVersion: {\n\t        value:  false ? require('../package.json').version : (\"5.0.10\")\n\t      },\n\t      volatile: {\n\t        value: {},\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    if (options) {\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = Object.keys(options)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var opt = _step.value;\n\t\n\t          if (_this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(_this, opt).writable) {\n\t            _this[opt] = options[opt];\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Forward the subscribe query to the network wrapper\n\t    Object.defineProperty(_this, 'subscribe', {\n\t      value: function value(room, opts, subscribeCB) {\n\t        var _this2 = this;\n\t\n\t        var object = {\n\t          requestId: uuidv4(),\n\t          controller: 'realtime',\n\t          action: 'subscribe',\n\t          index: room.collection.index,\n\t          collection: room.collection.collection,\n\t          volatile: this.volatile,\n\t          body: room.filters,\n\t          scope: room.scope,\n\t          state: room.state,\n\t          users: room.users\n\t        },\n\t            notificationCB = function notificationCB(data) {\n\t          if (data.type === 'TokenExpired') {\n\t            _this2.unsetJwt();\n\t            return _this2.emit('tokenExpired');\n\t          }\n\t\n\t          if (data.type === 'document') {\n\t            var copy = Object.assign({}, data);\n\t            copy.document = new Document(room.collection, data.result._id, data.result._source, data.result._meta);\n\t            delete copy.result;\n\t            return room.notify(copy);\n\t          }\n\t\n\t          room.notify(data);\n\t        };\n\t\n\t        if (this.jwt !== undefined) {\n\t          object.jwt = this.jwt;\n\t        }\n\t\n\t        Object.assign(object.volatile, room.volatile, { sdkVersion: this.sdkVersion });\n\t\n\t        this.network.subscribe(object, opts, notificationCB, subscribeCB);\n\t      }\n\t    });\n\t\n\t    // Forward the unsubscribe query to the network wrapper\n\t    Object.defineProperty(_this, 'unsubscribe', {\n\t      value: function value(room, unsubscribeCB) {\n\t        var object = {\n\t          requestId: uuidv4(),\n\t          controller: 'realtime',\n\t          action: 'unsubscribe',\n\t          volatile: _this.volatile,\n\t          body: { roomId: room.roomId }\n\t        };\n\t\n\t        if (_this.jwt !== undefined) {\n\t          object.jwt = _this.jwt;\n\t        }\n\t\n\t        Object.assign(object.volatile, room.volatile, { sdkVersion: _this.sdkVersion });\n\t\n\t        _this.network.unsubscribe(object, room.channel, unsubscribeCB);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n\t     * and is called by these methods\n\t     */\n\t    Object.defineProperty(_this, 'callbackRequired', {\n\t      value: function value(errorMessagePrefix, callback) {\n\t        if (!callback || typeof callback !== 'function') {\n\t          throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n\t        }\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Create an attribute security that embed all methods to manage Role, Profile and User\n\t     */\n\t    Object.defineProperty(_this, 'security', {\n\t      value: new Security(_this),\n\t      enumerable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'memoryStorage', {\n\t      value: new MemoryStorage(_this),\n\t      enumerable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'collections', {\n\t      value: {},\n\t      writable: true\n\t    });\n\t\n\t    Object.defineProperty(_this, 'eventTimeout', {\n\t      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n\t    });\n\t\n\t    Object.defineProperty(_this, 'protectedEvents', {\n\t      value: {\n\t        connected: { timeout: _this.eventTimeout },\n\t        error: { timeout: _this.eventTimeout },\n\t        disconnected: { timeout: _this.eventTimeout },\n\t        reconnected: { timeout: _this.eventTimeout },\n\t        tokenExpired: { timeout: _this.eventTimeout },\n\t        loginAttempt: { timeout: _this.eventTimeout }\n\t      }\n\t    });\n\t\n\t    _this.network = networkWrapper(_this.protocol, host, options);\n\t\n\t    // Properties related to the network layer\n\t    // Accessing a property irrelevant for a given protocol\n\t    // (e.g. \"autoReconnect\" for the HTTP layer) should\n\t    // throw an exception\n\t    Object.defineProperties(_this, {\n\t      autoQueue: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoQueue;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('autoQueue', 'boolean', value);\n\t          _this.network.autoQueue = value;\n\t        }\n\t      },\n\t      autoReconnect: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoReconnect;\n\t        }\n\t      },\n\t      autoReplay: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.autoReplay;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('autoReplay', 'boolean', value);\n\t          _this.network.autoReplay = value;\n\t        }\n\t      },\n\t      host: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.host;\n\t        }\n\t      },\n\t      offlineQueue: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.offlineQueue;\n\t        }\n\t      },\n\t      offlineQueueLoader: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.offlineQueueLoader;\n\t        },\n\t        set: function set(value) {\n\t          if (value !== null) {\n\t            checkPropertyType('offlineQueueLoader', 'function', value);\n\t          }\n\t          _this.network.offlineQueueLoader = value;\n\t        }\n\t      },\n\t      port: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.port;\n\t        }\n\t      },\n\t      queueFilter: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueFilter;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueFilter', 'function', value);\n\t          _this.network.queueFilter = value;\n\t        }\n\t      },\n\t      queueMaxSize: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueMaxSize;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueMaxSize', 'number', value);\n\t          _this.network.queueMaxSize = value;\n\t        }\n\t      },\n\t      queueTTL: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.queueTTL;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('queueTTL', 'number', value);\n\t          _this.network.queueTTL = value;\n\t        }\n\t      },\n\t      replayInterval: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.replayInterval;\n\t        },\n\t        set: function set(value) {\n\t          checkPropertyType('replayInterval', 'number', value);\n\t          _this.network.replayInterval = value;\n\t        }\n\t      },\n\t      reconnectionDelay: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _this.network.reconnectionDelay;\n\t        }\n\t      },\n\t      sslConnection: {\n\t        eumerable: true,\n\t        get: function get() {\n\t          return _this.network.ssl;\n\t        }\n\t      }\n\t    });\n\t\n\t    _this.network.addListener('offlineQueuePush', function (data) {\n\t      return _this.emit('offlineQueuePush', data);\n\t    });\n\t    _this.network.addListener('offlineQueuePop', function (data) {\n\t      return _this.emit('offlineQueuePop', data);\n\t    });\n\t    _this.network.addListener('queryError', function (err, query) {\n\t      return _this.emit('queryError', err, query);\n\t    });\n\t\n\t    _this.network.addListener('tokenExpired', function () {\n\t      _this.unsetJwt();\n\t      _this.emit('tokenExpired');\n\t    });\n\t\n\t    if ((options && options.connect || 'auto') === 'auto') {\n\t      _this.connect();\n\t    }\n\t\n\t    if (_this.bluebird) {\n\t      var _ret;\n\t\n\t      return _ret = _this.bluebird.promisifyAll(_this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics', 'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query', 'checkToken', 'whoAmI', 'updateSelf', 'getMyRights', 'getMyCredentials', 'createMyCredentials', 'deleteMyCredentials', 'updateMyCredentials', 'validateMyCredentials', 'createIndex', 'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'];\n\t\n\t          return passes && whitelist.indexOf(name) !== -1;\n\t        }\n\t      }), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t  * Emit an event to all registered listeners\n\t  * An event cannot be emitted multiple times before a timeout has been reached.\n\t  */\n\t\n\t\n\t  _createClass(Kuzzle, [{\n\t    key: 'emit',\n\t    value: function emit(eventName) {\n\t      var _get2;\n\t\n\t      var now = Date.now(),\n\t          protectedEvent = this.protectedEvents[eventName];\n\t\n\t      if (protectedEvent) {\n\t        if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n\t          return false;\n\t        }\n\t        protectedEvent.lastEmitted = now;\n\t      }\n\t\n\t      for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        payload[_key - 1] = arguments[_key];\n\t      }\n\t\n\t      (_get2 = _get(Kuzzle.prototype.__proto__ || Object.getPrototypeOf(Kuzzle.prototype), 'emit', this)).call.apply(_get2, [this, eventName].concat(payload));\n\t    }\n\t\n\t    /**\n\t     * Connects to a Kuzzle instance using the provided host name.\n\t     * @returns {Object} this\n\t     */\n\t\n\t  }, {\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this3 = this;\n\t\n\t      if (this.network.state !== 'offline') {\n\t        if (this.connectCB) {\n\t          this.connectCB(null, this);\n\t        }\n\t        return this;\n\t      }\n\t\n\t      this.network.connect();\n\t\n\t      this.network.addListener('connect', function () {\n\t        _this3.emit('connected');\n\t\n\t        if (_this3.connectCB) {\n\t          _this3.connectCB(null, _this3);\n\t        }\n\t      });\n\t\n\t      this.network.addListener('networkError', function (error) {\n\t        var connectionError = new Error('Unable to connect to kuzzle proxy server at ' + _this3.network.host + ':' + _this3.network.port);\n\t\n\t        connectionError.internal = error;\n\t        _this3.emit('networkError', connectionError);\n\t\n\t        if (_this3.connectCB) {\n\t          _this3.connectCB(connectionError);\n\t        }\n\t      });\n\t\n\t      this.network.addListener('disconnect', function () {\n\t        _this3.disconnect();\n\t        _this3.emit('disconnected');\n\t      });\n\t\n\t      this.network.addListener('reconnect', function () {\n\t        if (_this3.jwt) {\n\t          _this3.checkToken(_this3.jwt, function (err, res) {\n\t            // shouldn't obtain an error but let's invalidate the token anyway\n\t            if (err || !res.valid) {\n\t              _this3.unsetJwt();\n\t            }\n\t\n\t            _this3.emit('reconnected');\n\t          });\n\t        } else {\n\t          _this3.emit('reconnected');\n\t        }\n\t      });\n\t\n\t      this.network.on('discarded', function (data) {\n\t        return _this3.emit('discarded', data);\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Set the jwt used to query kuzzle\n\t     * @param token\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'setJwt',\n\t    value: function setJwt(token) {\n\t      if (typeof token === 'string') {\n\t        this.jwt = token;\n\t      } else if ((typeof token === 'undefined' ? 'undefined' : _typeof(token)) === 'object') {\n\t        if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n\t          this.jwt = token.result.jwt;\n\t        } else {\n\t          this.emit('loginAttempt', {\n\t            success: false,\n\t            error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n\t          });\n\t\n\t          return this;\n\t        }\n\t      } else {\n\t        this.emit('loginAttempt', { success: false, error: 'Invalid token argument: ' + token });\n\t        return this;\n\t      }\n\t\n\t      this.emit('loginAttempt', { success: true });\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unset the jwt used to query kuzzle\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'unsetJwt',\n\t    value: function unsetJwt() {\n\t      this.jwt = undefined;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Get the jwt used by kuzzle\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'getJwt',\n\t    value: function getJwt() {\n\t      return this.jwt;\n\t    }\n\t\n\t    /**\n\t     * Send login request to kuzzle with credentials\n\t     * If login success, store the jwt into kuzzle object\n\t     *\n\t     * @param strategy\n\t     * @param credentials\n\t     * @param expiresIn\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'login',\n\t    value: function login(strategy) {\n\t      var _this4 = this;\n\t\n\t      if (!strategy || typeof strategy !== 'string') {\n\t        throw new Error('Kuzzle.login: strategy required');\n\t      }\n\t\n\t      var request = {\n\t        strategy: strategy,\n\t        body: {}\n\t      };\n\t\n\t      var cb = null;\n\t\n\t      // Handle arguments (credentials, expiresIn, cb)\n\t      if (arguments.length <= 1 ? undefined : arguments[1]) {\n\t        if (_typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object') {\n\t          request.body = arguments.length <= 1 ? undefined : arguments[1];\n\t        } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'number' || typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'string') {\n\t          request.expiresIn = arguments.length <= 1 ? undefined : arguments[1];\n\t        } else if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === 'function') {\n\t          cb = arguments.length <= 1 ? undefined : arguments[1];\n\t        }\n\t      }\n\t      if (arguments.length <= 2 ? undefined : arguments[2]) {\n\t        if (typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'number' || typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'string') {\n\t          request.expiresIn = arguments.length <= 2 ? undefined : arguments[2];\n\t        } else if (typeof (arguments.length <= 2 ? undefined : arguments[2]) === 'function') {\n\t          cb = arguments.length <= 2 ? undefined : arguments[2];\n\t        }\n\t      }\n\t      if ((arguments.length <= 3 ? undefined : arguments[3]) && typeof (arguments.length <= 3 ? undefined : arguments[3]) === 'function') {\n\t        cb = arguments.length <= 3 ? undefined : arguments[3];\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'login' }, request, { queuable: false }, function (error, response) {\n\t        if (!error) {\n\t          if (response.result.jwt) {\n\t            _this4.setJwt(response.result.jwt);\n\t          }\n\t\n\t          cb && cb(null, response.result);\n\t        } else {\n\t          cb && cb(error);\n\t          _this4.emit('loginAttempt', { success: false, error: error.message });\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param credentials\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'createMyCredentials',\n\t    value: function createMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'createMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result._source);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Delete credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'deleteMyCredentials',\n\t    value: function deleteMyCredentials(strategy, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'deleteMyCredentials' }, { strategy: strategy }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Get credential information of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param options\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'getMyCredentials',\n\t    value: function getMyCredentials(strategy, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'getMyCredentials' }, { strategy: strategy }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Update credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param credentals\n\t     * @param options\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'updateMyCredentials',\n\t    value: function updateMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'updateMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Validate credentials of the specified <strategy> for the current user.\n\t     *\n\t     * @param strategy\n\t     * @param credentials\n\t     * @param options\n\t     * @param cb\n\t     */\n\t\n\t  }, {\n\t    key: 'validateMyCredentials',\n\t    value: function validateMyCredentials(strategy, credentials, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'validateMyCredentials' }, { strategy: strategy, body: credentials }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create a kuzzle index\n\t     *\n\t     * @param {string} index\n\t     * @param {object} [options]\n\t     * @param {responseCallback} cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'createIndex',\n\t    value: function createIndex(index, options, cb) {\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.createIndex: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'index', action: 'create', index: index }, {}, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Send logout request to kuzzle with jwt.\n\t     *\n\t     * @param cb\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'logout',\n\t    value: function logout(cb) {\n\t      var _this5 = this;\n\t\n\t      var request = {\n\t        action: 'logout',\n\t        controller: 'auth',\n\t        requestId: uuidv4(),\n\t        body: {}\n\t      };\n\t\n\t      this.query({ controller: 'auth', action: 'logout' }, request, { queuable: false }, function (error) {\n\t        if (typeof cb === 'function') {\n\t          cb(error, _this5);\n\t        }\n\t      });\n\t\n\t      return this.unsetJwt();\n\t    }\n\t\n\t    /**\n\t     * Checks whether a given jwt token still represents a valid session in Kuzzle.\n\t     *\n\t     * @param  {string}   token     The jwt token to check\n\t     * @param  {function} cb  The callback to be called when the response is\n\t     *                              available. The signature is `function(error, response)`.\n\t     */\n\t\n\t  }, {\n\t    key: 'checkToken',\n\t    value: function checkToken(token, cb) {\n\t      var request = {\n\t        body: {\n\t          token: token\n\t        }\n\t      };\n\t\n\t      this.callbackRequired('Kuzzle.checkToken', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'checkToken' }, request, { queuable: false }, function (err, res) {\n\t        cb(err, err ? undefined : res.result);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Fetches the current user.\n\t     *\n\t     * @param  {function} cb  The callback to be called when the response is\n\t     *                              available. The signature is `function(error, response)`.\n\t     */\n\t\n\t  }, {\n\t    key: 'whoAmI',\n\t    value: function whoAmI(cb) {\n\t      var _this6 = this;\n\t\n\t      this.callbackRequired('Kuzzle.whoAmI', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'getCurrentUser' }, {}, {}, function (err, res) {\n\t        cb(err, err ? undefined : new User(_this6.security, res.result._id, res.result._source, res.result._meta));\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets the rights array of the currently logged user.\n\t     *\n\t     * @param {object} [options] - Optional parameters\n\t     * @param  {function} cb The callback containing the normalized array of rights.\n\t     */\n\t\n\t  }, {\n\t    key: 'getMyRights',\n\t    value: function getMyRights(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getMyRights', cb);\n\t\n\t      this.query({ controller: 'auth', action: 'getMyRights' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.hits);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Update current user in Kuzzle.\n\t     *\n\t     * @param {object} content - a plain javascript object representing the user's modification\n\t     * @param {object} [options] - (optional) arguments\n\t     * @param {responseCallback} [cb] - (optional) Handles the query response\n\t     * @returns {Kuzzle} this object\n\t     */\n\t\n\t  }, {\n\t    key: 'updateSelf',\n\t    value: function updateSelf(content, options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.query({ controller: 'auth', action: 'updateSelf' }, { body: content }, options, function (err, res) {\n\t        if (typeof cb === 'function') {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n\t     * insertion.\n\t     *\n\t     * @param {string} event - name of the global event to subscribe to\n\t     * @param {function} listener - callback to invoke each time an event is fired\n\t     */\n\t\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(event, listener) {\n\t      if (this.eventActions.indexOf(event) === -1) {\n\t        throw new Error('[' + event + '] is not a known event. Known events: ' + this.eventActions.toString());\n\t      }\n\t\n\t      return _get(Kuzzle.prototype.__proto__ || Object.getPrototypeOf(Kuzzle.prototype), 'addListener', this).call(this, event, listener);\n\t    }\n\t\n\t    /**\n\t     * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t     * This method returns all available statistics from Kuzzle.\n\t     *\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getAllStatistics',\n\t    value: function getAllStatistics(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\t\n\t      this.query({ controller: 'server', action: 'getAllStats' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.hits);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t     * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n\t     *\n\t     * @param {number} [timestamp] -  Epoch time. Starting time from which the frames are to be retrieved\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getStatistics',\n\t    value: function getStatistics(timestamp, options, cb) {\n\t      if (!cb) {\n\t        if (!options) {\n\t          cb = timestamp;\n\t          options = null;\n\t          timestamp = null;\n\t        } else {\n\t          cb = options;\n\t          if ((typeof timestamp === 'undefined' ? 'undefined' : _typeof(timestamp)) === 'object') {\n\t            options = timestamp;\n\t            timestamp = null;\n\t          } else {\n\t            options = null;\n\t          }\n\t        }\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getStatistics', cb);\n\t\n\t      var queryCB = function queryCB(err, res) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t\n\t        cb(null, timestamp ? res.result.hits : [res.result]);\n\t      },\n\t          body = timestamp ? { body: { startTime: timestamp } } : {};\n\t\n\t      this.query({ controller: 'server', action: timestamp ? 'getStats' : 'getLastStats' }, body, options, queryCB);\n\t    }\n\t\n\t    /**\n\t     * Create a new instance of a Collection object.\n\t     * If no index is specified, takes the default index.\n\t     *\n\t     * @param {string} collection - The name of the data collection you want to manipulate\n\t     * @param {string} [index] - The name of the data index containing the data collection\n\t     * @returns {Collection} A Collection instance\n\t     */\n\t\n\t  }, {\n\t    key: 'collection',\n\t    value: function collection(_collection, index) {\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Unable to create a new data collection object: no index specified');\n\t        }\n\t\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (typeof index !== 'string' || typeof _collection !== 'string') {\n\t        throw new Error('Invalid index or collection argument: string expected');\n\t      }\n\t\n\t      if (!this.collections[index]) {\n\t        this.collections[index] = {};\n\t      }\n\t\n\t      if (!this.collections[index][_collection]) {\n\t        this.collections[index][_collection] = new Collection(this, _collection, index);\n\t      }\n\t\n\t      return this.collections[index][_collection];\n\t    }\n\t\n\t    /**\n\t     * Empties the offline queue without replaying it.\n\t     *\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'flushQueue',\n\t    value: function flushQueue() {\n\t      this.network.flushQueue();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Returns the list of known persisted data collections.\n\t     *\n\t     * @param {string} [index] - Index containing collections to be listed\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'listCollections',\n\t    value: function listCollections() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t        args[_key2] = arguments[_key2];\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var arg = _step2.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.listCollections: index required');\n\t        }\n\t\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.listCollections', cb);\n\t\n\t      var query = { type: options && options.type || 'all' };\n\t\n\t      this.query({ index: index, controller: 'collection', action: 'list' }, query, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.collections);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Returns the list of existing indexes in Kuzzle\n\t     *\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'listIndexes',\n\t    value: function listIndexes(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.listIndexes', cb);\n\t\n\t      this.query({ controller: 'index', action: 'list' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.indexes);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Disconnects from Kuzzle and invalidate this instance.\n\t     */\n\t\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this.network.close();\n\t\n\t      var _iteratorNormalCompletion3 = true;\n\t      var _didIteratorError3 = false;\n\t      var _iteratorError3 = undefined;\n\t\n\t      try {\n\t        for (var _iterator3 = Object.keys(this.collections)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t          var collection = _step3.value;\n\t\n\t          delete this.collections[collection];\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t            _iterator3.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError3) {\n\t            throw _iteratorError3;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Returns the server informations\n\t     *\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getServerInfo',\n\t    value: function getServerInfo(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getServerInfo', cb);\n\t\n\t      this.query({ controller: 'server', action: 'info' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.serverInfo);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Forces an index refresh\n\t     *\n\t     * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n\t     * @param {object} options - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     * @returns {Kuzzle}\n\t     */\n\t\n\t  }, {\n\t    key: 'refreshIndex',\n\t    value: function refreshIndex() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n\t        args[_key3] = arguments[_key3];\n\t      }\n\t\n\t      var _iteratorNormalCompletion4 = true;\n\t      var _didIteratorError4 = false;\n\t      var _iteratorError4 = undefined;\n\t\n\t      try {\n\t        for (var _iterator4 = args[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t          var arg = _step4.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError4 = true;\n\t        _iteratorError4 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t            _iterator4.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError4) {\n\t            throw _iteratorError4;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.refreshIndex: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.query({ index: index, controller: 'index', action: 'refresh' }, {}, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Returns de current autoRefresh status for the given index\n\t     *\n\t     * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n\t     * @param {object} options - Optinal arguments\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'getAutoRefresh',\n\t    value: function getAutoRefresh() {\n\t      var index = void 0,\n\t          options = void 0,\n\t          cb = void 0;\n\t\n\t      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n\t        args[_key4] = arguments[_key4];\n\t      }\n\t\n\t      var _iteratorNormalCompletion5 = true;\n\t      var _didIteratorError5 = false;\n\t      var _iteratorError5 = undefined;\n\t\n\t      try {\n\t        for (var _iterator5 = args[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t          var arg = _step5.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError5 = true;\n\t        _iteratorError5 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t            _iterator5.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError5) {\n\t            throw _iteratorError5;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.getAutoRefresh: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n\t      this.query({ index: index, controller: 'index', action: 'getAutoRefresh' }, {}, options, cb);\n\t    }\n\t\n\t    /**\n\t     * (Un)Sets the autoRefresh flag on the given index\n\t     *\n\t     * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n\t     * @param {boolean} autoRefresh - The autoRefresh value to set\n\t     * @param {object} options - Optional arguments\n\t     * @param {responseCallback} cb - Handles the query result\n\t     * @returns {object} this\n\t     */\n\t\n\t  }, {\n\t    key: 'setAutoRefresh',\n\t    value: function setAutoRefresh() {\n\t      var index, autoRefresh, options, cb;\n\t\n\t      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n\t        args[_key5] = arguments[_key5];\n\t      }\n\t\n\t      var _iteratorNormalCompletion6 = true;\n\t      var _didIteratorError6 = false;\n\t      var _iteratorError6 = undefined;\n\t\n\t      try {\n\t        for (var _iterator6 = args[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n\t          var arg = _step6.value;\n\t\n\t          switch (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) {\n\t            case 'string':\n\t              index = arg;\n\t              break;\n\t            case 'boolean':\n\t              autoRefresh = arg;\n\t              break;\n\t            case 'object':\n\t              options = arg;\n\t              break;\n\t            case 'function':\n\t              cb = arg;\n\t              break;\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError6 = true;\n\t        _iteratorError6 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n\t            _iterator6.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError6) {\n\t            throw _iteratorError6;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (!index) {\n\t        if (!this.defaultIndex) {\n\t          throw new Error('Kuzzle.setAutoRefresh: index required');\n\t        }\n\t        index = this.defaultIndex;\n\t      }\n\t\n\t      if (autoRefresh === undefined) {\n\t        throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n\t      }\n\t\n\t      this.query({ index: index, controller: 'index', action: 'setAutoRefresh' }, { body: { autoRefresh: autoRefresh } }, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Return the current Kuzzle's UTC Epoch time, in milliseconds\n\t     * @param {object} [options] - Optional parameters\n\t     * @param {responseCallback} cb - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'now',\n\t    value: function now(options, cb) {\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      this.callbackRequired('Kuzzle.now', cb);\n\t\n\t      this.query({ controller: 'server', action: 'now' }, {}, options, function (err, res) {\n\t        cb(err, err ? undefined : res.result.now);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n\t     * Base method used to send read queries to Kuzzle\n\t     *\n\t     * Takes an optional argument object with the following properties:\n\t     *    - volatile (object, default: null):\n\t     *        Additional information passed to notifications to other users\n\t     *\n\t     * @param {object} queryArgs - Query configuration\n\t     * @param {object} query - The query data\n\t     * @param {object} [options] - Optional arguments\n\t     * @param {responseCallback} [cb] - Handles the query response\n\t     */\n\t\n\t  }, {\n\t    key: 'query',\n\t    value: function query(queryArgs, _query, options, cb) {\n\t      var object = {\n\t        action: queryArgs.action,\n\t        controller: queryArgs.controller,\n\t        volatile: this.volatile\n\t      };\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      } else if (!cb && !options && typeof _query === 'function') {\n\t        cb = _query;\n\t        _query = {};\n\t        options = null;\n\t      }\n\t\n\t      if (options) {\n\t        var _arr = ['refresh', 'from', 'size', 'scroll', 'scrollId'];\n\t\n\t        for (var _i = 0; _i < _arr.length; _i++) {\n\t          var prop = _arr[_i];\n\t          if (options[prop] !== undefined) {\n\t            object[prop] = options[prop];\n\t          }\n\t        }\n\t\n\t        if (options.volatile && _typeof(options.volatile) === 'object') {\n\t          Object.assign(object.volatile, options.volatile);\n\t        }\n\t      }\n\t\n\t      if (!_query || (typeof _query === 'undefined' ? 'undefined' : _typeof(_query)) !== 'object' || Array.isArray(_query)) {\n\t        throw new Error('Invalid query parameter: ' + _query);\n\t      }\n\t\n\t      Object.assign(object.volatile, _query.volatile, { sdkVersion: this.sdkVersion });\n\t\n\t      var _iteratorNormalCompletion7 = true;\n\t      var _didIteratorError7 = false;\n\t      var _iteratorError7 = undefined;\n\t\n\t      try {\n\t        for (var _iterator7 = Object.keys(_query)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n\t          var attr = _step7.value;\n\t\n\t          if (attr !== 'volatile') {\n\t            object[attr] = _query[attr];\n\t          }\n\t        }\n\t\n\t        /*\n\t         * Do not add the token for the checkToken route, to avoid getting a token error when\n\t         * a developer simply wish to verify his token\n\t         */\n\t      } catch (err) {\n\t        _didIteratorError7 = true;\n\t        _iteratorError7 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n\t            _iterator7.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError7) {\n\t            throw _iteratorError7;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this.jwt !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n\t        object.jwt = this.jwt;\n\t      }\n\t\n\t      if (queryArgs.collection) {\n\t        object.collection = queryArgs.collection;\n\t      }\n\t\n\t      if (queryArgs.index) {\n\t        object.index = queryArgs.index;\n\t      }\n\t\n\t      if (!object.requestId) {\n\t        object.requestId = uuidv4();\n\t      }\n\t\n\t      this.network.query(object, options, cb);\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Starts the requests queuing.\n\t     */\n\t\n\t  }, {\n\t    key: 'startQueuing',\n\t    value: function startQueuing() {\n\t      this.network.startQueuing();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Stops the requests queuing.\n\t     */\n\t\n\t  }, {\n\t    key: 'stopQueuing',\n\t    value: function stopQueuing() {\n\t      this.network.stopQueuing();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * @DEPRECATED\n\t     * See Kuzzle.prototype.playQueue();\n\t     */\n\t\n\t  }, {\n\t    key: 'replayQueue',\n\t    value: function replayQueue() {\n\t      return this.playQueue();\n\t    }\n\t\n\t    /**\n\t     * Plays the requests queued during offline mode.\n\t     */\n\t\n\t  }, {\n\t    key: 'playQueue',\n\t    value: function playQueue() {\n\t      this.network.playQueue();\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Sets the default Kuzzle index\n\t     *\n\t     * @param index\n\t     * @returns this\n\t     */\n\t\n\t  }, {\n\t    key: 'setDefaultIndex',\n\t    value: function setDefaultIndex(index) {\n\t      if (typeof index !== 'string') {\n\t        throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n\t      }\n\t\n\t      if (index.length === 0) {\n\t        throw new Error('Cannot set an empty index as the default index');\n\t      }\n\t\n\t      this.defaultIndex = index;\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Kuzzle;\n\t}(KuzzleEventEmitter);\n\t\n\tfunction checkPropertyType(prop, typestr, value) {\n\t  var wrongType = typestr === 'array' ? !Array.isArray(value) : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== typestr;\n\t\n\t  if (wrongType) {\n\t    throw new Error('Can only assign a ' + typestr + ' value to property \"' + prop + '\"');\n\t  }\n\t}\n\t\n\tmodule.exports = Kuzzle;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Listener = function Listener(fn) {\n\t  var once = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t  _classCallCheck(this, Listener);\n\t\n\t  this.fn = fn;\n\t  this.once = once;\n\t};\n\t\n\tvar KuzzleEventEmitter = function () {\n\t  function KuzzleEventEmitter() {\n\t    _classCallCheck(this, KuzzleEventEmitter);\n\t\n\t    this._events = {};\n\t  }\n\t\n\t  _createClass(KuzzleEventEmitter, [{\n\t    key: '_exists',\n\t    value: function _exists(listeners, fn) {\n\t      return Boolean(listeners.find(function (listener) {\n\t        return listener.fn === fn;\n\t      }));\n\t    }\n\t  }, {\n\t    key: 'listeners',\n\t    value: function listeners(eventName) {\n\t      if (this._events[eventName] === undefined) {\n\t        return [];\n\t      }\n\t\n\t      return this._events[eventName].map(function (listener) {\n\t        return listener.fn;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(eventName, listener) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!eventName || !listener) {\n\t        return this;\n\t      }\n\t\n\t      var listenerType = typeof listener === 'undefined' ? 'undefined' : _typeof(listener);\n\t\n\t      if (listenerType !== 'function') {\n\t        throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n\t      }\n\t\n\t      if (this._events[eventName] === undefined) {\n\t        this._events[eventName] = [];\n\t      }\n\t\n\t      if (!this._exists(this._events[eventName], listener)) {\n\t        this._events[eventName].push(new Listener(listener, once));\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'on',\n\t    value: function on(eventName, listener) {\n\t      return this.addListener(eventName, listener);\n\t    }\n\t  }, {\n\t    key: 'prependListener',\n\t    value: function prependListener(eventName, listener) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!eventName || !listener) {\n\t        return this;\n\t      }\n\t\n\t      if (this._events[eventName] === undefined) {\n\t        this._events[eventName] = [];\n\t      }\n\t\n\t      if (!this._exists(this._events[eventName], listener)) {\n\t        this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'addOnceListener',\n\t    value: function addOnceListener(eventName, listener) {\n\t      return this.addListener(eventName, listener, true);\n\t    }\n\t  }, {\n\t    key: 'once',\n\t    value: function once(eventName, listener) {\n\t      return this.addOnceListener(eventName, listener);\n\t    }\n\t  }, {\n\t    key: 'prependOnceListener',\n\t    value: function prependOnceListener(eventName, listener) {\n\t      return this.prependListener(eventName, listener, true);\n\t    }\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(eventName, listener) {\n\t      var listeners = this._events[eventName];\n\t\n\t      if (!listeners || !listeners.length) {\n\t        return this;\n\t      }\n\t\n\t      var index = listeners.findIndex(function (l) {\n\t        return l.fn === listener;\n\t      });\n\t\n\t      if (index !== -1) {\n\t        listeners.splice(index, 1);\n\t      }\n\t\n\t      if (listeners.length === 0) {\n\t        delete this._events[eventName];\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'removeAllListeners',\n\t    value: function removeAllListeners(eventName) {\n\t      if (eventName) {\n\t        delete this._events[eventName];\n\t      } else {\n\t        this._events = {};\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(eventName) {\n\t      var listeners = this._events[eventName];\n\t\n\t      if (listeners === undefined) {\n\t        return false;\n\t      }\n\t\n\t      var onceListeners = [];\n\t\n\t      for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t        payload[_key - 1] = arguments[_key];\n\t      }\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var listener = _step.value;\n\t\n\t          listener.fn.apply(listener, payload);\n\t\n\t          if (listener.once) {\n\t            onceListeners.push(listener.fn);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = onceListeners[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var toDelete = _step2.value;\n\t\n\t          this.removeListener(eventName, toDelete);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t  }, {\n\t    key: 'eventNames',\n\t    value: function eventNames() {\n\t      return Object.keys(this._events);\n\t    }\n\t  }, {\n\t    key: 'listenerCount',\n\t    value: function listenerCount(eventName) {\n\t      return this._events[eventName] && this._events[eventName].length || 0;\n\t    }\n\t  }]);\n\t\n\t  return KuzzleEventEmitter;\n\t}();\n\t\n\tmodule.exports = KuzzleEventEmitter;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\tfunction SecurityDocument(Security, id, content, meta) {\n\t\n\t  if (!id) {\n\t    throw new Error('A security document must have an id');\n\t  }\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    kuzzle: {\n\t      value: Security.kuzzle\n\t    },\n\t    Security: {\n\t      value: Security\n\t    },\n\t    // read-only properties\n\t    // writable properties\n\t    id: {\n\t      value: id,\n\t      enumerable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (content) {\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'update'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {Object} data - New securityDocument content\n\t * @return {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.setContent = function (data) {\n\t  this.content = data;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a pojo\n\t *\n\t * @return {object} pojo representing this securityDocument\n\t */\n\tSecurityDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Delete the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tSecurityDocument.prototype.delete = function (options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, res.result._id);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} content - Content to add to KuzzleSecurityDocument\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {SecurityDocument} this\n\t */\n\tSecurityDocument.prototype.update = function (content, options, cb) {\n\t  var\n\t    data = {},\n\t    self = this;\n\t\n\t  if (typeof content !== 'object') {\n\t    throw new Error('Parameter \"content\" must be a object');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = self.id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.setContent(response.result._source);\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = SecurityDocument;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar KuzzleEventEmitter = __webpack_require__(1);\n\t\n\tvar RTWrapper = function (_KuzzleEventEmitter) {\n\t  _inherits(RTWrapper, _KuzzleEventEmitter);\n\t\n\t  function RTWrapper(host, options) {\n\t    _classCallCheck(this, RTWrapper);\n\t\n\t    var _this = _possibleConstructorReturn(this, (RTWrapper.__proto__ || Object.getPrototypeOf(RTWrapper)).call(this));\n\t\n\t    Object.defineProperties(_this, {\n\t      cleanHistoryTimer: {\n\t        value: null,\n\t        writable: true\n\t      },\n\t      host: {\n\t        value: host,\n\t        enumerable: true\n\t      },\n\t      port: {\n\t        value: options && typeof options.port === 'number' ? options.port : 7512,\n\t        enumerable: true\n\t      },\n\t      ssl: {\n\t        value: options && typeof options.sslConnection === 'boolean' ? options.sslConnection : false,\n\t        enumerable: true\n\t      },\n\t      queuing: {\n\t        value: false,\n\t        writable: true\n\t      },\n\t      reconnectionDelay: {\n\t        value: options && typeof options.reconnectionDelay === 'number' ? options.reconnectionDelay : 1000,\n\t        enumerable: true\n\t      },\n\t      // configuration properties\n\t      autoReconnect: {\n\t        value: options && typeof options.autoReconnect === 'boolean' ? options.autoReconnect : true,\n\t        enumerable: true\n\t      },\n\t      autoQueue: {\n\t        value: false,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      autoReplay: {\n\t        value: false,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      state: {\n\t        value: 'offline',\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      /*\n\t        Offline queue use the following format:\n\t              [\n\t                {\n\t                  ts: <query timestamp>,\n\t                  query: 'query',\n\t                  cb: callbackFunction\n\t                }\n\t              ]\n\t       */\n\t      offlineQueue: {\n\t        value: [],\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueFilter: {\n\t        value: null,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueMaxSize: {\n\t        value: 500,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      queueTTL: {\n\t        value: 120000,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      replayInterval: {\n\t        value: 10,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      offlineQueueLoader: {\n\t        value: null,\n\t        enumerable: true,\n\t        writable: true\n\t      }\n\t    });\n\t\n\t    if (options) {\n\t      Object.keys(options).forEach(function (opt) {\n\t        if (_this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(_this, opt).writable) {\n\t          _this[opt] = options[opt];\n\t        }\n\t      });\n\t\n\t      if (options.offlineMode === 'auto' && _this.autoReconnect) {\n\t        _this.autoQueue = _this.autoReplay = true;\n\t      }\n\t    }\n\t\n\t    Object.defineProperty(_this, 'requestHistory', {\n\t      value: {},\n\t      writable: true\n\t    });\n\t\n\t    _this.wasConnected = false;\n\t    _this.stopRetryingToConnect = false;\n\t    _this.retrying = false;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(RTWrapper, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      this.state = 'connecting';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is established\n\t     */\n\t\n\t  }, {\n\t    key: 'clientConnected',\n\t    value: function clientConnected() {\n\t      var _this2 = this;\n\t\n\t      this.state = 'connected';\n\t      this.emit(this.wasConnected && 'reconnect' || 'connect');\n\t      this.wasConnected = true;\n\t      this.stopRetryingToConnect = false;\n\t\n\t      if (this.autoQueue) {\n\t        this.stopQueuing();\n\t      }\n\t\n\t      if (this.autoReplay) {\n\t        this.playQueue();\n\t      }\n\t\n\t      if (!this.cleanHistoryTimer) {\n\t        this.cleanHistoryTimer = setInterval(function () {\n\t          cleanHistory(_this2.requestHistory);\n\t        }, 1000);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is closed\n\t     */\n\t\n\t  }, {\n\t    key: 'clientDisconnected',\n\t    value: function clientDisconnected() {\n\t      this.state = 'offline';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t\n\t      this.clearHistoryTimer();\n\t      this.emit('disconnect');\n\t    }\n\t\n\t    /**\n\t     * Called when the client's connection is closed with an error state\n\t     *\n\t     * @param {Error} error\n\t     */\n\t\n\t  }, {\n\t    key: 'clientNetworkError',\n\t    value: function clientNetworkError(error) {\n\t      var _this3 = this;\n\t\n\t      this.state = 'offline';\n\t      if (this.autoQueue) {\n\t        this.startQueuing();\n\t      }\n\t\n\t      this.clearHistoryTimer();\n\t\n\t      this.emit('networkError', error);\n\t      if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n\t        this.retrying = true;\n\t        setTimeout(function () {\n\t          _this3.retrying = false;\n\t          _this3.connect(_this3.host);\n\t        }, this.reconnectionDelay);\n\t      } else {\n\t        this.emit('disconnect');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Empties the offline queue without replaying it.\n\t     */\n\t\n\t  }, {\n\t    key: 'flushQueue',\n\t    value: function flushQueue() {\n\t      this.offlineQueue = [];\n\t    }\n\t\n\t    /**\n\t     * Replays the requests queued during offline mode.\n\t     */\n\t\n\t  }, {\n\t    key: 'playQueue',\n\t    value: function playQueue() {\n\t      if (this.state === 'connected') {\n\t        cleanQueue(this);\n\t        dequeue(this);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t     */\n\t\n\t  }, {\n\t    key: 'startQueuing',\n\t    value: function startQueuing() {\n\t      this.queuing = true;\n\t    }\n\t\n\t    /**\n\t     * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t     */\n\t\n\t  }, {\n\t    key: 'stopQueuing',\n\t    value: function stopQueuing() {\n\t      this.queuing = false;\n\t    }\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(object, options, notificationCB, cb) {\n\t      var _this4 = this;\n\t\n\t      if (this.state !== 'connected') {\n\t        return cb(new Error('Not Connected'));\n\t      }\n\t      this.query(object, options, function (error, response) {\n\t        if (error) {\n\t          return cb(error);\n\t        }\n\t        _this4.on(response.result.channel, function (data) {\n\t          data.fromSelf = _this4.requestHistory[data.requestId] !== undefined;\n\t          notificationCB(data);\n\t        });\n\t        cb(null, response.result);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(object, channel, cb) {\n\t      this.removeAllListeners(channel);\n\t      this.query(object, null, function (err, res) {\n\t        if (cb) {\n\t          cb(err, err ? undefined : res.result);\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'query',\n\t    value: function query(object, options, cb) {\n\t      var queuable = options && options.queuable !== false || true;\n\t\n\t      if (this.queueFilter) {\n\t        queuable = queuable && this.queueFilter(object);\n\t      }\n\t\n\t      if (this.queuing && queuable) {\n\t        cleanQueue(this, object, cb);\n\t        this.emit('offlineQueuePush', { query: object, cb: cb });\n\t        return this.offlineQueue.push({ ts: Date.now(), query: object, cb: cb });\n\t      }\n\t\n\t      if (this.state === 'connected') {\n\t        return emitRequest(this, object, cb);\n\t      }\n\t\n\t      return discardRequest(object, cb);\n\t    }\n\t  }, {\n\t    key: 'clearHistoryTimer',\n\t    value: function clearHistoryTimer() {\n\t      if (this.cleanHistoryTimer) {\n\t        clearInterval(this.cleanHistoryTimer);\n\t        this.cleanHistoryTimer = null;\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return RTWrapper;\n\t}(KuzzleEventEmitter);\n\t/**\n\t * Emit a request to Kuzzle\n\t *\n\t * @param {RTWrapper} network\n\t * @param {object} request\n\t * @param {responseCallback} [cb]\n\t */\n\t\n\t\n\tfunction emitRequest(network, request, cb) {\n\t  if (request.jwt !== undefined || cb) {\n\t    network.once(request.requestId, function (response) {\n\t      var error = null;\n\t\n\t      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n\t        network.emit('tokenExpired', request, cb);\n\t      }\n\t\n\t      if (response.error) {\n\t        error = new Error(response.error.message);\n\t        Object.assign(error, response.error);\n\t        error.status = response.status;\n\t        network.emit('queryError', error, request, cb);\n\t      }\n\t\n\t      if (cb) {\n\t        cb(error, response);\n\t      }\n\t    });\n\t  }\n\t  // Track requests made to allow Room.subscribeToSelf to work\n\t  network.requestHistory[request.requestId] = Date.now();\n\t  network.send(request);\n\t}\n\t\n\tfunction discardRequest(object, cb) {\n\t  if (cb) {\n\t    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n\t  }\n\t}\n\t\n\t/**\n\t * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n\t * @param {RTWrapper} network\n\t */\n\tfunction cleanQueue(network) {\n\t  var now = Date.now();\n\t  var lastDocumentIndex = -1;\n\t\n\t  if (network.queueTTL > 0) {\n\t    network.offlineQueue.forEach(function (query, index) {\n\t      if (query.ts < now - network.queueTTL) {\n\t        lastDocumentIndex = index;\n\t      }\n\t    });\n\t\n\t    if (lastDocumentIndex !== -1) {\n\t      network.offlineQueue.splice(0, lastDocumentIndex + 1).forEach(function (droppedRequest) {\n\t        network.emit('offlineQueuePop', droppedRequest.query);\n\t      });\n\t    }\n\t  }\n\t\n\t  if (network.queueMaxSize > 0 && network.offlineQueue.length > network.queueMaxSize) {\n\t    network.offlineQueue.splice(0, network.offlineQueue.length - network.queueMaxSize).forEach(function (droppedRequest) {\n\t      network.emit('offlineQueuePop', droppedRequest.query);\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Play all queued requests, in order.\n\t */\n\tfunction dequeue(network) {\n\t  var uniqueQueue = {},\n\t      dequeuingProcess = function dequeuingProcess() {\n\t    if (network.offlineQueue.length > 0) {\n\t      emitRequest(network, network.offlineQueue[0].query, network.offlineQueue[0].cb);\n\t      network.emit('offlineQueuePop', network.offlineQueue.shift());\n\t\n\t      setTimeout(function () {\n\t        dequeuingProcess();\n\t      }, Math.max(0, network.replayInterval));\n\t    }\n\t  };\n\t\n\t  if (network.offlineQueueLoader) {\n\t    if (typeof network.offlineQueueLoader !== 'function') {\n\t      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + _typeof(network.offlineQueueLoader));\n\t    }\n\t\n\t    var additionalQueue = network.offlineQueueLoader();\n\t    if (Array.isArray(additionalQueue)) {\n\t      network.offlineQueue = additionalQueue.concat(network.offlineQueue).filter(function (request) {\n\t        // throws if the query object does not contain required attributes\n\t        if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n\t          throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n\t        }\n\t\n\t        return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : uniqueQueue[request.query.requestId] = true;\n\t      });\n\t    } else {\n\t      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + (typeof additionalQueue === 'undefined' ? 'undefined' : _typeof(additionalQueue)));\n\t    }\n\t  }\n\t\n\t  dequeuingProcess();\n\t}\n\t\n\t/**\n\t * Clean history from requests made more than 10s ago\n\t */\n\tfunction cleanHistory(requestHistory) {\n\t  var now = Date.now();\n\t\n\t  Object.keys(requestHistory).forEach(function (key) {\n\t    if (requestHistory[key] < now - 10000) {\n\t      delete requestHistory[key];\n\t    }\n\t  });\n\t}\n\t\n\tmodule.exports = RTWrapper;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle handles documents either as realtime messages or as stored documents.\n\t * Document is the object representation of one of these documents.\n\t *\n\t * Notes:\n\t *   - this constructor may be called either with a documentId, a content, neither or both.\n\t *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n\t *\n\t *\n\t * @param {Collection} collection - an instanciated Collection object\n\t * @param {string} [documentId] - ID of an existing document\n\t * @param {object} [content] - Initializes this document with the provided content\n\t * @param {object} [meta] - Initializes this document with the provided meta\n\t * @constructor\n\t */\n\tfunction Document(collection, documentId, content, meta) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection.collection,\n\t      enumerable: true\n\t    },\n\t    dataCollection: {\n\t      value: collection,\n\t      enumerable: false\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: false\n\t    },\n\t    // writable properties\n\t    id: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    version: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    meta: {\n\t      value: meta || {},\n\t      enumerable: true,\n\t      writable: false\n\t    }\n\t  });\n\t\n\t  // handling provided arguments\n\t  if (!content && documentId && typeof documentId === 'object') {\n\t    content = documentId;\n\t    documentId = null;\n\t  }\n\t\n\t  if (content) {\n\t    if (content._version) {\n\t      this.version = content._version;\n\t      delete content._version;\n\t    }\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  if (documentId) {\n\t    Object.defineProperty(this, 'id', {\n\t      value: documentId,\n\t      enumerable: true\n\t    });\n\t  }\n\t\n\t  // promisifying\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'refresh', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this document\n\t */\n\tDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  if (this.version) {\n\t    data._version = this.version;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Overrides the toString() method in order to return a serialized version of the document\n\t *\n\t * @return {string} serialized version of this object\n\t */\n\tDocument.prototype.toString = function () {\n\t  return JSON.stringify(this.serialize());\n\t};\n\t\n\t/**\n\t * Deletes this document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.delete = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.delete: cannot delete a document without a document ID');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n\t    cb(err, err ? undefined : self.id);\n\t  });\n\t};\n\t\n\t/**\n\t * Checks if this document exists in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.exists = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replaces the current content with the last version of this document stored in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.refresh = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.refresh', cb);\n\t\n\t  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n\t    var newDocument;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n\t    newDocument.version = res.result._version;\n\t\n\t    cb(null, newDocument);\n\t  });\n\t};\n\t\n\t/**\n\t * Saves this document into Kuzzle.\n\t *\n\t * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n\t * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tDocument.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n\t    if (error) {\n\t      return cb && cb(error);\n\t    }\n\t\n\t    self.id = res.result._id;\n\t    self.version = res.result._version;\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Sends the content of this document as a realtime message.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tDocument.prototype.publish = function (options) {\n\t  var data = this.serialize();\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {object} data - New content\n\t * @param {boolean} replace - if true: replace this document content with the provided data\n\t */\n\tDocument.prototype.setContent = function (data, replace) {\n\t  var self = this;\n\t\n\t  if (replace) {\n\t    this.content = data;\n\t  }\n\t  else {\n\t    Object.keys(data).forEach(function (key) {\n\t      self.content[key] = data[key];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Listens to events concerning this document. Has no effect if the document does not have an ID\n\t * (i.e. if the document has not yet been created as a persisted document).\n\t *\n\t * @param {object} [options] - subscription options\n\t * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n\t */\n\tDocument.prototype.subscribe = function (options, cb) {\n\t  var filters;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\t\n\t  if (!this.id) {\n\t    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n\t  }\n\t\n\t  filters = { ids: { values: [this.id] } };\n\t\n\t  return this.dataCollection.subscribe(filters, options, cb);\n\t};\n\t\n\tmodule.exports = Document;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(2);\n\t\n\t/**\n\t * @param {Security} Security\n\t * @param {string} id\n\t * @param {Object} content\n\t * @constructor\n\t */\n\tfunction User(Security, id, content, meta) {\n\t  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteUser'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateUser'\n\t    },\n\t    credentials: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: User\n\t  }\n\t});\n\t\n\t/**\n\t * Set profiles in content\n\t * @param {array} profileIds - an array of profiles ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.setProfiles = function (profileIds) {\n\t  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n\t    throw new Error('Parameter \"profileIds\" must be an array of strings');\n\t  }\n\t\n\t  this.content.profileIds = profileIds;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {object} credentials\n\t */\n\tUser.prototype.setCredentials = function (credentials) {\n\t  if (typeof credentials !== 'object') {\n\t    throw new Error('Parameter \"credentials\" must be a object');\n\t  }\n\t\n\t  this.credentials = credentials;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a profile\n\t * @param {string} profileId - a profile ids string\n\t *\n\t * @returns {User} this\n\t */\n\tUser.prototype.addProfile = function (profileId) {\n\t  if (typeof profileId !== 'string') {\n\t    throw new Error('Parameter \"profileId\" must be a string');\n\t  }\n\t\n\t  if (!this.content.profileIds) {\n\t    this.content.profileIds = [];\n\t  }\n\t\n\t  if (this.content.profileIds.indexOf(profileId) === -1) {\n\t    this.content.profileIds.push(profileId);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Creates this user into Kuzzle\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.create = function (options, cb) {\n\t  var\n\t    data = this.creationSerialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Replaces the latest version of this user in Kuzzle by the current content of this object.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.replace = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (!this.content.profileIds) {\n\t    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t\n\t  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Saves this user as restricted into Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {User} this\n\t */\n\tUser.prototype.saveRestricted = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.serialize = function () {\n\t  return {_id: this.id, body: this.content, meta: this.meta};\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tUser.prototype.creationSerialize = function () {\n\t  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n\t};\n\t\n\t/**\n\t * Return the associated profiles IDs\n\t *\n\t * @return {array.<string>} the associated profiles IDs\n\t */\n\tUser.prototype.getProfileIds = function () {\n\t  return this.content.profileIds || [];\n\t};\n\t\n\t/**\n\t * Return the associated Profile objects\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tUser.prototype.getProfiles = function (options, cb) {\n\t  var \n\t    self = this,\n\t    fetchedProfiles = [],\n\t    errored = false;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\t\n\t  if (!self.content.profileIds) {\n\t    return cb(null, fetchedProfiles);\n\t  }\n\t\n\t  self.content.profileIds.forEach(function (profileId) {\n\t    self.Security.fetchProfile(profileId, options, function (error, profile) {\n\t      if (error) {\n\t        if (errored) {\n\t          return;\n\t        }\n\t\n\t        errored = true; // prevents multiple callback resolutions\n\t        return cb(error);\n\t      }\n\t\n\t      fetchedProfiles.push(profile);\n\t\n\t      if (fetchedProfiles.length === self.content.profileIds.length) {\n\t        cb(null, fetchedProfiles);\n\t      }\n\t    });\n\t  });\n\t};\n\t\n\tmodule.exports = User;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar KuzzleEventEmitter = __webpack_require__(1);\n\t\n\t/**\n\t * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n\t *\n\t * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n\t *\n\t * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n\t * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n\t * document change (because it is created, updated or deleted), then youll receive a notification about it.\n\t *\n\t */\n\t\n\tvar Room = function (_KuzzleEventEmitter) {\n\t  _inherits(Room, _KuzzleEventEmitter);\n\t\n\t  /*\n\t   * @constructor\n\t   * @param {object} collection - an instantiated and valid kuzzle object\n\t   * @param {object} [filters] - Filters in Kuzzle DSL format\n\t   * @param {object} [options] - subscription optional configuration\n\t   */\n\t  function Room(collection, filters, options) {\n\t    _classCallCheck(this, Room);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Room.__proto__ || Object.getPrototypeOf(Room)).call(this));\n\t\n\t    var _roomId = null;\n\t\n\t    // Define properties\n\t    Object.defineProperties(_this, {\n\t      // private properties\n\t      roomstate: {\n\t        // Values can be: inactive, subscribing, active\n\t        value: 'inactive',\n\t        writable: true\n\t      },\n\t      kuzzle: {\n\t        value: collection.kuzzle\n\t      },\n\t      isListening: {\n\t        value: false,\n\t        writable: true\n\t      },\n\t      //listeners\n\t      resubscribe: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t          _this.error = null;\n\t          _this.subscribe();\n\t        }\n\t      },\n\t      deactivate: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t        }\n\t      },\n\t      resubscribeConditional: {\n\t        value: function value() {\n\t          _this.roomstate = 'inactive';\n\t\n\t          if (_this.autoResubscribe) {\n\t            _this.subscribe();\n\t          }\n\t        }\n\t      },\n\t      //enumerables\n\t      channel: {\n\t        value: null,\n\t        writable: true,\n\t        enumerable: true\n\t      },\n\t      scope: {\n\t        value: options && options.scope ? options.scope : 'all',\n\t        enumerable: true\n\t      },\n\t      state: {\n\t        value: options && options.state ? options.state : 'done',\n\t        enumerable: true\n\t      },\n\t      users: {\n\t        value: options && options.users ? options.users : 'none',\n\t        enumerable: true\n\t      },\n\t      // read-only properties\n\t      collection: {\n\t        value: collection,\n\t        enumerable: true\n\t      },\n\t      filters: {\n\t        value: filters ? filters : {},\n\t        enumerable: true\n\t      },\n\t      roomId: {\n\t        enumerable: true,\n\t        get: function get() {\n\t          return _roomId;\n\t        },\n\t        set: function set(value) {\n\t          if (!_roomId) {\n\t            _roomId = value;\n\t          }\n\t        }\n\t      },\n\t      // writable properties\n\t      volatile: {\n\t        value: options && options.volatile ? options.volatile : {},\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      subscribeToSelf: {\n\t        value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n\t        enumerable: true,\n\t        writable: true\n\t      },\n\t      autoResubscribe: {\n\t        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : collection.kuzzle.autoResubscribe,\n\t        enumerable: true\n\t      }\n\t    });\n\t\n\t    if (_this.kuzzle.bluebird) {\n\t      var _ret;\n\t\n\t      return _ret = _this.kuzzle.bluebird.promisifyAll(_this, {\n\t        suffix: 'Promise',\n\t        filter: function filter(name, func, target, passes) {\n\t          var whitelist = ['count', 'subscribe', 'unsubscribe', 'onDone'];\n\t\n\t          return passes && whitelist.indexOf(name) !== -1;\n\t        }\n\t      }), _possibleConstructorReturn(_this, _ret);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Returns the number of other subscriptions on that room.\n\t   *\n\t   * @param {responseCallback} cb - Handles the query response\n\t   */\n\t\n\t\n\t  _createClass(Room, [{\n\t    key: 'count',\n\t    value: function count(cb) {\n\t      this.kuzzle.callbackRequired('Room.count', cb);\n\t\n\t      var data = { body: { roomId: this.roomId } };\n\t\n\t      if (this.roomstate !== 'active') {\n\t        return cb(new Error('Cannot count subscriptions on an non-active room'));\n\t      }\n\t\n\t      this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n\t        cb(err, res && res.result.count);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Subscribes to Kuzzle \n\t     * (do nothing if a subscription is active or underway)\n\t     * \n\t     * @param options\n\t     * @param {responseCallback} cb - called when the subscription is ready.\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(options, cb) {\n\t      var _this2 = this;\n\t\n\t      if (!cb && typeof options === 'function') {\n\t        cb = options;\n\t        options = null;\n\t      }\n\t\n\t      if (cb) {\n\t        this.onDone(cb);\n\t      }\n\t\n\t      // If the room subscription is active, just call the callback.\n\t      if (this.roomstate === 'active') {\n\t        this.emit('done', null, this);\n\t        return this;\n\t      }\n\t\n\t      // If the room is already subscribing, wait for its activation.\n\t      if (this.roomstate === 'subscribing') {\n\t        return this;\n\t      }\n\t\n\t      // If the room is still inactive, start the subscription.\n\t      this.error = null;\n\t      this.roomstate = 'subscribing';\n\t\n\t      this.kuzzle.subscribe(this, options, function (error, result) {\n\t        if (error) {\n\t          if (error.message === 'Not Connected') {\n\t            return _this2.kuzzle.once('connected', _this2.resubscribe);\n\t          }\n\t\n\t          _this2.roomstate = 'inactive';\n\t          _this2.error = new Error('Error during Kuzzle subscription: ' + error.message);\n\t          _this2.emit('done', _this2.error);\n\t          return null;\n\t        }\n\t\n\t        _this2.roomId = result.roomId;\n\t        _this2.channel = result.channel;\n\t        _this2.roomstate = 'active';\n\t\n\t        if (!_this2.isListening) {\n\t          _this2.kuzzle.addListener('disconnected', _this2.deactivate);\n\t          _this2.kuzzle.addListener('tokenExpired', _this2.deactivate);\n\t          _this2.kuzzle.addListener('reconnected', _this2.resubscribeConditional);\n\t          _this2.isListening = true;\n\t        }\n\t\n\t        _this2.emit('done', null, _this2);\n\t      });\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unsubscribes from Kuzzle.\n\t     *\n\t     * Stop listening immediately.\n\t     * @param {responseCallback} cb - Handles the query response\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(cb) {\n\t      if (this.roomstate === 'subscribing') {\n\t        if (cb) {\n\t          cb(new Error('Cannot unsubscribe a room while a subscription attempt is underway'));\n\t        }\n\t\n\t        return this;\n\t      }\n\t\n\t      if (this.isListening) {\n\t        this.kuzzle.removeListener('disconnected', this.deactivate);\n\t        this.kuzzle.removeListener('tokenExpired', this.deactivate);\n\t        this.kuzzle.removeListener('reconnected', this.resubscribeConditional);\n\t        this.isListening = false;\n\t      }\n\t\n\t      if (this.roomstate === 'active') {\n\t        this.kuzzle.unsubscribe(this, cb);\n\t      } else if (cb) {\n\t        cb(null, this.roomId);\n\t      }\n\t\n\t      this.roomstate = 'inactive';\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Notify listeners\n\t     *\n\t     * @param {Object} data - data to send. Must contain `data.type` as eventName.\n\t     * @return {*} this\n\t     */\n\t\n\t  }, {\n\t    key: 'notify',\n\t    value: function notify(data) {\n\t      if (data.type === undefined) {\n\t        throw new Error('Room.notify: argument must match {type: <document|user>}');\n\t      }\n\t      if (!data.fromSelf || this.subscribeToSelf) {\n\t        this.emit(data.type, data);\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Registers a callback to be called with a subscription result\n\t     * @param {Function} cb\n\t     */\n\t\n\t  }, {\n\t    key: 'onDone',\n\t    value: function onDone(cb) {\n\t      if (!cb || typeof cb !== 'function') {\n\t        throw new Error('Room.onDone: a callback argument is required.');\n\t      }\n\t\n\t      if (this.error) {\n\t        cb(this.error);\n\t      } else if (this.roomstate === 'active') {\n\t        cb(null, this);\n\t      } else {\n\t        this.once('done', cb);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t\n\t  return Room;\n\t}(KuzzleEventEmitter);\n\t\n\tmodule.exports = Room;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar RTWrapper = __webpack_require__(3);\n\t\n\tvar SocketIO = function (_RTWrapper) {\n\t  _inherits(SocketIO, _RTWrapper);\n\t\n\t  function SocketIO(host, options) {\n\t    _classCallCheck(this, SocketIO);\n\t\n\t    var _this = _possibleConstructorReturn(this, (SocketIO.__proto__ || Object.getPrototypeOf(SocketIO)).call(this, host, options));\n\t\n\t    _this.socket = null;\n\t    _this.forceDisconnect = false;\n\t    _this.eventsWrapper = {};\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Connect to the SocketIO server\n\t   */\n\t\n\t\n\t  _createClass(SocketIO, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\t\n\t      _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'connect', this).call(this);\n\t\n\t      this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n\t        reconnection: this.autoReconnect,\n\t        reconnectionDelay: this.reconnectionDelay,\n\t        forceNew: true\n\t      });\n\t\n\t      this.socket.on('connect', function () {\n\t        return _this2.clientConnected();\n\t      });\n\t      this.socket.on('connect_error', function (error) {\n\t        return _this2.clientNetworkError(error);\n\t      });\n\t\n\t      this.socket.on('disconnect', function () {\n\t        if (_this2.forceDisconnect) {\n\t          _this2.clientDisconnected();\n\t        } else {\n\t          var error = new Error('An error occurred, kuzzle may not be ready yet');\n\t          error.status = 500;\n\t\n\t          _this2.clientNetworkError(error);\n\t        }\n\t\n\t        _this2.forceDisconnect = false;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Registers a callback on an event. Once 1 message is received, fires the\n\t     * callback and unregister it afterward.\n\t     *\n\t     * @param {string} event\n\t     * @param {function} callback\n\t     */\n\t\n\t  }, {\n\t    key: 'addOnceListener',\n\t    value: function addOnceListener(event, callback) {\n\t      return this.addListener(event, callback, true);\n\t    }\n\t  }, {\n\t    key: 'once',\n\t    value: function once(event, callback) {\n\t      return this.addOnceListener(event, callback);\n\t    }\n\t  }, {\n\t    key: 'prependOnceListener',\n\t    value: function prependOnceListener(event, callback) {\n\t      return this.prependListener(event, callback, true);\n\t    }\n\t\n\t    /**\n\t     * Registers a callback on an event.\n\t     *\n\t     * @param {string} event\n\t     * @param {function} callback\n\t     */\n\t\n\t  }, {\n\t    key: 'addListener',\n\t    value: function addListener(event, callback) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this._addEventWrapper(event, callback, once);\n\t      _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'addListener', this).call(this, event, callback, once);\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'on',\n\t    value: function on(event, callback) {\n\t      return this.addListener(event, callback);\n\t    }\n\t  }, {\n\t    key: 'prependListener',\n\t    value: function prependListener(event, callback) {\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      this._addEventWrapper(event, callback, once);\n\t      return this.prependListener(event, callback, once);\n\t    }\n\t\n\t    /**\n\t     * Unregisters a callback from an event.\n\t     *\n\t     * @param {string} event\n\t     * @param {function} callback\n\t     */\n\t\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(event, callback) {\n\t      if (this.eventsWrapper[event]) {\n\t        this.eventsWrapper[event].listeners.delete(callback);\n\t\n\t        if (this.eventsWrapper[event].listeners.size === 0) {\n\t          this.socket.off(event, this.eventsWrapper[event].wrapper);\n\t          delete this.eventsWrapper[event];\n\t        }\n\t\n\t        _get(SocketIO.prototype.__proto__ || Object.getPrototypeOf(SocketIO.prototype), 'removeListener', this).call(this, event, callback);\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Unregisters all listeners either from an event, or from all events\n\t     *\n\t     * @param {string} [event]\n\t     */\n\t\n\t  }, {\n\t    key: 'removeAllListeners',\n\t    value: function removeAllListeners(event) {\n\t      if (event !== undefined && this.eventsWrapper[event] !== undefined) {\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = this.eventsWrapper[event].listeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var listener = _step.value;\n\t\n\t            this.removeListener(event, listener);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        var _iteratorNormalCompletion2 = true;\n\t        var _didIteratorError2 = false;\n\t        var _iteratorError2 = undefined;\n\t\n\t        try {\n\t          for (var _iterator2 = Object.keys(this.eventsWrapper)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t            var _event = _step2.value;\n\t\n\t            this.removeAllListeners(_event);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError2 = true;\n\t          _iteratorError2 = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t              _iterator2.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError2) {\n\t              throw _iteratorError2;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Sends a payload to the connected server\n\t     *\n\t     * @param {Object} payload\n\t     */\n\t\n\t  }, {\n\t    key: 'send',\n\t    value: function send(payload) {\n\t      this.socket.emit('kuzzle', payload);\n\t    }\n\t\n\t    /**\n\t     * Closes the connection\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      this.forceDisconnect = true;\n\t      this.state = 'offline';\n\t      this.socket.close();\n\t      this.socket = null;\n\t    }\n\t  }, {\n\t    key: '_addEventWrapper',\n\t    value: function _addEventWrapper(event, callback) {\n\t      var _this3 = this;\n\t\n\t      var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      if (!this.eventsWrapper[event]) {\n\t        var wrapper = function wrapper() {\n\t          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t            args[_key] = arguments[_key];\n\t          }\n\t\n\t          return _this3.emit.apply(_this3, [event].concat(args));\n\t        };\n\t\n\t        this.eventsWrapper[event] = {\n\t          wrapper: wrapper,\n\t          listeners: new Set()\n\t        };\n\t\n\t        if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n\t          if (once) {\n\t            this.socket.once(event, wrapper);\n\t          } else {\n\t            this.socket.on(event, wrapper);\n\t          }\n\t        }\n\t      }\n\t\n\t      this.eventsWrapper[event].listeners.add(callback);\n\t    }\n\t  }]);\n\t\n\t  return SocketIO;\n\t}(RTWrapper);\n\t\n\tmodule.exports = SocketIO;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar RTWrapper = __webpack_require__(3);\n\t\n\tvar WebSocketClient = void 0;\n\t\n\tvar WSNode = function (_RTWrapper) {\n\t  _inherits(WSNode, _RTWrapper);\n\t\n\t  function WSNode(host, options) {\n\t    _classCallCheck(this, WSNode);\n\t\n\t    var _this = _possibleConstructorReturn(this, (WSNode.__proto__ || Object.getPrototypeOf(WSNode)).call(this, host, options));\n\t\n\t    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"ws\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t    _this.client = null;\n\t    _this.lasturl = null;\n\t    return _this;\n\t  }\n\t\n\t  /**\n\t   * Connect to the websocket server\n\t   */\n\t\n\t\n\t  _createClass(WSNode, [{\n\t    key: 'connect',\n\t    value: function connect() {\n\t      var _this2 = this;\n\t\n\t      var url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n\t          opts = typeof window !== 'undefined' ? undefined : { perMessageDeflate: false };\n\t\n\t      _get(WSNode.prototype.__proto__ || Object.getPrototypeOf(WSNode.prototype), 'connect', this).call(this);\n\t\n\t      if (url !== this.lasturl) {\n\t        this.wasConnected = false;\n\t        this.lasturl = url;\n\t      }\n\t\n\t      this.client = new WebSocketClient(url, opts);\n\t\n\t      this.client.onopen = function () {\n\t        _this2.clientConnected();\n\t      };\n\t\n\t      this.client.onclose = function (closeEvent, message) {\n\t        var status = void 0,\n\t            reason = message;\n\t\n\t        if (typeof closeEvent === 'number') {\n\t          status = closeEvent;\n\t        } else {\n\t          status = closeEvent.code;\n\t\n\t          if (closeEvent.reason) {\n\t            reason = closeEvent.reason;\n\t          }\n\t        }\n\t\n\t        if (status === 1000) {\n\t          _this2.clientDisconnected();\n\t        }\n\t        // do not forward a connection close error if no \n\t        // connection has been previously established\n\t        else if (_this2.wasConnected) {\n\t            var error = new Error(reason);\n\t            error.status = status;\n\t\n\t            _this2.clientNetworkError(error);\n\t          }\n\t      };\n\t\n\t      this.client.onerror = function (error) {\n\t        var err = error instanceof Error && error || new Error(error);\n\t\n\t        _this2.clientNetworkError(err);\n\t      };\n\t\n\t      this.client.onmessage = function (payload) {\n\t        var data = JSON.parse(payload.data || payload);\n\t\n\t        if (data.room) {\n\t          _this2.emit(data.room, data);\n\t        } else {\n\t          _this2.emit('discarded', data);\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Sends a payload to the connected server\n\t     *\n\t     * @param {Object} payload\n\t     */\n\t\n\t  }, {\n\t    key: 'send',\n\t    value: function send(payload) {\n\t      if (this.client && this.client.readyState === this.client.OPEN) {\n\t        this.client.send(JSON.stringify(payload));\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Closes the connection\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      this.state = 'offline';\n\t      this.removeAllListeners();\n\t      this.wasConnected = false;\n\t      if (this.client) {\n\t        this.client.close();\n\t      }\n\t      this.client = null;\n\t      this.stopRetryingToConnect = true;\n\t    }\n\t  }]);\n\t\n\t  return WSNode;\n\t}(RTWrapper);\n\t\n\tmodule.exports = WSNode;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSearchResult = __webpack_require__(12),\n\t  Document = __webpack_require__(4),\n\t  CollectionMapping = __webpack_require__(10),\n\t  Room = __webpack_require__(6);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n\t * or like a room for pub/sub messages.\n\t *\n\t * @property {string} collection\n\t * @property {string} index\n\t * @property {Kuzzle} kuzzle\n\t * @property {Array.<string>} collection\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @param {string} collection - name of the data collection to handle\n\t * @param {string} index - Index containing the data collection\n\t * @constructor\n\t */\n\tfunction Collection(kuzzle, collection, index) {\n\t  if (!index || !collection) {\n\t    throw new Error('The Collection object constructor needs an index and a collection arguments');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    index: {\n\t      value: index,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (controller, action) {\n\t      return {\n\t        controller: controller,\n\t        action: action,\n\t        collection: this.collection,\n\t        index: this.index\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['subscribe'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of documents matching the provided set of filters.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.count = function (filters, options, cb) {\n\t  var query = {body: filters};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.count', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new empty data collection, with no associated mapping.\n\t * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n\t * want to create and prepare data collections before storing documents in it.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.create = function (options, cb) {\n\t  var data = {},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n\t    cb(err, err ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n\t *        If the same document already exists:\n\t *          - resolves with an error if set to \"error\".\n\t *          - replaces the existing document if set to \"replace\"\n\t *\n\t * @param {string} [id] - (optional) document identifier\n\t * @param {object} document - either an instance of a Document object, or a document\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tCollection.prototype.createDocument = function (id, document, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'create';\n\t\n\t  if (id && typeof id !== 'string') {\n\t    cb = options;\n\t    options = document;\n\t    document = id;\n\t    id = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  if (options && options.ifExist) {\n\t    if (options.ifExist === 'replace') {\n\t      action = 'createOrReplace';\n\t    }\n\t    else if (options.ifExist !== 'error') {\n\t      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n\t    }\n\t  }\n\t\n\t  if (id) {\n\t    data._id = id;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    var doc;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    doc.version = res.result._version;\n\t    cb(null, doc);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete persistent documents.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Collection} this\n\t */\n\tCollection.prototype.deleteDocument = function (arg, options, cb) {\n\t  var\n\t    action,\n\t    data = {};\n\t\n\t  if (typeof arg === 'string') {\n\t    data._id = arg;\n\t    action = 'delete';\n\t  } else {\n\t    data.body = {query: arg};\n\t    action = 'deleteByQuery';\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      cb(err);\n\t    }\n\t    else {\n\t      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Deletes the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.deleteSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Returns a boolean indicating whether or not a document with provided ID exists.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} options [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.documentExists = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve a single stored document using its unique document ID.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.fetchDocument = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiates a CollectionMapping object containing the current mapping of this collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.getMapping = function (options, cb) {\n\t  var kuzzleMapping;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\t\n\t  kuzzleMapping = new CollectionMapping(this);\n\t  kuzzleMapping.refresh(options, cb);\n\t};\n\t\n\t/**\n\t * Create the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Create or replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to create or replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {},\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Delete specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to delete\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Get specific documents according to given IDs\n\t *\n\t * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t */\n\tCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n\t  var data = {\n\t      body: {\n\t        ids: documentIds\n\t      }\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documentIds)) {\n\t    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Replace the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to replace\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Update the provided documents\n\t *\n\t * @param {Array.<document>} documents - Array of documents to update\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n\t * @returns {object} this\n\t */\n\tCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n\t  var data = {\n\t      body: {}\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!Array.isArray(documents)) {\n\t    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\t\n\t  data.body.documents = documents.map(function (doc) {\n\t    return (doc instanceof Document) ? doc.serialize() : doc;\n\t  });\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Retrieves the current specifications of this collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.getSpecifications = function (options, cb) {\n\t  var\n\t    data = { index: this.index, collection: this.collection },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Publish a realtime message\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} document - either a Document instance or a JSON object\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.publishMessage = function (document, options, cb) {\n\t  var data = {};\n\t\n\t  if (document instanceof Document) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replace an existing document with a new one.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to replace\n\t * @param {object} content - JSON object representing the new document version\n\t * @param {object} [options] - additional arguments\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Executes an advanced search on the data collection.\n\t *\n\t * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function.\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\t\n\tCollection.prototype.search = function (filters, options, cb) {\n\t  var\n\t    query = {body: filters},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.search', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      result.result.aggregations ? result.result.aggregations : {},\n\t      options,\n\t      filters,\n\t      options.previous || null\n\t    ));\n\t  });\n\t};\n\t\n\t/**\n\t * A \"scroll\" option can be passed to search queries, creating persistent\n\t * paginated results.\n\t * This method can be used to manually get the next page of a search result,\n\t * instead of using KuzzleSearchResult.next()\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {object} [filters]\n\t * @param {responseCallback} cb\n\t */\n\tCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scroll: scrollId is required');\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      {},\n\t      options,\n\t      filters,\n\t      options.previous || null\n\t    ));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieves next result of a search with scroll query.\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n\t  var\n\t    data = { scrollId: scrollId };\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Collection.scrollSpecifications: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\t\n\t  this.kuzzle.query(\n\t    { controller: 'collection', action: 'scrollSpecifications'},\n\t    data,\n\t    options,\n\t    function (err, res) {\n\t      cb (err, err ? undefined : res.result);\n\t    }\n\t  );\n\t};\n\t\n\t/**\n\t * Searches specifications across indexes/collections according to the provided filters\n\t *\n\t * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.searchSpecifications = function (filters, options, cb) {\n\t  var\n\t    data = { body: { query: filters } },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\t\n\t  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a subscription room to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @returns {*} KuzzleRoom object\n\t */\n\tCollection.prototype.room = function (filters, options) {\n\t  return new Room(this, filters, options);\n\t};\n\t\n\t/**\n\t * Subscribes to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @param {responseCallback} notificationCB - called for each new notification\n\t * @returns {*} KuzzleRoom object\n\t */\n\tCollection.prototype.subscribe = function (filters, options, notificationCB) {\n\t  var\n\t    evtName,\n\t    room;\n\t\n\t  if (!notificationCB && typeof options === 'function') {\n\t    notificationCB = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Collection.subscribe', notificationCB);\n\t\n\t  evtName = (options && options.users && options.users !== 'none') ? 'user' : 'document';\n\t  room = new Room(this, filters, options);\n\t\n\t  room.subscribe().on(evtName, notificationCB);\n\t  return room;\n\t};\n\t\n\t/**\n\t * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n\t * This method is a lot faster than removing all documents using a query.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tCollection.prototype.truncate = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Update parts of a document\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - volatile (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to update\n\t * @param {object} content - JSON object containing changes to perform on the document\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Returns an instantiated Document object\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n\t  var data = {\n\t      _id: documentId,\n\t      body: content\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options && options.retryOnConflict) {\n\t    data.retryOnConflict = options.retryOnConflict;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    (new Document(self, res.result._id)).refresh(cb);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Updates the current specifications of this collection\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @return {object} this\n\t */\n\tCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Validates the provided specifications\n\t *\n\t * @param {object} specifications - Specifications content\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n\t  var\n\t    collection = {},\n\t    data = { body: {} },\n\t    self = this;\n\t\n\t  collection[this.collection] = specifications;\n\t  data.body[this.index] = collection;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.valid);\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - document id\n\t * @param {object} content - document content\n\t * @constructor\n\t */\n\tCollection.prototype.document = function (id, content) {\n\t  return new Document(this, id, content);\n\t};\n\t\n\t/**\n\t * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n\t * @constructor\n\t */\n\tCollection.prototype.collectionMapping = function (mapping) {\n\t  return new CollectionMapping(this, mapping);\n\t};\n\t\n\tmodule.exports = Collection;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n\t *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n\t *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n\t *  the amount of data you stored in a collection and the complexity of your database.\n\t *\n\t *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n\t *\n\t * @param {object} collection - Instance of the inherited Collection object\n\t * @param {object} [mapping] - mappings\n\t * @constructor\n\t */\n\tfunction CollectionMapping(collection, mapping) {\n\t  Object.defineProperties(this, {\n\t    //read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: collection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    mapping: {\n\t      value: mapping || {},\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['set'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Applies the new mapping to the data collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tCollectionMapping.prototype.apply = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      body: {\n\t        properties: this.mapping\n\t      }\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n\t    if (err) {\n\t      return cb && cb(err);\n\t    }\n\t\n\t    self.refresh(options, cb);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with the mapping stored in Kuzzle\n\t *\n\t * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tCollectionMapping.prototype.refresh = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    if (res.result[self.collection.index]) {\n\t      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n\t        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\t\n\t        // Mappings can be empty. The mapping property should never be \"undefined\"\n\t        if (self.mapping === undefined) {\n\t          self.mapping = {};\n\t        }\n\t      } else {\n\t        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n\t      }\n\t    } else {\n\t      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds or updates a field mapping.\n\t *\n\t * Changes made by this function wont be applied until you call the apply method\n\t *\n\t * @param {string} field - Name of the field from which the mapping is to be added or updated\n\t * @param {object} mapping - corresponding field mapping\n\t * @returns {CollectionMapping}\n\t */\n\tCollectionMapping.prototype.set = function (field, mapping) {\n\t  this.mapping[field] = mapping;\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = CollectionMapping;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t// Parameter mutualization\n\tvar\n\t  getId = {getter: true, required: ['_id']},\n\t  getIdField = {getter: true, required: ['_id', 'field']},\n\t  getKeys = {getter: true, required: ['keys']},\n\t  getMember = {getter: true, required: ['_id', 'member']},\n\t  getxScan = {\n\t    getter: true, \n\t    required: ['_id', 'cursor'], \n\t    opts: ['match', 'count'],\n\t    mapResults: mapScanResults\n\t  },\n\t  getZrange = {\n\t    getter: true,\n\t    required: ['_id', 'start', 'stop'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  getZrangeBy = {\n\t    getter: true,\n\t    required: ['_id', 'min', 'max'],\n\t    opts: assignZrangeOptions,\n\t    mapResults: mapZrangeResults\n\t  },\n\t  setId = {required: ['_id']},\n\t  setIdValue = {required: ['_id', 'value']};\n\t\n\t// Redis commands\n\tvar\n\t  commands = {\n\t    append: setIdValue,\n\t    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n\t    bitop: {required: ['_id', 'operation', 'keys']},\n\t    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n\t    dbsize: {getter: true},\n\t    decr: setId,\n\t    decrby: setIdValue,\n\t    del: {required: ['keys']},\n\t    exists: getKeys,\n\t    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n\t    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n\t    flushdb: {mapResults: mapNoResult},\n\t    geoadd: {required: ['_id', 'points']},\n\t    geodist: {\n\t      getter: true,\n\t      required: ['_id', 'member1', 'member2'],\n\t      opts: ['unit'],\n\t      mapResults: parseFloat\n\t    },\n\t    geohash: {getter: true, required: ['_id', 'members']},\n\t    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n\t    georadius: {\n\t      getter: true,\n\t      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    georadiusbymember: {\n\t      getter: true,\n\t      required: ['_id', 'member', 'distance', 'unit'],\n\t      opts: assignGeoRadiusOptions,\n\t      mapResults: mapGeoRadiusResults\n\t    },\n\t    get: getId,\n\t    getbit: {getter: true, required: ['_id', 'offset']},\n\t    getrange: {getter: true, required: ['_id', 'start', 'end']},\n\t    getset: setIdValue,\n\t    hdel: {required: ['_id', 'fields']},\n\t    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n\t    hget: getIdField,\n\t    hgetall: {getter: true, required: ['_id']},\n\t    hincrby: {required: ['_id', 'field', 'value']},\n\t    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n\t    hkeys: getId,\n\t    hlen: getId,\n\t    hmget: {getter: true, required: ['_id', 'fields']},\n\t    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n\t    hscan: getxScan,\n\t    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n\t    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n\t    hstrlen: getIdField,\n\t    hvals: getId,\n\t    incr: setId,\n\t    incrby: setIdValue,\n\t    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n\t    keys: {getter: true, required: ['pattern']},\n\t    lindex: {getter: true, required: ['_id', 'idx']},\n\t    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n\t    llen: getId,\n\t    lpop: setId,\n\t    lpush: {required: ['_id', 'values']},\n\t    lpushx: setIdValue,\n\t    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n\t    lrem: {required: ['_id', 'count', 'value']},\n\t    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n\t    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n\t    mget: getKeys,\n\t    mset: {required: ['entries'], mapResults: mapNoResult},\n\t    msetnx: {required: ['entries'], mapResults: Boolean},\n\t    object: {getter: true, required: ['_id', 'subcommand']},\n\t    persist: {required: ['_id'], mapResults: Boolean},\n\t    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n\t    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n\t    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n\t    pfcount: getKeys,\n\t    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n\t    ping: {getter: true},\n\t    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n\t    pttl: getId,\n\t    randomkey: {getter: true},\n\t    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n\t    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n\t    rpop: setId,\n\t    rpoplpush: {required: ['source', 'destination']},\n\t    rpush: {required: ['_id', 'values']},\n\t    rpushx: setIdValue,\n\t    sadd: {required: ['_id', 'members']},\n\t    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n\t    scard: getId,\n\t    sdiff: {getter: true, required: ['_id', 'keys']},\n\t    sdiffstore: {required: ['_id', 'keys', 'destination']},\n\t    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n\t    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n\t    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n\t    sinter: getKeys,\n\t    sinterstore: {required: ['destination', 'keys']},\n\t    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n\t    smembers: getId,\n\t    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n\t    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n\t    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n\t    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n\t    srem: {required: ['_id', 'members']},\n\t    sscan: getxScan,\n\t    strlen: getId,\n\t    sunion: getKeys,\n\t    sunionstore: {required: ['destination', 'keys']},\n\t    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n\t    touch: {required: ['keys']},\n\t    ttl: getId,\n\t    type: getId,\n\t    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n\t    zcard: getId,\n\t    zcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zincrby: {required: ['_id', 'member', 'value']},\n\t    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n\t    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n\t    zrange: getZrange,\n\t    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n\t    zrangebyscore: getZrangeBy,\n\t    zrank: getMember,\n\t    zrem: {required: ['_id', 'members']},\n\t    zremrangebylex: {required: ['_id', 'min', 'max']},\n\t    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n\t    zremrangebyscore: {required: ['_id', 'min', 'max']},\n\t    zrevrange: getZrange,\n\t    zrevrangebyscore: getZrangeBy,\n\t    zrevrank: getMember,\n\t    zscan: getxScan,\n\t    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n\t    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n\t  };\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t * Kuzzle's memory storage is a separate data store from the database layer.\n\t * It is internaly based on Redis. You can access most of Redis functions (all\n\t * lowercased), except functions falling in the following categories:\n\t *\n\t *  - blocking functions\n\t *  - cluster commands\n\t *  - configuration commands\n\t *  - cursor functions\n\t *  - database administration commands\n\t *  - debugging functions\n\t *  - script based functions\n\t *  - transaction functions\n\t *\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @constructor\n\t */\n\tfunction MemoryStorage(kuzzle) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = [];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t// Dynamically builds this class' prototypes using the \"commands\" global variable\n\t(function () {\n\t  Object.keys(commands).forEach(function (command) {\n\t    MemoryStorage.prototype[command] = function () {\n\t      var\n\t        args = Array.prototype.slice.call(arguments),\n\t        options = null,\n\t        cb,\n\t        query = {\n\t          controller: 'ms',\n\t          action: command\n\t        },\n\t        data = {};\n\t\n\t      if (args.length && typeof args[args.length - 1] === 'function') {\n\t        cb = args.pop();\n\t      }\n\t\n\t      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\t\n\t      if (!commands[command].getter) {\n\t        data.body = {};\n\t      }\n\t\n\t      if (commands[command].required) {\n\t        commands[command].required.forEach(function (param) {\n\t          var value = args.shift();\n\t\n\t          if (value === undefined) {\n\t            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n\t          }\n\t\n\t          assignParameter(data, commands[command].getter, param, value);\n\t        });\n\t      }\n\t\n\t      if (args.length > 1) {\n\t        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n\t      }\n\t\n\t      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n\t        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n\t      }\n\t\n\t      if (args.length) {\n\t        options = Object.assign({}, args[0]);\n\t\n\t        if (Array.isArray(commands[command].opts)) {\n\t          commands[command].opts.forEach(function (opt) {\n\t            if (options[opt] !== null && options[opt] !== undefined) {\n\t              assignParameter(data, commands[command].getter, opt, options[opt]);\n\t              delete options[opt];\n\t            }\n\t          });\n\t        }\n\t      }\n\t\n\t      /*\n\t       Options function mapper does not necessarily need\n\t       options to be passed by clients.\n\t       */\n\t      if (typeof commands[command].opts === 'function') {\n\t        commands[command].opts(data, options || {});\n\t      }\n\t\n\t      this.kuzzle.query(query, data, options, cb && function (err, res) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t\n\t        if (commands[command].mapResults) {\n\t          return cb(null, commands[command].mapResults(res.result));\n\t        }\n\t\n\t        cb(null, res.result);\n\t      });\n\t\n\t      if (!commands[command].getter) {\n\t        return this;\n\t      }\n\t    };\n\t  });\n\t})();\n\t\n\t/**\n\t *\n\t * @param {object} data - target data object\n\t * @param {boolean} getter - tells if the command is a getter one\n\t * @param {string} name - parameter name\n\t * @param {*} value - parameter value\n\t */\n\tfunction assignParameter(data, getter, name, value) {\n\t  if (getter || name === '_id') {\n\t    data[name] = value;\n\t  }\n\t  else {\n\t    data.body[name] = value;\n\t  }\n\t}\n\t\n\t/**\n\t * Assign the provided options for the georadius* redis functions\n\t * to the request object, as expected by Kuzzle API\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignGeoRadiusOptions(data, options) {\n\t  var parsed = [];\n\t\n\t  Object.keys(options)\n\t    .filter(function (opt) {\n\t      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n\t    })\n\t    .forEach(function (opt) {\n\t      if (opt === 'withcoord' || opt === 'withdist') {\n\t        parsed.push(opt);\n\t        delete options[opt];\n\t      }\n\t      else if (opt === 'count' || opt === 'sort') {\n\t        if (opt === 'count') {\n\t          parsed.push('count');\n\t        }\n\t\n\t        parsed.push(options[opt]);\n\t      }\n\t\n\t      delete options[opt];\n\t    });\n\t\n\t  if (parsed.length > 0) {\n\t    data.options = parsed;\n\t  }\n\t}\n\t\n\t/**\n\t * Force the WITHSCORES option on z*range* routes\n\t *\n\t * Mutates the provided data and options objects\n\t *\n\t * @param {object} data\n\t * @param {object} options\n\t */\n\tfunction assignZrangeOptions(data, options) {\n\t  data.options = ['withscores'];\n\t\n\t  if (options.limit) {\n\t    data.limit = options.limit;\n\t    delete options.limit;\n\t  }\n\t}\n\t\n\t/**\n\t * Maps geopos results, from array<array<string>> to array<array<number>>\n\t *\n\t * @param {Array.<Array.<string>>} results\n\t * @return {Array.<Array.<Number>>}\n\t */\n\tfunction mapGeoposResults(results) {\n\t  return results.map(function (coords) {\n\t    return coords.map(function (latlon) {\n\t      return parseFloat(latlon);\n\t    });\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Maps georadius results to the format specified in the SDK documentation,\n\t * preventing different formats depending on the passed options\n\t *\n\t * Results can be either an array of point names, or an array\n\t * of arrays, each one of them containing the point name,\n\t * and additional informations depending on the passed options\n\t * (coordinates, distances)\n\t *\n\t * @param {Array} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapGeoRadiusResults(results) {\n\t  // Simple array of point names (no options provided)\n\t  if (!Array.isArray(results[0])) {\n\t    return results.map(function (point) {\n\t      return {name: point};\n\t    });\n\t  }\n\t\n\t  return results.map(function (point) {\n\t    // The point id is always the first item\n\t    var p = {\n\t        name: point[0]\n\t      },\n\t      i;\n\t\n\t    for (i = 1; i < point.length; i++) {\n\t      // withcoord result are in an array...\n\t      if (Array.isArray(point[i])) {\n\t        p.coordinates = point[i].map(function (coord) {\n\t          return parseFloat(coord);\n\t        });\n\t      }\n\t      else {\n\t        // ... and withdist are not\n\t        p.distance = parseFloat(point[i]);\n\t      }\n\t    }\n\t\n\t    return p;\n\t  });\n\t}\n\t\n\t/**\n\t * Map a string result to an array of strings.\n\t * Used to uniformize polymorphic results from redis\n\t *\n\t * @param {Array|string} results\n\t * @return {Array.<string>}\n\t */\n\tfunction mapStringToArray(results) {\n\t  return Array.isArray(results) ? results : [results];\n\t}\n\t\n\t/**\n\t * Map an array of strings to an array of integers\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Number>}\n\t */\n\tfunction mapArrayStringToArrayInt(results) {\n\t  return results.map(function (value) {\n\t    return parseInt(value);\n\t  });\n\t}\n\t\n\t/**\n\t * Disable results for routes like flushdb\n\t * @return {undefined}\n\t */\n\tfunction mapNoResult() {\n\t  return undefined;\n\t}\n\t\n\t/**\n\t * Map zrange results with WITHSCORES:\n\t * [\n\t *  \"member1\",\n\t *  \"score of member1\",\n\t *  \"member2\",\n\t *  \"score of member2\"\n\t * ]\n\t *\n\t * into the following format:\n\t * [\n\t *  {\"member\": \"member1\", \"score\": <score of member1>},\n\t *  {\"member\": \"member2\", \"score\": <score of member2>},\n\t * ]\n\t *\n\t *\n\t * @param {Array.<string>} results\n\t * @return {Array.<Object>}\n\t */\n\tfunction mapZrangeResults(results) {\n\t  var\n\t    buffer = null,\n\t    mapped = [];\n\t\n\t  results.forEach(function (value) {\n\t    if (buffer === null) {\n\t      buffer = value;\n\t    }\n\t    else {\n\t      mapped.push({member: buffer, score: parseFloat(value)});\n\t      buffer = null;\n\t    }\n\t  });\n\t\n\t  return mapped;\n\t}\n\t\n\t/**\n\t * Map *scan calls results, from:\n\t * [\n\t *   \"<cursor>\",\n\t *   [\n\t *     \"value1\",\n\t *     \"value2\", \n\t *     \"...\"\n\t *   ]\n\t * ]\n\t *\n\t * To:\n\t * {\n\t *   cursor: <cursor>,\n\t *   values: [\n\t *     \"value1\",\n\t *     \"value2\",\n\t *     \"...\"\n\t *   ]\n\t * }\n\t * \n\t * @param  {array.<string|array>} results \n\t * @return {object}\n\t */\n\tfunction mapScanResults(results) {\n\t  return {\n\t    cursor: results[0],\n\t    values: results[1]\n\t  };\n\t}\n\t\n\tmodule.exports = MemoryStorage;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * @param {Collection} collection\n\t * @param {int} total\n\t * @param {Document[]} documents\n\t * @param {object} aggregations\n\t * @param {object} options\n\t * @param {object} filters\n\t * @param {SearchResult} previous\n\t * @property {Collection} collection\n\t * @property {number} total\n\t * @property {Document[]} documents\n\t * @property {object} aggregations\n\t * @property {object} options\n\t * @property {object} filters\n\t * @property {number} fetchedDocument\n\t * @constructor\n\t */\n\tfunction SearchResult (collection, total, documents, aggregations, options, filters, previous) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    total: {\n\t      value: total,\n\t      enumerable: true\n\t    },\n\t    documents: {\n\t      value: documents,\n\t      enumerable: true\n\t    },\n\t    aggregations: {\n\t      value: aggregations || {},\n\t      enumerable: true\n\t    },\n\t    options: {\n\t      value: options || {},\n\t      enumerable: true\n\t    },\n\t    filters: {\n\t      value: filters || {},\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    fetchedDocument: {\n\t      value: previous instanceof SearchResult ? documents.length + previous.fetchedDocument : documents.length,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (this.collection.kuzzle.bluebird) {\n\t    return this.collection.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['fetchNext'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * @param {function} cb\n\t */\n\tSearchResult.prototype.fetchNext = function (cb) {\n\t  var\n\t    filters,\n\t    options = Object.assign({}, this.options),\n\t    self = this;\n\t  \n\t  options.previous = this;\n\t\n\t  // retrieve next results with scroll if original search use it\n\t  if (options.scrollId) {\n\t    if (this.fetchedDocument >= this.getTotal()) {\n\t      cb(null, null);\n\t      return;\n\t    }\n\t\n\t    // from and size parameters are not valid for a scroll action\n\t    if (typeof options.from !== 'undefined') {\n\t      delete options.from;\n\t    }\n\t\n\t    if (options.size) {\n\t      delete options.size;\n\t    }\n\t\n\t    this.collection.scroll(options.scrollId, options, this.filters || {}, cb);\n\t\n\t    return;\n\t  }\n\t\n\t  // retrieve next results using ES's search_after\n\t  if (options.size && this.filters.sort) {\n\t    if (this.fetchedDocument >= this.getTotal()) {\n\t      cb(null, null);\n\t      return;\n\t    }\n\t\n\t    if (options.from) {\n\t      delete options.from;\n\t    }\n\t\n\t    filters = Object.assign(this.filters, {search_after: []});\n\t\n\t    filters.sort.forEach(function (sortRule) {\n\t      filters.search_after.push(self.documents[self.documents.length - 1].content[Object.keys(sortRule)[0]]);\n\t    });\n\t\n\t    this.collection.search(filters, options, cb);\n\t\n\t    return;\n\t  }\n\t\n\t  // retrieve next results with from/size if original search use it\n\t  if (options.from !== undefined && options.size !== undefined) {\n\t    filters = Object.assign({}, this.filters);\n\t\n\t    // check if we need to do next request to fetch all matching documents\n\t    options.from += options.size;\n\t\n\t    if (options.from >= this.getTotal()) {\n\t      cb(null, null);\n\t\n\t      return;\n\t    }\n\t\n\t    this.collection.search(filters, options, cb);\n\t\n\t    return;\n\t  }\n\t\n\t  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n\t};\n\t\n\t/**\n\t * @returns {Document[]}\n\t */\n\tSearchResult.prototype.getDocuments = function () {\n\t  return this.documents;\n\t};\n\t\n\t/**\n\t * @returns {number}\n\t */\n\tSearchResult.prototype.getTotal = function () {\n\t  return this.total;\n\t};\n\t\n\t/**\n\t * @returns {object}\n\t */\n\tSearchResult.prototype.getAggregations = function () {\n\t  return this.aggregations;\n\t};\n\t\n\t/**\n\t * @returns {Object}\n\t */\n\tSearchResult.prototype.getOptions = function() {\n\t  return this.options;\n\t};\n\t\n\t/**\n\t * @returns {object}\n\t */\n\tSearchResult.prototype.getFilters = function() {\n\t  return this.filters;\n\t};\n\t\n\t/**\n\t * @returns {object}\n\t */\n\tSearchResult.prototype.getCollection = function () {\n\t  return this.collection;\n\t};\n\t\n\t/**\n\t * @returns {number}\n\t */\n\tSearchResult.prototype.getFetchedDocument = function () {\n\t  return this.fetchedDocument;\n\t};\n\t\n\tmodule.exports = SearchResult;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t *\n\t * @param protocol\n\t * @param host\n\t * @param options\n\t * @returns {Object} Instantiated WebSocket/Socket.IO object\n\t */\n\t\n\tfunction network(protocol, host, options) {\n\t  switch (protocol) {\n\t    case 'websocket':\n\t      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n\t        throw new Error('Aborting: no websocket support detected.');\n\t      }\n\t      return new (__webpack_require__(8))(host, options);\n\t    case 'socketio':\n\t      if (!window.io) {\n\t        throw new Error('Aborting: no socket.io library loaded.');\n\t      }\n\t      return new (__webpack_require__(7))(host, options);\n\t    default:\n\t      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n\t  }\n\t}\n\t\n\tmodule.exports = network;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(2);\n\t\n\tfunction Profile(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteProfile'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateProfile'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['hydrate', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tProfile.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Profile\n\t  }\n\t});\n\t\n\t/**\n\t * Persist to the persistent layer the current profile\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.save = function (options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!this.content.policies) {\n\t    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.serialize();\n\t\n\t  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Add a policy in the policies list\n\t * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.addPolicy = function (policy) {\n\t\n\t  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n\t  }\n\t\n\t  if (!this.content.policies) {\n\t    this.content.policies = [];\n\t  }\n\t\n\t  this.content.policies.push(policy);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set policies list\n\t * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @returns {Profile} this\n\t */\n\tProfile.prototype.setPolicies = function (policies) {\n\t\n\t  if (!Array.isArray(policies)) {\n\t    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t  }\n\t\n\t  policies.map(function (policy) {\n\t    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t    }\n\t  });\n\t\n\t  this.content.policies = policies;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this securityDocument\n\t */\n\tProfile.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data.meta = this.meta;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Returns the list of policies associated to this profile.\n\t * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @return {object} an array of policies\n\t */\n\tProfile.prototype.getPolicies = function () {\n\t  return this.content.policies;\n\t};\n\t\n\tmodule.exports = Profile;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SecurityDocument = __webpack_require__(2);\n\t\n\tfunction Role(Security, id, content, meta) {\n\t\n\t  SecurityDocument.call(this, Security, id, content, meta);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteRole'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateRole'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (Security.kuzzle.bluebird) {\n\t    return Security.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tRole.prototype = Object.create(SecurityDocument.prototype, {\n\t  constructor: {\n\t    value: Role\n\t  }\n\t});\n\t\n\t/**\n\t * Saves this role into Kuzzle.\n\t *\n\t * If this is a new role, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Role} this object\n\t */\n\tRole.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = Role;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar\n\t  Role = __webpack_require__(15),\n\t  Profile = __webpack_require__(14),\n\t  User = __webpack_require__(5);\n\t\n\t/**\n\t * Kuzzle security constructor\n\t *\n\t * @param kuzzle\n\t * @returns {Security}\n\t * @constructor\n\t */\n\tfunction Security(kuzzle) {\n\t\n\t  Object.defineProperty(this, 'kuzzle', {\n\t    value: kuzzle\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (action) {\n\t      return {\n\t        controller: 'security',\n\t        action: action\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Retrieve a single Role using its unique role ID.\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchRole = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id) {\n\t    throw new Error('Id parameter is mandatory for fetchRole function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on roles according to a filter\n\t *\n\t * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t *\n\t */\n\tSecurity.prototype.searchRoles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = result.result.hits.map(function (doc) {\n\t      return new Role(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, roles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new role in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same role already exists: throw an error if sets to false.\n\t *        Replace the existing role otherwise\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createRole: cannot create a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a role in Kuzzle.\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'updateRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateRole: cannot update a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete role.\n\t *\n\t * There is a small delay between role deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Role id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteRole = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - role id\n\t * @param {object} content - role content\n\t * @param {object} meta - role metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.role = function(id, content, meta) {\n\t  return new Role(this, id, content, meta);\n\t};\n\t\n\t\n\t/**\n\t * Get a specific profile from kuzzle\n\t *\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchProfile = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchProfile function');\n\t  }\n\t\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n\t    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on profiles according to a filter\n\t *\n\t *\n\t * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchProfiles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new Profile(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new profile in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same profile already exists: throw an error if sets to false.\n\t *        Replace the existing profile otherwise\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - list of policies to attach to the new profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = { policies: policies };\n\t  }\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a profile in Kuzzle.\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {array} policies - the list of policies to apply to this profile\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t\n\t  if (policies) {\n\t    data.body = {policies: policies};\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    var updatedContent = {};\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    Object.keys(res.result._source).forEach(function (property) {\n\t      updatedContent[property] = res.result._source[property];\n\t    });\n\t\n\t    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete profile.\n\t *\n\t * There is a small delay between profile deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteProfile = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollProfiles: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n\t    var profiles = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (profile) {\n\t      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\t\n\t      newProfile.version = profile._version;\n\t\n\t      profiles.push(newProfile);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      profiles: profiles,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t};\n\t\n\t/**\n\t * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - profile id\n\t * @param {object} content - profile content\n\t * @param {object} meta - profile metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.profile = function(id, content, meta) {\n\t  return new Profile(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Get a specific user from kuzzle using its unique ID\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tSecurity.prototype.fetchUser = function (id, options, cb) {\n\t  var\n\t    data = {_id: id},\n\t    self = this;\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for fetchUser function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on user according to a filter\n\t *\n\t * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - same filters as documents filters\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tSecurity.prototype.searchUsers = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n\t    var\n\t      documents,\n\t      scrollId = null;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new User(self, doc._id, doc._source, doc._meta);\n\t    });\n\t\n\t    if (response.result.scrollId) {\n\t      scrollId = response.result.scrollId;\n\t    }\n\t\n\t    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Replace an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.replaceUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new restricted user in Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profile` in `content` must only contains the profile id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (content.profileIds) {\n\t    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.updateUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Security.updateUser: cannot update an user without an user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete user.\n\t *\n\t * There is a small delay between user deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Security} this object\n\t */\n\tSecurity.prototype.deleteUser = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t */\n\tSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n\t  var\n\t    request = {},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('Security.scrollUsers: scrollId is required');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\t\n\t  request.scrollId = scrollId;\n\t\n\t  if (options && options.scroll) {\n\t    request.scroll = options.scroll;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n\t    var users = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (user) {\n\t      var newUser = new User(self, user._id, user._source, user._meta);\n\t\n\t      newUser.version = user._version;\n\t\n\t      users.push(newUser);\n\t    });\n\t\n\t    cb(null, {\n\t      total: result.result.total,\n\t      users: users,\n\t      scrollId: scrollId\n\t    });\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - user id\n\t * @param {object} content - user content\n\t * @param {object} meta - user metadata\n\t * @constructor\n\t */\n\tSecurity.prototype.user = function(id, content, meta) {\n\t  return new User(this, id, content, meta);\n\t};\n\t\n\t/**\n\t * Tells whether an action is allowed, denied or conditional based on the rights\n\t * rights provided as the first argument. An action is defined as a couple of\n\t * action and controller (mandatory), plus an index and a collection(optional).\n\t *\n\t * @param {object} rights - The rights rights associated to a user\n\t *                            (see getMyrights and getUserrights).\n\t * @param {string} controller - The controller to check the action onto.\n\t * @param {string} action - The action to perform.\n\t * @param {string} index - (optional) The name of index to perform the action onto.\n\t * @param {string} collection - (optional) The name of the collection to perform the action onto.\n\t *\n\t * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n\t *                   correspond to rights containing closures.\n\t *                   See also http://kuzzle.io/guide/#roles-definition\n\t */\n\tSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n\t  var filteredRights;\n\t\n\t  if (!rights || typeof rights !== 'object') {\n\t    throw new Error('rights parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!controller || typeof controller !== 'string') {\n\t    throw new Error('controller parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!action || typeof action !== 'string') {\n\t    throw new Error('action parameter is mandatory for isActionAllowed function');\n\t  }\n\t\n\t  // We filter in all the rights that match the request (including wildcards).\n\t  filteredRights = rights\n\t    .filter(function (right) {\n\t      return right.controller === controller || right.controller === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.action === action || right.action === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.index === index || right.index === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.collection === collection || right.collection === '*';\n\t    });\n\t\n\t  // Then, if at least one right allows the action, we return 'allowed'\n\t  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n\t    return 'allowed';\n\t  }\n\t  // If no right allows the action, we check for conditionals.\n\t  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n\t    return 'conditional';\n\t  }\n\t  // Otherwise we return 'denied'.\n\t  return 'denied';\n\t};\n\t\n\t\n\t/**\n\t * Gets the rights array of a given user.\n\t *\n\t * @param {string} userId The id of the user.\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {function} cb The callback containing the normalized array of rights.\n\t */\n\tSecurity.prototype.getUserRights = function (userId, options, cb) {\n\t  var\n\t    data = {_id: userId},\n\t    self = this;\n\t\n\t  if (!userId || typeof userId !== 'string') {\n\t    throw new Error('userId parameter is mandatory for getUserRights function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Create credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result._source);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete credentials of the specified <strategy> for the user <kuid> .\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieve a list of accepted fields per authentication strategy.\n\t *\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getAllCredentialFields = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieve the list of accepted field names by the specified <strategy>.\n\t *\n\t * @param strategy\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Get credential information of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Check the existence of the specified <strategy>s credentials for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Updates credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t * @returns {Security}\n\t */\n\tSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Validate credentials of the specified <strategy> for the user <kuid>.\n\t *\n\t * @param strategy\n\t * @param kuid\n\t * @param credentials\n\t * @param options\n\t * @param cb\n\t */\n\tSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n\t    if (!err) {\n\t      cb && cb(null, res.result);\n\t    } else {\n\t      cb && cb(err);\n\t    }\n\t  });\n\t};\n\t\n\tmodule.exports = Security;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\tvar rng;\n\t\n\tvar crypto = (window).crypto || (window).msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(18);\n\tvar bytesToUuid = __webpack_require__(17);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// kuzzle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d2654b12cf08324a5af1","const\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('./eventEmitter'),\n  Collection = require('./Collection.js'),\n  Document = require('./Document.js'),\n  Security = require('./security/Security'),\n  MemoryStorage = require('./MemoryStorage'),\n  User = require('./security/User'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n */\nclass Kuzzle extends KuzzleEventEmitter {\n  constructor(host, options, cb) {\n    super();\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    if (!host || host === '') {\n      throw new Error('host argument missing');\n    }\n\n    Object.defineProperties(this, {\n      // 'private' properties\n      connectCB: {\n        value: cb\n      },\n      eventActions: {\n        value: [\n          'connected',\n          'discarded',\n          'disconnected',\n          'loginAttempt',\n          'networkError',\n          'offlineQueuePush',\n          'offlineQueuePop',\n          'queryError',\n          'reconnected',\n          'tokenExpired'\n        ]\n      },\n      // configuration properties\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n        enumerable: true\n      },\n      defaultIndex: {\n        value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n        writable: true,\n        enumerable: true\n      },\n      jwt: {\n        value: undefined,\n        enumerable: true,\n        writable: true\n      },\n      protocol: {\n        value: (options && typeof options.protocol === 'string') ? options.protocol : 'websocket',\n        enumerable: true\n      },\n      sdkVersion: {\n        value: (typeof SDKVERSION === 'undefined') ? require('../package.json').version : SDKVERSION\n      },\n      volatile: {\n        value: {},\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      for (const opt of Object.keys(options)) {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    // Forward the subscribe query to the network wrapper\n    Object.defineProperty(this, 'subscribe', {\n      value: function(room, opts, subscribeCB) {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'subscribe',\n            index: room.collection.index,\n            collection: room.collection.collection,\n            volatile: this.volatile,\n            body: room.filters,\n            scope: room.scope,\n            state: room.state,\n            users: room.users\n          },\n          notificationCB = data => {\n            if (data.type === 'TokenExpired') {\n              this.unsetJwt();\n              return this.emit('tokenExpired');\n            }\n\n            if (data.type === 'document') {\n              const copy = Object.assign({}, data);\n              copy.document = new Document(room.collection, data.result._id, data.result._source, data.result._meta);\n              delete copy.result;\n              return room.notify(copy);\n            }\n\n            room.notify(data);\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkVersion: this.sdkVersion});\n\n        this.network.subscribe(object, opts, notificationCB, subscribeCB);\n      }\n    });\n\n    // Forward the unsubscribe query to the network wrapper\n    Object.defineProperty(this, 'unsubscribe', {\n      value: (room, unsubscribeCB) => {\n        const\n          object = {\n            requestId: uuidv4(),\n            controller: 'realtime',\n            action: 'unsubscribe',\n            volatile: this.volatile,\n            body: {roomId: room.roomId}\n          };\n\n        if (this.jwt !== undefined) {\n          object.jwt = this.jwt;\n        }\n\n        Object.assign(object.volatile, room.volatile, {sdkVersion: this.sdkVersion});\n\n        this.network.unsubscribe(object, room.channel, unsubscribeCB);\n      }\n    });\n\n    /**\n     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n     * and is called by these methods\n     */\n    Object.defineProperty(this, 'callbackRequired', {\n      value: (errorMessagePrefix, callback) => {\n        if (!callback || typeof callback !== 'function') {\n          throw new Error(`${errorMessagePrefix}: a callback argument is required for read queries`);\n        }\n      }\n    });\n\n    /**\n     * Create an attribute security that embed all methods to manage Role, Profile and User\n     */\n    Object.defineProperty(this, 'security', {\n      value: new Security(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'memoryStorage', {\n      value: new MemoryStorage(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'collections',{\n      value: {},\n      writable: true\n    });\n\n    Object.defineProperty(this, 'eventTimeout',{\n      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n    });\n\n    Object.defineProperty(this, 'protectedEvents', {\n      value: {\n        connected: {timeout: this.eventTimeout},\n        error: {timeout: this.eventTimeout},\n        disconnected: {timeout: this.eventTimeout},\n        reconnected: {timeout: this.eventTimeout},\n        tokenExpired: {timeout: this.eventTimeout},\n        loginAttempt: {timeout: this.eventTimeout}\n      }\n    });\n\n    this.network = networkWrapper(this.protocol, host, options);\n\n    // Properties related to the network layer\n    // Accessing a property irrelevant for a given protocol\n    // (e.g. \"autoReconnect\" for the HTTP layer) should\n    // throw an exception\n    Object.defineProperties(this, {\n      autoQueue: {\n        enumerable: true,\n        get: () => this.network.autoQueue,\n        set: value => {\n          checkPropertyType('autoQueue', 'boolean', value);\n          this.network.autoQueue = value;\n        }\n      },\n      autoReconnect: {\n        enumerable: true,\n        get: () => this.network.autoReconnect\n      },\n      autoReplay: {\n        enumerable: true,\n        get: () => this.network.autoReplay,\n        set: value => {\n          checkPropertyType('autoReplay', 'boolean', value);\n          this.network.autoReplay = value;\n        }\n      },\n      host: {\n        enumerable: true,\n        get: () => this.network.host\n      },\n      offlineQueue: {\n        enumerable: true,\n        get: () => this.network.offlineQueue\n      },\n      offlineQueueLoader: {\n        enumerable: true,\n        get: () => this.network.offlineQueueLoader,\n        set: value => {\n          if (value !== null) {\n            checkPropertyType('offlineQueueLoader', 'function', value);\n          }\n          this.network.offlineQueueLoader = value;\n        }\n      },\n      port: {\n        enumerable: true,\n        get: () => this.network.port\n      },\n      queueFilter: {\n        enumerable: true,\n        get: () => this.network.queueFilter,\n        set: value => {\n          checkPropertyType('queueFilter', 'function', value);\n          this.network.queueFilter = value;\n        }\n      },\n      queueMaxSize: {\n        enumerable: true,\n        get: () => this.network.queueMaxSize,\n        set: value => {\n          checkPropertyType('queueMaxSize', 'number', value);\n          this.network.queueMaxSize = value;\n        }\n      },\n      queueTTL: {\n        enumerable: true,\n        get: () => this.network.queueTTL,\n        set: value => {\n          checkPropertyType('queueTTL', 'number', value);\n          this.network.queueTTL = value;\n        }\n      },\n      replayInterval: {\n        enumerable: true,\n        get: () => this.network.replayInterval,\n        set: value => {\n          checkPropertyType('replayInterval', 'number', value);\n          this.network.replayInterval = value;\n        }\n      },\n      reconnectionDelay: {\n        enumerable: true,\n        get: () => this.network.reconnectionDelay\n      },\n      sslConnection: {\n        eumerable: true,\n        get: () => this.network.ssl\n      }\n    });\n\n    this.network.addListener('offlineQueuePush', data => this.emit('offlineQueuePush', data));\n    this.network.addListener('offlineQueuePop', data => this.emit('offlineQueuePop', data));\n    this.network.addListener('queryError', (err, query) => this.emit('queryError', err, query));\n\n    this.network.addListener('tokenExpired', () => {\n      this.unsetJwt();\n      this.emit('tokenExpired');\n    });\n\n    if ((options && options.connect || 'auto') === 'auto') {\n      this.connect();\n    }\n\n    if (this.bluebird) {\n      return this.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n            'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n            'checkToken', 'whoAmI', 'updateSelf', 'getMyRights', 'getMyCredentials',\n            'createMyCredentials', 'deleteMyCredentials', 'updateMyCredentials', 'validateMyCredentials',\n            'createIndex', 'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n          ];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n  * Emit an event to all registered listeners\n  * An event cannot be emitted multiple times before a timeout has been reached.\n  */\n  emit (eventName, ...payload) {\n    const\n      now = Date.now(),\n      protectedEvent = this.protectedEvents[eventName];\n\n    if (protectedEvent) {\n      if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n        return false;\n      }\n      protectedEvent.lastEmitted = now;\n    }\n\n    super.emit(eventName, ...payload);\n  }\n\n\n  /**\n   * Connects to a Kuzzle instance using the provided host name.\n   * @returns {Object} this\n   */\n  connect () {\n    if (this.network.state !== 'offline') {\n      if (this.connectCB) {\n        this.connectCB(null, this);\n      }\n      return this;\n    }\n\n    this.network.connect();\n\n    this.network.addListener('connect', () => {\n      this.emit('connected');\n\n      if (this.connectCB) {\n        this.connectCB(null, this);\n      }\n    });\n\n    this.network.addListener('networkError', error => {\n      const connectionError = new Error(`Unable to connect to kuzzle proxy server at ${this.network.host}:${this.network.port}`);\n\n      connectionError.internal = error;\n      this.emit('networkError', connectionError);\n\n      if (this.connectCB) {\n        this.connectCB(connectionError);\n      }\n    });\n\n    this.network.addListener('disconnect', () => {\n      this.disconnect();\n      this.emit('disconnected');\n    });\n\n    this.network.addListener('reconnect', () => {\n      if (this.jwt) {\n        this.checkToken(this.jwt, (err, res) => {\n          // shouldn't obtain an error but let's invalidate the token anyway\n          if (err || !res.valid) {\n            this.unsetJwt();\n          }\n\n          this.emit('reconnected');\n        });\n      } else {\n        this.emit('reconnected');\n      }\n    });\n\n    this.network.on('discarded', data => this.emit('discarded', data));\n\n    return this;\n  }\n\n  /**\n   * Set the jwt used to query kuzzle\n   * @param token\n   * @returns {Kuzzle}\n   */\n  setJwt (token) {\n    if (typeof token === 'string') {\n      this.jwt = token;\n    } else if (typeof token === 'object') {\n      if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n        this.jwt = token.result.jwt;\n      } else {\n        this.emit('loginAttempt', {\n          success: false,\n          error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n        });\n\n        return this;\n      }\n    } else {\n      this.emit('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n      return this;\n    }\n\n    this.emit('loginAttempt', {success: true});\n    return this;\n  }\n\n  /**\n   * Unset the jwt used to query kuzzle\n   * @returns {Kuzzle}\n   */\n  unsetJwt () {\n    this.jwt = undefined;\n    return this;\n  }\n\n  /**\n   * Get the jwt used by kuzzle\n   * @returns {Kuzzle}\n   */\n  getJwt () {\n    return this.jwt;\n  }\n\n  /**\n   * Send login request to kuzzle with credentials\n   * If login success, store the jwt into kuzzle object\n   *\n   * @param strategy\n   * @param credentials\n   * @param expiresIn\n   * @param cb\n   */\n  login (strategy, ...args) {\n    if (!strategy || typeof strategy !== 'string') {\n      throw new Error('Kuzzle.login: strategy required');\n    }\n\n    const \n      request = {\n        strategy,\n        body: {}\n      };\n\n    let cb = null;\n\n    // Handle arguments (credentials, expiresIn, cb)\n    if (args[0]) {\n      if (typeof args[0] === 'object') {\n        request.body = args[0];\n      } else if (typeof args[0] === 'number' || typeof args[0] === 'string') {\n        request.expiresIn = args[0];\n      } else if (typeof args[0] === 'function') {\n        cb = args[0];\n      }\n    }\n    if (args[1]) {\n      if (typeof args[1] === 'number' || typeof args[1] === 'string') {\n        request.expiresIn = args[1];\n      } else if (typeof args[1] === 'function') {\n        cb = args[1];\n      }\n    }\n    if (args[2] && typeof args[2] === 'function') {\n      cb = args[2];\n    }\n\n    this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, (error, response) => {\n      if (!error) {\n        if (response.result.jwt) {\n          this.setJwt(response.result.jwt);\n        }\n\n        cb && cb(null, response.result);\n      }\n      else {\n        cb && cb(error);\n        this.emit('loginAttempt', {success: false, error: error.message});\n      }\n    });\n  }\n\n  /**\n   * Create credentials of the specified <strategy> for the current user.\n   *\n   * @param credentials\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  createMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result._source);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Delete credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  deleteMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Get credential information of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   */\n  getMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Update credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentals\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  updateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Validate credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentials\n   * @param options\n   * @param cb\n   */\n  validateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Create a kuzzle index\n   *\n   * @param {string} index\n   * @param {object} [options]\n   * @param {responseCallback} cb\n   * @returns {Kuzzle}\n   */\n  createIndex (index, options, cb) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.createIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'index', action: 'create', index}, {}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Send logout request to kuzzle with jwt.\n   *\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  logout (cb) {\n    const\n      request = {\n        action: 'logout',\n        controller: 'auth',\n        requestId: uuidv4(),\n        body: {}\n      };\n\n    this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, error => {\n      if (typeof cb === 'function') {\n        cb(error, this);\n      }\n    });\n\n    return this.unsetJwt();\n  }\n\n  /**\n   * Checks whether a given jwt token still represents a valid session in Kuzzle.\n   *\n   * @param  {string}   token     The jwt token to check\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  checkToken (token, cb) {\n    const\n      request = {\n        body: {\n          token\n        }\n      };\n\n    this.callbackRequired('Kuzzle.checkToken', cb);\n\n    this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, (err, res) => {\n      cb(err, err ? undefined : res.result);\n    });\n  }\n\n  /**\n   * Fetches the current user.\n   *\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  whoAmI (cb) {\n    this.callbackRequired('Kuzzle.whoAmI', cb);\n\n    this.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, (err, res) => {\n      cb(err, err ? undefined : new User(this.security, res.result._id, res.result._source, res.result._meta));\n    });\n  }\n\n  /**\n   * Gets the rights array of the currently logged user.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param  {function} cb The callback containing the normalized array of rights.\n   */\n  getMyRights (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getMyRights', cb);\n\n    this.query({controller: 'auth', action:'getMyRights'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Update current user in Kuzzle.\n   *\n   * @param {object} content - a plain javascript object representing the user's modification\n   * @param {object} [options] - (optional) arguments\n   * @param {responseCallback} [cb] - (optional) Handles the query response\n   * @returns {Kuzzle} this object\n   */\n  updateSelf (content, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateSelf'}, {body: content}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n   * insertion.\n   *\n   * @param {string} event - name of the global event to subscribe to\n   * @param {function} listener - callback to invoke each time an event is fired\n   */\n  addListener (event, listener) {\n    if (this.eventActions.indexOf(event) === -1) {\n      throw new Error(`[${event}] is not a known event. Known events: ${this.eventActions.toString()}`);\n    }\n\n    return super.addListener(event, listener);\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method returns all available statistics from Kuzzle.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAllStatistics (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n    this.query({controller:'server', action: 'getAllStats'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n   * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n   *\n   * @param {number} [timestamp] -  Epoch time. Starting time from which the frames are to be retrieved\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getStatistics (timestamp, options, cb) {\n    if (!cb) {\n      if (!options) {\n        cb = timestamp;\n        options = null;\n        timestamp = null;\n      } else {\n        cb = options;\n        if (typeof timestamp === 'object') {\n          options = timestamp;\n          timestamp = null;\n        } else {\n          options = null;\n        }\n      }\n    }\n\n    this.callbackRequired('Kuzzle.getStatistics', cb);\n\n    const \n      queryCB = (err, res) => {\n        if (err) {\n          return cb(err);\n        }\n\n        cb(null, timestamp ? res.result.hits : [res.result]);\n      },\n      body = timestamp ? {body: {startTime: timestamp}} : {};\n\n    this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n  }\n\n  /**\n   * Create a new instance of a Collection object.\n   * If no index is specified, takes the default index.\n   *\n   * @param {string} collection - The name of the data collection you want to manipulate\n   * @param {string} [index] - The name of the data index containing the data collection\n   * @returns {Collection} A Collection instance\n   */\n  collection (collection, index) {\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Unable to create a new data collection object: no index specified');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    if (typeof index !== 'string' || typeof collection !== 'string') {\n      throw new Error('Invalid index or collection argument: string expected');\n    }\n\n    if (!this.collections[index]) {\n      this.collections[index] = {};\n    }\n\n    if (!this.collections[index][collection]) {\n      this.collections[index][collection] = new Collection(this, collection, index);\n    }\n\n    return this.collections[index][collection];\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   *\n   * @returns {Kuzzle}\n   */\n  flushQueue () {\n    this.network.flushQueue();\n    return this;\n  }\n\n  /**\n   * Returns the list of known persisted data collections.\n   *\n   * @param {string} [index] - Index containing collections to be listed\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listCollections (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.listCollections: index required');\n      }\n\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.listCollections', cb);\n\n    const query = {type: options && options.type || 'all'};\n\n    this.query({index, controller: 'collection', action: 'list'}, query, options, (err, res) => {\n      cb(err, err ? undefined : res.result.collections);\n    });\n  }\n\n  /**\n   * Returns the list of existing indexes in Kuzzle\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  listIndexes (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.listIndexes', cb);\n\n    this.query({controller: 'index', action: 'list'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.indexes);\n    });\n  }\n\n  /**\n   * Disconnects from Kuzzle and invalidate this instance.\n   */\n  disconnect () {\n    this.network.close();\n\n    for (const collection of Object.keys(this.collections)) {\n      delete this.collections[collection];\n    }\n  }\n\n  /**\n   * Returns the server informations\n   *\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getServerInfo (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n    this.query({controller: 'server', action: 'info'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.serverInfo);\n    });\n  }\n\n  /**\n   * Forces an index refresh\n   *\n   * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query response\n   * @returns {Kuzzle}\n   */\n  refreshIndex (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.refreshIndex: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.query({index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Returns de current autoRefresh status for the given index\n   *\n   * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n   * @param {object} options - Optinal arguments\n   * @param {responseCallback} cb - Handles the query response\n   */\n  getAutoRefresh (...args) {\n    let\n      index,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.getAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n    this.query({index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n  }\n\n  /**\n   * (Un)Sets the autoRefresh flag on the given index\n   *\n   * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n   * @param {boolean} autoRefresh - The autoRefresh value to set\n   * @param {object} options - Optional arguments\n   * @param {responseCallback} cb - Handles the query result\n   * @returns {object} this\n   */\n  setAutoRefresh (...args) {\n    var\n      index,\n      autoRefresh,\n      options,\n      cb;\n\n    for (const arg of args) {\n      switch (typeof arg) {\n        case 'string':\n          index = arg;\n          break;\n        case 'boolean':\n          autoRefresh = arg;\n          break;\n        case 'object':\n          options = arg;\n          break;\n        case 'function':\n          cb = arg;\n          break;\n      }\n    }\n\n    if (!index) {\n      if (!this.defaultIndex) {\n        throw new Error('Kuzzle.setAutoRefresh: index required');\n      }\n      index = this.defaultIndex;\n    }\n\n    if (autoRefresh === undefined) {\n      throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n    }\n\n    this.query({index, controller: 'index', action: 'setAutoRefresh'}, {body: {autoRefresh}}, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Return the current Kuzzle's UTC Epoch time, in milliseconds\n   * @param {object} [options] - Optional parameters\n   * @param {responseCallback} cb - Handles the query response\n   */\n  now (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.now', cb);\n\n    this.query({controller: 'server', action: 'now'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.now);\n    });\n  }\n\n  /**\n   * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n   * Base method used to send read queries to Kuzzle\n   *\n   * Takes an optional argument object with the following properties:\n   *    - volatile (object, default: null):\n   *        Additional information passed to notifications to other users\n   *\n   * @param {object} queryArgs - Query configuration\n   * @param {object} query - The query data\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} [cb] - Handles the query response\n   */\n  query (queryArgs, query, options, cb) {\n    const\n      object = {\n        action: queryArgs.action,\n        controller: queryArgs.controller,\n        volatile: this.volatile\n      };\n\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    } else if (!cb && !options && typeof query === 'function') {\n      cb = query;\n      query = {};\n      options = null;\n    }\n\n    if (options) {\n      for (const prop of ['refresh', 'from', 'size', 'scroll', 'scrollId']) {\n        if (options[prop] !== undefined) {\n          object[prop] = options[prop];\n        }\n      }\n\n      if (options.volatile && typeof options.volatile === 'object') {\n        Object.assign(object.volatile, options.volatile);\n      }\n    }\n\n    if (!query || typeof query !== 'object' || Array.isArray(query)) {\n      throw new Error('Invalid query parameter: ' + query);\n    }\n\n    Object.assign(object.volatile, query.volatile, {sdkVersion: this.sdkVersion});\n\n    for (const attr of Object.keys(query)) {\n      if (attr !== 'volatile') {\n        object[attr] = query[attr];\n      }\n    }\n\n    /*\n     * Do not add the token for the checkToken route, to avoid getting a token error when\n     * a developer simply wish to verify his token\n     */\n    if (this.jwt !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n      object.jwt = this.jwt;\n    }\n\n    if (queryArgs.collection) {\n      object.collection = queryArgs.collection;\n    }\n\n    if (queryArgs.index) {\n      object.index = queryArgs.index;\n    }\n\n    if (!object.requestId) {\n      object.requestId = uuidv4();\n    }\n\n    this.network.query(object, options, cb);\n\n    return this;\n  }\n\n  /**\n   * Starts the requests queuing.\n   */\n  startQueuing () {\n    this.network.startQueuing();\n    return this;\n  }\n\n  /**\n   * Stops the requests queuing.\n   */\n  stopQueuing () {\n    this.network.stopQueuing();\n    return this;\n  }\n\n  /**\n   * @DEPRECATED\n   * See Kuzzle.prototype.playQueue();\n   */\n  replayQueue () {\n    return this.playQueue();\n  }\n\n  /**\n   * Plays the requests queued during offline mode.\n   */\n  playQueue () {\n    this.network.playQueue();\n    return this;\n  }\n\n  /**\n   * Sets the default Kuzzle index\n   *\n   * @param index\n   * @returns this\n   */\n  setDefaultIndex (index) {\n    if (typeof index !== 'string') {\n      throw new Error(`Invalid default index: [${index}] (an index name is expected)`);\n    }\n\n    if (index.length === 0) {\n      throw new Error('Cannot set an empty index as the default index');\n    }\n\n    this.defaultIndex = index;\n\n    return this;\n  }\n}\n\nfunction checkPropertyType(prop, typestr, value) {\n  const wrongType = typestr === 'array' ? !Array.isArray(value) : typeof value !== typestr;\n\n  if (wrongType) {\n    throw new Error(`Can only assign a ${typestr} value to property \"${prop}\"`);\n  }\n}\n\nmodule.exports = Kuzzle;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Kuzzle.js","class Listener {\n  constructor(fn, once = false) {\n    this.fn = fn;\n    this.once = once;\n  }\n}\n\nclass KuzzleEventEmitter {\n  constructor() {\n    this._events = {};\n  }\n\n  _exists (listeners, fn) {\n    return Boolean(listeners.find(listener => listener.fn === fn));\n  }\n\n  listeners (eventName) {\n    if (this._events[eventName] === undefined) {\n      return [];\n    }\n\n    return this._events[eventName].map(listener => listener.fn);\n  }\n\n  addListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    const listenerType = typeof listener;\n\n    if (listenerType !== 'function') {\n      throw new Error(`Invalid listener type: expected a function, got a ${listenerType}`);\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName].push(new Listener(listener, once));\n    }\n\n    return this;\n  }\n\n  on (eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  prependListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n    }\n\n    return this;\n  }\n\n  addOnceListener (eventName, listener) {\n    return this.addListener(eventName, listener, true);\n  }\n\n  once (eventName, listener) {\n    return this.addOnceListener(eventName, listener);\n  }\n\n  prependOnceListener (eventName, listener) {\n    return this.prependListener(eventName, listener, true);\n  }\n\n  removeListener (eventName, listener) {\n    const listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n\n    const index = listeners.findIndex(l => l.fn === listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    return this;\n  }\n\n  removeAllListeners (eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  }\n\n  emit (eventName, ...payload) {\n    const listeners = this._events[eventName];\n\n    if (listeners === undefined) {\n      return false;\n    }\n\n    const onceListeners = [];\n\n    for (const listener of listeners) {\n      listener.fn(...payload);\n\n      if (listener.once) {\n        onceListeners.push(listener.fn);\n      }\n    }\n\n    for (const toDelete of onceListeners) {\n      this.removeListener(eventName, toDelete);\n    }\n\n    return true;\n  }\n\n  eventNames () {\n    return Object.keys(this._events);\n  }\n\n  listenerCount (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  }\n}\n\nmodule.exports = KuzzleEventEmitter;\n\n\n\n// WEBPACK FOOTER //\n// ./src/eventEmitter/index.js","function SecurityDocument(Security, id, content, meta) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: Security.kuzzle\n    },\n    Security: {\n      value: Security\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    meta: {\n      value: meta || {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {SecurityDocument} this\n */\nSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {SecurityDocument} this\n */\nSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = SecurityDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/SecurityDocument.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nconst\n  KuzzleEventEmitter = require('../../../eventEmitter');\n\nclass RTWrapper extends KuzzleEventEmitter {\n\n  constructor (host, options) {\n    super();\n\n    Object.defineProperties(this, {\n      cleanHistoryTimer: {\n        value: null,\n        writable: true\n      },\n      host: {\n        value: host,\n        enumerable: true\n      },\n      port: {\n        value: (options && typeof options.port === 'number') ? options.port : 7512,\n        enumerable: true\n      },\n      ssl: {\n        value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n        enumerable: true\n      },\n      queuing: {\n        value: false,\n        writable: true\n      },\n      reconnectionDelay: {\n        value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n        enumerable: true\n      },\n      // configuration properties\n      autoReconnect: {\n        value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n        enumerable: true\n      },\n      autoQueue: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      autoReplay: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      state: {\n        value: 'offline',\n        enumerable: true,\n        writable: true\n      },\n      /*\n        Offline queue use the following format:\n              [\n                {\n                  ts: <query timestamp>,\n                  query: 'query',\n                  cb: callbackFunction\n                }\n              ]\n       */\n      offlineQueue: {\n        value: [],\n        enumerable: true,\n        writable: true\n      },\n      queueFilter: {\n        value: null,\n        enumerable: true,\n        writable: true\n      },\n      queueMaxSize: {\n        value: 500,\n        enumerable: true,\n        writable: true\n      },\n      queueTTL: {\n        value: 120000,\n        enumerable: true,\n        writable: true\n      },\n      replayInterval: {\n        value: 10,\n        enumerable: true,\n        writable: true\n      },\n      offlineQueueLoader: {\n        value: null,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      Object.keys(options).forEach(opt => {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      });\n\n      if (options.offlineMode === 'auto' && this.autoReconnect) {\n        this.autoQueue = this.autoReplay = true;\n      }\n    }\n\n    Object.defineProperty(this, 'requestHistory', {\n      value: {},\n      writable: true\n    });\n\n    this.wasConnected = false;\n    this.stopRetryingToConnect = false;\n    this.retrying = false;\n  }\n\n  connect() {\n    this.state = 'connecting';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected() {\n    this.state = 'connected';\n    this.emit(this.wasConnected && 'reconnect' || 'connect');\n    this.wasConnected = true;\n    this.stopRetryingToConnect = false;\n\n    if (this.autoQueue) {\n      this.stopQueuing();\n    }\n\n    if (this.autoReplay) {\n      this.playQueue();\n    }\n\n    if (!this.cleanHistoryTimer) {\n      this.cleanHistoryTimer = setInterval(() => { \n        cleanHistory(this.requestHistory); \n      }, 1000);\n    }\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  clientDisconnected() {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.clearHistoryTimer();\n    this.emit('disconnect');\n  }\n\n  /**\n   * Called when the client's connection is closed with an error state\n   *\n   * @param {Error} error\n   */\n  clientNetworkError(error) {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.clearHistoryTimer();\n\n    this.emit('networkError', error);\n    if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n      this.retrying = true;\n      setTimeout(() => {\n        this.retrying = false;\n        this.connect(this.host);\n      }, this.reconnectionDelay);\n    } else {\n      this.emit('disconnect');\n    }\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   */\n  flushQueue() {\n    this.offlineQueue = [];\n  }\n\n  /**\n   * Replays the requests queued during offline mode.\n   */\n  playQueue() {\n    if (this.state === 'connected') {\n      cleanQueue(this);\n      dequeue(this);\n    }\n  }\n\n  /**\n   * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  startQueuing() {\n    this.queuing = true;\n  }\n\n  /**\n   * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  stopQueuing() {\n    this.queuing = false;\n  }\n\n  subscribe(object, options, notificationCB, cb) {\n    if (this.state !== 'connected') {\n      return cb(new Error('Not Connected'));\n    }\n    this.query(object, options, (error, response) => {\n      if (error) {\n        return cb(error);\n      }\n      this.on(response.result.channel, data => {\n        data.fromSelf = this.requestHistory[data.requestId] !== undefined;\n        notificationCB(data);\n      });\n      cb(null, response.result);\n    });\n  }\n\n  unsubscribe(object, channel, cb) {\n    this.removeAllListeners(channel);\n    this.query(object, null, (err, res) => {\n      if (cb) {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  query(object, options, cb) {\n    let queuable = options && (options.queuable !== false) || true;\n\n    if (this.queueFilter) {\n      queuable = queuable && this.queueFilter(object);\n    }\n\n    if (this.queuing && queuable) {\n      cleanQueue(this, object, cb);\n      this.emit('offlineQueuePush', {query: object, cb: cb});\n      return this.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n    }\n\n    if (this.state === 'connected') {\n      return emitRequest(this, object, cb);\n    }\n\n    return discardRequest(object, cb);\n  }\n\n  clearHistoryTimer() {\n    if (this.cleanHistoryTimer) {\n      clearInterval(this.cleanHistoryTimer);\n      this.cleanHistoryTimer = null;\n    }\n  }\n}\n/**\n * Emit a request to Kuzzle\n *\n * @param {RTWrapper} network\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (network, request, cb) {\n  if (request.jwt !== undefined || cb) {\n    network.once(request.requestId, response => {\n      let error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        network.emit('tokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        network.emit('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n  // Track requests made to allow Room.subscribeToSelf to work\n  network.requestHistory[request.requestId] = Date.now();\n  network.send(request);\n}\n\nfunction discardRequest(object, cb) {\n  if (cb) {\n    cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n  }\n}\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n * @param {RTWrapper} network\n */\nfunction cleanQueue (network) {\n  const now = Date.now();\n  let lastDocumentIndex = -1;\n\n  if (network.queueTTL > 0) {\n    network.offlineQueue.forEach((query, index) => {\n      if (query.ts < now - network.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      network.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(droppedRequest => {\n          network.emit('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (network.queueMaxSize > 0 && network.offlineQueue.length > network.queueMaxSize) {\n    network.offlineQueue\n      .splice(0, network.offlineQueue.length - network.queueMaxSize)\n      .forEach(droppedRequest => {\n        network.emit('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue (network) {\n  const\n    uniqueQueue = {},\n    dequeuingProcess = () => {\n      if (network.offlineQueue.length > 0) {\n        emitRequest(network, network.offlineQueue[0].query, network.offlineQueue[0].cb);\n        network.emit('offlineQueuePop', network.offlineQueue.shift());\n\n        setTimeout(() => {\n          dequeuingProcess();\n        }, Math.max(0, network.replayInterval));\n      }\n    };\n\n  if (network.offlineQueueLoader) {\n    if (typeof network.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof network.offlineQueueLoader);\n    }\n\n    const additionalQueue = network.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      network.offlineQueue = additionalQueue\n        .concat(network.offlineQueue)\n        .filter(request => {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\n/**\n * Clean history from requests made more than 10s ago\n */\nfunction cleanHistory (requestHistory) {\n  var\n    now = Date.now();\n\n  Object.keys(requestHistory).forEach(function (key) {\n    if (requestHistory[key] < now - 10000) {\n      delete requestHistory[key];\n    }\n  });\n}\n\nmodule.exports = RTWrapper;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/abstract/realtime.js","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * Document is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {Collection} collection - an instanciated Collection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @param {object} [meta] - Initializes this document with the provided meta\n * @constructor\n */\nfunction Document(collection, documentId, content, meta) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: collection,\n      enumerable: false\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: false\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    meta: {\n      value: meta || {},\n      enumerable: true,\n      writable: false\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  if (this.version) {\n    data._version = this.version;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Checks if this document exists in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.exists = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.exists: cannot check if the document exists if no id has been provided');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'exists'), this.serialize(), options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('Document.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('Document.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new Document(self.dataCollection, self.id, res.result._source, res.result._meta);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Document.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('Document.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\nmodule.exports = Document;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Document.js\n// module id = 4\n// module chunks = 0","var\n  KuzzleSecurityDocument = require('./SecurityDocument');\n\n/**\n * @param {Security} Security\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction User(Security, id, content, meta) {\n  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    },\n    credentials: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: User\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {User} this\n */\nUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * @param {object} credentials\n */\nUser.prototype.setCredentials = function (credentials) {\n  if (typeof credentials !== 'object') {\n    throw new Error('Parameter \"credentials\" must be a object');\n  }\n\n  this.credentials = credentials;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {User} this\n */\nUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Creates this user into Kuzzle\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.create = function (options, cb) {\n  var\n    data = this.creationSerialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n\n/**\n * Replaces the latest version of this user in Kuzzle by the current content of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.replace = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n\n  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content, meta: this.meta};\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.creationSerialize = function () {\n  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array.<string>} the associated profiles IDs\n */\nUser.prototype.getProfileIds = function () {\n  return this.content.profileIds || [];\n};\n\n/**\n * Return the associated Profile objects\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nUser.prototype.getProfiles = function (options, cb) {\n  var \n    self = this,\n    fetchedProfiles = [],\n    errored = false;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\n  if (!self.content.profileIds) {\n    return cb(null, fetchedProfiles);\n  }\n\n  self.content.profileIds.forEach(function (profileId) {\n    self.Security.fetchProfile(profileId, options, function (error, profile) {\n      if (error) {\n        if (errored) {\n          return;\n        }\n\n        errored = true; // prevents multiple callback resolutions\n        return cb(error);\n      }\n\n      fetchedProfiles.push(profile);\n\n      if (fetchedProfiles.length === self.content.profileIds.length) {\n        cb(null, fetchedProfiles);\n      }\n    });\n  });\n};\n\nmodule.exports = User;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/User.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nconst\n  KuzzleEventEmitter = require('./eventEmitter');\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then youll receive a notification about it.\n *\n */\nclass Room extends KuzzleEventEmitter {\n  /*\n   * @constructor\n   * @param {object} collection - an instantiated and valid kuzzle object\n   * @param {object} [filters] - Filters in Kuzzle DSL format\n   * @param {object} [options] - subscription optional configuration\n   */\n  constructor(collection, filters, options) {\n    super();\n\n    let _roomId = null;\n\n    // Define properties\n    Object.defineProperties(this, {\n      // private properties\n      roomstate: {\n        // Values can be: inactive, subscribing, active\n        value: 'inactive',\n        writable: true\n      },\n      kuzzle: {\n        value: collection.kuzzle\n      },\n      isListening: {\n        value: false,\n        writable: true\n      },\n      //listeners\n      resubscribe: {\n        value: () => {\n          this.roomstate = 'inactive';\n          this.error = null;\n          this.subscribe();\n        }\n      },\n      deactivate: {\n        value: () => {\n          this.roomstate = 'inactive';\n        }\n      },\n      resubscribeConditional: {\n        value: () => {\n          this.roomstate = 'inactive';\n          \n          if (this.autoResubscribe) {\n            this.subscribe();\n          }\n        }\n      },\n      //enumerables\n      channel: {\n        value: null,\n        writable: true,\n        enumerable: true\n      },\n      scope: {\n        value: options && options.scope ? options.scope : 'all',\n        enumerable: true\n      },\n      state: {\n        value: options && options.state ? options.state : 'done',\n        enumerable: true\n      },\n      users: {\n        value: options && options.users ? options.users : 'none',\n        enumerable: true\n      },\n      // read-only properties\n      collection: {\n        value: collection,\n        enumerable: true\n      },\n      filters: {\n        value: filters ? filters : {},\n        enumerable: true,\n      },\n      roomId: {\n        enumerable: true,\n        get: () => _roomId,\n        set: value => {\n          if (!_roomId) {\n            _roomId = value;\n          }\n        }\n      },\n      // writable properties\n      volatile: {\n        value: (options && options.volatile) ? options.volatile : {},\n        enumerable: true,\n        writable: true\n      },\n      subscribeToSelf: {\n        value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n        enumerable: true,\n        writable: true\n      },\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : collection.kuzzle.autoResubscribe,\n        enumerable: true\n      }\n    });\n\n    if (this.kuzzle.bluebird) {\n      return this.kuzzle.bluebird.promisifyAll(this, {\n        suffix: 'Promise',\n        filter: function (name, func, target, passes) {\n          const whitelist = ['count', 'subscribe', 'unsubscribe', 'onDone'];\n\n          return passes && whitelist.indexOf(name) !== -1;\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the number of other subscriptions on that room.\n   *\n   * @param {responseCallback} cb - Handles the query response\n   */\n  count(cb) {\n    this.kuzzle.callbackRequired('Room.count', cb);\n\n    const data = {body: {roomId: this.roomId}};\n\n    if (this.roomstate !== 'active') {\n      return cb(new Error('Cannot count subscriptions on an non-active room'));\n    }\n\n    this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n      cb(err, res && res.result.count);\n    });\n  }\n\n  /**\n   * Subscribes to Kuzzle \n   * (do nothing if a subscription is active or underway)\n   * \n   * @param options\n   * @param {responseCallback} cb - called when the subscription is ready.\n   * @return {*} this\n   */\n  subscribe(options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    if (cb) {\n      this.onDone(cb);\n    }\n\n    // If the room subscription is active, just call the callback.\n    if (this.roomstate === 'active') {\n      this.emit('done', null, this);\n      return this;\n    }\n\n    // If the room is already subscribing, wait for its activation.\n    if (this.roomstate === 'subscribing') {\n      return this;\n    }\n\n    // If the room is still inactive, start the subscription.\n    this.error = null;\n    this.roomstate = 'subscribing';\n\n    this.kuzzle.subscribe(this, options, (error, result) => {\n      if (error) {\n        if (error.message === 'Not Connected') {\n          return this.kuzzle.once('connected', this.resubscribe);\n        }\n\n        this.roomstate = 'inactive';\n        this.error = new Error('Error during Kuzzle subscription: ' + error.message);\n        this.emit('done', this.error);\n        return null;\n      }\n\n      this.roomId = result.roomId;\n      this.channel = result.channel;\n      this.roomstate = 'active';\n\n      if (!this.isListening) {\n        this.kuzzle.addListener('disconnected', this.deactivate);\n        this.kuzzle.addListener('tokenExpired', this.deactivate);\n        this.kuzzle.addListener('reconnected', this.resubscribeConditional);\n        this.isListening = true;\n      }\n\n      this.emit('done', null, this);\n    });\n\n    return this;\n  }\n\n  /**\n   * Unsubscribes from Kuzzle.\n   *\n   * Stop listening immediately.\n   * @param {responseCallback} cb - Handles the query response\n   * @return {*} this\n   */\n  unsubscribe(cb) {\n    if (this.roomstate === 'subscribing') {\n      if (cb) {\n        cb(new Error('Cannot unsubscribe a room while a subscription attempt is underway'));\n      }\n\n      return this;\n    }\n\n    if (this.isListening) {\n      this.kuzzle.removeListener('disconnected', this.deactivate);\n      this.kuzzle.removeListener('tokenExpired', this.deactivate);\n      this.kuzzle.removeListener('reconnected', this.resubscribeConditional);\n      this.isListening = false;\n    }\n\n    if (this.roomstate === 'active') {\n      this.kuzzle.unsubscribe(this, cb);\n    }\n    else if (cb) {\n      cb(null, this.roomId);\n    }\n\n    this.roomstate = 'inactive';\n\n    return this;\n  }\n\n  /**\n   * Notify listeners\n   *\n   * @param {Object} data - data to send. Must contain `data.type` as eventName.\n   * @return {*} this\n   */\n  notify(data) {\n    if (data.type === undefined) {\n      throw new Error('Room.notify: argument must match {type: <document|user>}');\n    }\n    if (!data.fromSelf || this.subscribeToSelf) {\n      this.emit(data.type, data);\n    }\n    return this;\n  }\n\n  /**\n   * Registers a callback to be called with a subscription result\n   * @param {Function} cb\n   */\n  onDone(cb) {\n    if (!cb || typeof cb !== 'function') {\n      throw new Error('Room.onDone: a callback argument is required.');\n    }\n\n    if (this.error) {\n      cb(this.error);\n    }\n    else if (this.roomstate === 'active') {\n      cb(null, this);\n    }\n    else {\n      this.once('done', cb);\n    }\n\n    return this;\n  }\n}\n\nmodule.exports = Room;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Room.js","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nclass SocketIO extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    this.socket = null;\n    this.forceDisconnect = false;\n    this.eventsWrapper = {};\n  }\n\n  /**\n   * Connect to the SocketIO server\n   */\n  connect() {\n    super.connect();\n\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: this.autoReconnect,\n      reconnectionDelay: this.reconnectionDelay,\n      forceNew: true\n    });\n\n    this.socket.on('connect', () => this.clientConnected());\n    this.socket.on('connect_error', error => this.clientNetworkError(error));\n\n    this.socket.on('disconnect', () => {\n      if (this.forceDisconnect) {\n        this.clientDisconnected();\n      } else {\n        const error = new Error('An error occurred, kuzzle may not be ready yet');\n        error.status = 500;\n\n        this.clientNetworkError(error);\n      }\n\n      this.forceDisconnect = false;\n    });\n  }\n\n  /**\n   * Registers a callback on an event. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  addOnceListener(event, callback) {\n    return this.addListener(event, callback, true);\n  }\n\n  once(event, callback) {\n    return this.addOnceListener(event, callback);\n  }\n\n  prependOnceListener(event, callback) {\n    return this.prependListener(event, callback, true);\n  }\n\n  /**\n   * Registers a callback on an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  addListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    super.addListener(event, callback, once);\n\n    return this;\n  }\n\n  on(event, callback) {\n    return this.addListener(event, callback);\n  }\n\n  prependListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    return this.prependListener(event, callback, once);\n  }\n\n  /**\n   * Unregisters a callback from an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  removeListener(event, callback) {\n    if (this.eventsWrapper[event]) {\n      this.eventsWrapper[event].listeners.delete(callback);\n\n      if (this.eventsWrapper[event].listeners.size === 0) {\n        this.socket.off(event, this.eventsWrapper[event].wrapper);\n        delete this.eventsWrapper[event];\n      }\n\n      super.removeListener(event, callback);\n    }\n\n    return this;\n  }\n\n  /**\n   * Unregisters all listeners either from an event, or from all events\n   *\n   * @param {string} [event]\n   */\n  removeAllListeners(event) {\n    if (event !== undefined && this.eventsWrapper[event] !== undefined) {\n      for (const listener of this.eventsWrapper[event].listeners) {\n        this.removeListener(event, listener);\n      }\n    } else {\n      for (const _event of Object.keys(this.eventsWrapper)) {\n        this.removeAllListeners(_event);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send(payload) {\n    this.socket.emit('kuzzle', payload);\n  }\n\n  /**\n   * Closes the connection\n   */\n  close() {\n    this.forceDisconnect = true;\n    this.state = 'offline';\n    this.socket.close();\n    this.socket = null;\n  }\n\n  _addEventWrapper(event, callback, once = false) {\n    if (!this.eventsWrapper[event]) {\n      const wrapper = (...args) => this.emit(event, ...args);\n\n      this.eventsWrapper[event] = {\n        wrapper,\n        listeners: new Set()\n      };\n\n      if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n        if (once) {\n          this.socket.once(event, wrapper);\n        } else {\n          this.socket.on(event, wrapper);\n        }\n      }\n    }\n\n    this.eventsWrapper[event].listeners.add(callback);\n  }\n}\n\nmodule.exports = SocketIO;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/socketio.js","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nlet WebSocketClient;\n\nclass WSNode extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n    this.client = null;\n    this.lasturl = null;\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    const\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      opts = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    super.connect();\n\n    if (url !== this.lasturl) {\n      this.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new WebSocketClient(url, opts);\n\n    this.client.onopen = () => {\n      this.clientConnected();\n    };\n\n    this.client.onclose = (closeEvent, message) => {\n      let\n        status,\n        reason = message;\n\n      if (typeof closeEvent === 'number') {\n        status = closeEvent;\n      }\n      else {\n        status = closeEvent.code;\n\n        if (closeEvent.reason) {\n          reason = closeEvent.reason;\n        }\n      }\n\n      if (status === 1000) {\n        this.clientDisconnected();\n      }\n      // do not forward a connection close error if no \n      // connection has been previously established\n      else if (this.wasConnected) {\n        const error = new Error(reason);\n        error.status = status;\n\n        this.clientNetworkError(error);\n      }\n    };\n\n    this.client.onerror = error => {\n      const err = (error instanceof Error) && error || new Error(error);\n\n      this.clientNetworkError(err);\n    };\n\n    this.client.onmessage = payload => {\n      const data = JSON.parse(payload.data || payload);\n\n      if (data.room) {\n        this.emit(data.room, data);\n      }\n      else {\n        this.emit('discarded', data);\n      }\n    };\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.state = 'offline';\n    this.removeAllListeners();\n    this.wasConnected = false;\n    if (this.client) {\n      this.client.close();\n    }\n    this.client = null;\n    this.stopRetryingToConnect = true;\n  }\n}\n\nmodule.exports = WSNode;\n\n\n\n// WEBPACK FOOTER //\n// ./src/networkWrapper/protocols/websocket.js","var\n  KuzzleSearchResult = require('./SearchResult'),\n  Document = require('./Document'),\n  CollectionMapping = require('./CollectionMapping'),\n  Room = require('./Room');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction Collection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The Collection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.count = function (filters, options, cb) {\n  var query = {body: filters};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.count', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (err, res) {\n    cb(err, err ? undefined : res.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.create = function (options, cb) {\n  var data = {},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, function(err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *    - ifExist (string, allowed values: \"error\" (default), \"replace\"):\n *        If the same document already exists:\n *          - resolves with an error if set to \"error\".\n *          - replaces the existing document if set to \"replace\"\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a Document object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options && options.ifExist) {\n    if (options.ifExist === 'replace') {\n      action = 'createOrReplace';\n    }\n    else if (options.ifExist !== 'error') {\n      throw new Error('Invalid value for the \"ifExist\" option: ' + options.ifExist);\n    }\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new Document(self, res.result._id, res.result._source, res.result._meta);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Collection} this\n */\nCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = {query: arg};\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Deletes the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.deleteSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'deleteSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Returns a boolean indicating whether or not a document with provided ID exists.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} options [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.documentExists = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.documentExists', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'exists'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.fetch', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Instantiates a CollectionMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.getMapping', cb);\n\n  kuzzleMapping = new CollectionMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Create the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreate'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Create or replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to create or replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mCreateOrReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {},\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mCreateOrReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mCreateOrReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mCreateOrReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Delete specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to delete\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mDeleteDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mDeleteDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mDelete', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mDelete'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Get specific documents according to given IDs\n *\n * @param {Array.<string>} documentIds - IDs of the documents to retrieve\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n */\nCollection.prototype.mGetDocument = function (documentIds, options, cb) {\n  var data = {\n      body: {\n        ids: documentIds\n      }\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documentIds)) {\n    return cb(new Error('Collection.mGetDocument: documentIds parameter format is invalid (should be an array of IDs)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mGet', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mGet'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Replace the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to replace\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mReplaceDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mReplaceDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mReplace', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mReplace'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Update the provided documents\n *\n * @param {Array.<document>} documents - Array of documents to update\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated CollectionMapping object\n * @returns {object} this\n */\nCollection.prototype.mUpdateDocument = function (documents, options, cb) {\n  var data = {\n      body: {}\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!Array.isArray(documents)) {\n    return cb(new Error('Collection.mUpdateDocument: documents parameter format is invalid (should be an array of documents)'));\n  }\n\n  self.kuzzle.callbackRequired('Collection.mUpdate', cb);\n\n  data.body.documents = documents.map(function (doc) {\n    return (doc instanceof Document) ? doc.serialize() : doc;\n  });\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'mUpdate'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Retrieves the current specifications of this collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.getSpecifications = function (options, cb) {\n  var\n    data = { index: this.index, collection: this.collection },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.getSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'getSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a Document instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof Document) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new Document(self, res.result._id, res.result._source, res.result._meta);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nCollection.prototype.search = function (filters, options, cb) {\n  var\n    query = {body: filters},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.search', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      result.result.aggregations ? result.result.aggregations : {},\n      options,\n      filters,\n      options.previous || null\n    ));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Collection.scroll: scrollId is required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scroll', cb);\n\n  request.scrollId = scrollId;\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new Document(self, doc._id, doc._source, doc._meta);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      {},\n      options,\n      filters,\n      options.previous || null\n    ));\n  });\n\n  return this;\n};\n\n/**\n * Retrieves next result of a search with scroll query.\n *\n * @param {string} scrollId\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.scrollSpecifications = function (scrollId, options, cb) {\n  var\n    data = { scrollId: scrollId };\n\n  if (!scrollId) {\n    throw new Error('Collection.scrollSpecifications: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Collection.scrollSpecifications', cb);\n\n  this.kuzzle.query(\n    { controller: 'collection', action: 'scrollSpecifications'},\n    data,\n    options,\n    function (err, res) {\n      cb (err, err ? undefined : res.result);\n    }\n  );\n};\n\n/**\n * Searches specifications across indexes/collections according to the provided filters\n *\n * @param {object} [filters] - Optional filters in ElasticSearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.searchSpecifications = function (filters, options, cb) {\n  var\n    data = { body: { query: filters } },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('Collection.searchSpecifications', cb);\n\n  self.kuzzle.query({ controller: 'collection', action: 'searchSpecifications' }, data, options, function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n};\n\n/**\n * Create a subscription room to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.room = function (filters, options) {\n  return new Room(this, filters, options);\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} notificationCB - called for each new notification\n * @returns {*} KuzzleRoom object\n */\nCollection.prototype.subscribe = function (filters, options, notificationCB) {\n  var\n    evtName,\n    room;\n\n  if (!notificationCB && typeof options === 'function') {\n    notificationCB = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('Collection.subscribe', notificationCB);\n\n  evtName = (options && options.users && options.users !== 'none') ? 'user' : 'document';\n  room = new Room(this, filters, options);\n\n  room.subscribe().on(evtName, notificationCB);\n  return room;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - volatile (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated Document object\n * @return {object} this\n */\nCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options && options.retryOnConflict) {\n    data.retryOnConflict = options.retryOnConflict;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new Document(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n/**\n * Updates the current specifications of this collection\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @return {object} this\n */\nCollection.prototype.updateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'updateSpecifications'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return self;\n};\n\n/**\n * Validates the provided specifications\n *\n * @param {object} specifications - Specifications content\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nCollection.prototype.validateSpecifications = function (specifications, options, cb) {\n  var\n    collection = {},\n    data = { body: {} },\n    self = this;\n\n  collection[this.collection] = specifications;\n  data.body[this.index] = collection;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Collection.validateSpecifications', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('collection', 'validateSpecifications'), data, options, function (err, res) {\n    cb(err, err ? undefined : res.result.valid);\n  });\n};\n\n/**\n * Instantiate a new Document object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nCollection.prototype.document = function (id, content) {\n  return new Document(this, id, content);\n};\n\n/**\n * Instantiate a new CollectionMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the CollectionMapping object with\n * @constructor\n */\nCollection.prototype.collectionMapping = function (mapping) {\n  return new CollectionMapping(this, mapping);\n};\n\nmodule.exports = Collection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Collection.js\n// module id = 9\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The CollectionMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} collection - Instance of the inherited Collection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction CollectionMapping(collection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: collection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nCollectionMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = {\n      body: {\n        properties: this.mapping\n      }\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nCollectionMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function wont be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {CollectionMapping}\n */\nCollectionMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\nmodule.exports = CollectionMapping;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/CollectionMapping.js\n// module id = 10\n// module chunks = 0","// Parameter mutualization\nvar\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true, \n    required: ['_id', 'cursor'], \n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']};\n\n// Redis commands\nvar\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    flushdb: {mapResults: mapNoResult},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: {required: ['_id', 'field', 'value']},\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n    hscan: getxScan,\n    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n    mget: getKeys,\n    mset: {required: ['entries'], mapResults: mapNoResult},\n    msetnx: {required: ['entries'], mapResults: Boolean},\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: {required: ['_id'], mapResults: Boolean},\n    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction MemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = [];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(function () {\n  Object.keys(commands).forEach(function (command) {\n    MemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (args.length && typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\n      if (!commands[command].getter) {\n        data.body = {};\n      }\n\n      if (commands[command].required) {\n        commands[command].required.forEach(function (param) {\n          var value = args.shift();\n\n          if (value === undefined) {\n            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n          }\n\n          assignParameter(data, commands[command].getter, param, value);\n        });\n      }\n\n      if (args.length > 1) {\n        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n      }\n\n      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n      }\n\n      if (args.length) {\n        options = Object.assign({}, args[0]);\n\n        if (Array.isArray(commands[command].opts)) {\n          commands[command].opts.forEach(function (opt) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(data, commands[command].getter, opt, options[opt]);\n              delete options[opt];\n            }\n          });\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof commands[command].opts === 'function') {\n        commands[command].opts(data, options || {});\n      }\n\n      this.kuzzle.query(query, data, options, cb && function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (commands[command].mapResults) {\n          return cb(null, commands[command].mapResults(res.result));\n        }\n\n        cb(null, res.result);\n      });\n\n      if (!commands[command].getter) {\n        return this;\n      }\n    };\n  });\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  var parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions(data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults(results) {\n  return results.map(function (coords) {\n    return coords.map(function (latlon) {\n      return parseFloat(latlon);\n    });\n  });\n}\n\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    var p = {\n        name: point[0]\n      },\n      i;\n\n    for (i = 1; i < point.length; i++) {\n      // withcoord result are in an array...\n      if (Array.isArray(point[i])) {\n        p.coordinates = point[i].map(function (coord) {\n          return parseFloat(coord);\n        });\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(point[i]);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray(results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt(results) {\n  return results.map(function (value) {\n    return parseInt(value);\n  });\n}\n\n/**\n * Disable results for routes like flushdb\n * @return {undefined}\n */\nfunction mapNoResult() {\n  return undefined;\n}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults(results) {\n  var\n    buffer = null,\n    mapped = [];\n\n  results.forEach(function (value) {\n    if (buffer === null) {\n      buffer = value;\n    }\n    else {\n      mapped.push({member: buffer, score: parseFloat(value)});\n      buffer = null;\n    }\n  });\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\", \n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n * \n * @param  {array.<string|array>} results \n * @return {object}\n */\nfunction mapScanResults(results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MemoryStorage.js\n// module id = 11\n// module chunks = 0","/**\n * @param {Collection} collection\n * @param {int} total\n * @param {Document[]} documents\n * @param {object} aggregations\n * @param {object} options\n * @param {object} filters\n * @param {SearchResult} previous\n * @property {Collection} collection\n * @property {number} total\n * @property {Document[]} documents\n * @property {object} aggregations\n * @property {object} options\n * @property {object} filters\n * @property {number} fetchedDocument\n * @constructor\n */\nfunction SearchResult (collection, total, documents, aggregations, options, filters, previous) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    total: {\n      value: total,\n      enumerable: true\n    },\n    documents: {\n      value: documents,\n      enumerable: true\n    },\n    aggregations: {\n      value: aggregations || {},\n      enumerable: true\n    },\n    options: {\n      value: options || {},\n      enumerable: true\n    },\n    filters: {\n      value: filters || {},\n      enumerable: true\n    },\n    // writable properties\n    fetchedDocument: {\n      value: previous instanceof SearchResult ? documents.length + previous.fetchedDocument : documents.length,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  // promisifying\n  if (this.collection.kuzzle.bluebird) {\n    return this.collection.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['fetchNext'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * @param {function} cb\n */\nSearchResult.prototype.fetchNext = function (cb) {\n  var\n    filters,\n    options = Object.assign({}, this.options),\n    self = this;\n  \n  options.previous = this;\n\n  // retrieve next results with scroll if original search use it\n  if (options.scrollId) {\n    if (this.fetchedDocument >= this.getTotal()) {\n      cb(null, null);\n      return;\n    }\n\n    // from and size parameters are not valid for a scroll action\n    if (typeof options.from !== 'undefined') {\n      delete options.from;\n    }\n\n    if (options.size) {\n      delete options.size;\n    }\n\n    this.collection.scroll(options.scrollId, options, this.filters || {}, cb);\n\n    return;\n  }\n\n  // retrieve next results using ES's search_after\n  if (options.size && this.filters.sort) {\n    if (this.fetchedDocument >= this.getTotal()) {\n      cb(null, null);\n      return;\n    }\n\n    if (options.from) {\n      delete options.from;\n    }\n\n    filters = Object.assign(this.filters, {search_after: []});\n\n    filters.sort.forEach(function (sortRule) {\n      filters.search_after.push(self.documents[self.documents.length - 1].content[Object.keys(sortRule)[0]]);\n    });\n\n    this.collection.search(filters, options, cb);\n\n    return;\n  }\n\n  // retrieve next results with from/size if original search use it\n  if (options.from !== undefined && options.size !== undefined) {\n    filters = Object.assign({}, this.filters);\n\n    // check if we need to do next request to fetch all matching documents\n    options.from += options.size;\n\n    if (options.from >= this.getTotal()) {\n      cb(null, null);\n\n      return;\n    }\n\n    this.collection.search(filters, options, cb);\n\n    return;\n  }\n\n  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n};\n\n/**\n * @returns {Document[]}\n */\nSearchResult.prototype.getDocuments = function () {\n  return this.documents;\n};\n\n/**\n * @returns {number}\n */\nSearchResult.prototype.getTotal = function () {\n  return this.total;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getAggregations = function () {\n  return this.aggregations;\n};\n\n/**\n * @returns {Object}\n */\nSearchResult.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getFilters = function() {\n  return this.filters;\n};\n\n/**\n * @returns {object}\n */\nSearchResult.prototype.getCollection = function () {\n  return this.collection;\n};\n\n/**\n * @returns {number}\n */\nSearchResult.prototype.getFetchedDocument = function () {\n  return this.fetchedDocument;\n};\n\nmodule.exports = SearchResult;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/SearchResult.js\n// module id = 12\n// module chunks = 0","/**\n *\n * @param protocol\n * @param host\n * @param options\n * @returns {Object} Instantiated WebSocket/Socket.IO object\n */\n\nfunction network(protocol, host, options) {\n  switch (protocol) {\n    case 'websocket':\n      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n        throw new Error('Aborting: no websocket support detected.');\n      }\n      return new (require('./protocols/websocket'))(host, options);\n    case 'socketio':\n      if (!window.io) {\n        throw new Error('Aborting: no socket.io library loaded.');\n      }\n      return new (require('./protocols/socketio'))(host, options);\n    default:\n      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n  }\n}\n\nmodule.exports = network;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/index.js\n// module id = 13\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Profile(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nProfile.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Profile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Profile} this\n */\nProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {Profile} this\n */\nProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {Profile} this\n */\nProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = Profile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Profile.js\n// module id = 14\n// module chunks = 0","var SecurityDocument = require('./SecurityDocument');\n\nfunction Role(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nRole.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Role\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Role} this object\n */\nRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = Role;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Role.js\n// module id = 15\n// module chunks = 0","var\n  Role = require('./Role'),\n  Profile = require('./Profile'),\n  User = require('./User');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {Security}\n * @constructor\n */\nfunction Security(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.fetchRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for fetchRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new Role(self, doc._id, doc._source, doc._meta);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @param {object} meta - role metadata\n * @constructor\n */\nSecurity.prototype.role = function(id, content, meta) {\n  return new Role(this, id, content, meta);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new Profile(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {array} policies - list of policies to attach to the new profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = { policies: policies };\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {array} policies - the list of policies to apply to this profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = {policies: policies};\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollProfiles: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n    var profiles = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (profile) {\n      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\n      newProfile.version = profile._version;\n\n      profiles.push(newProfile);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      profiles: profiles,\n      scrollId: scrollId\n    });\n  });\n};\n\n/**\n * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @param {object} meta - profile metadata\n * @constructor\n */\nSecurity.prototype.profile = function(id, content, meta) {\n  return new Profile(this, id, content, meta);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created wont be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId = null;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new User(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Replace an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.replaceUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (content.profileIds) {\n    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollUsers: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n    var users = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (user) {\n      var newUser = new User(self, user._id, user._source, user._meta);\n\n      newUser.version = user._version;\n\n      users.push(newUser);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      users: users,\n      scrollId: scrollId\n    });\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @param {object} meta - user metadata\n * @constructor\n */\nSecurity.prototype.user = function(id, content, meta) {\n  return new User(this, id, content, meta);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the user <kuid> .\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a list of accepted fields per authentication strategy.\n *\n * @param options\n * @param cb\n */\nSecurity.prototype.getAllCredentialFields = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Retrieve the list of accepted field names by the specified <strategy>.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Get credential information of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Check the existence of the specified <strategy>s credentials for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Updates credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n */\nSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\nmodule.exports = Security;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/Security.js\n// module id = 16\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/bytesToUuid.js\n// module id = 17\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/rng-browser.js\n// module id = 18\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v4.js\n// module id = 19\n// module chunks = 0"],"sourceRoot":""}