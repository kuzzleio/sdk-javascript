<<<<<<< HEAD
{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kuzzle.js","webpack:///webpack/bootstrap 8c3162cebc031ff3d690","webpack:///./src/kuzzle.js","webpack:///./src/security/kuzzleSecurityDocument.js","webpack:///./src/networkWrapper/wrappers/websocket.js","webpack:///./src/security/kuzzleUser.js","webpack:///./~/uuid/index.js","webpack:///./~/uuid/lib/bytesToUuid.js","webpack:///./~/uuid/lib/rng-browser.js","webpack:///./src/kuzzleDataCollection.js","webpack:///./src/kuzzleDataMapping.js","webpack:///./src/kuzzleDocument.js","webpack:///./src/kuzzleMemoryStorage.js","webpack:///./src/kuzzleRoom.js","webpack:///./src/kuzzleSearchResult.js","webpack:///./src/kuzzleSubscribeResult.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/networkWrapper/wrappers/socketio.js","webpack:///./src/security/kuzzleProfile.js","webpack:///./src/security/kuzzleRole.js","webpack:///./src/security/kuzzleSecurity.js","webpack:///./~/uuid/v1.js","webpack:///./~/uuid/v4.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Kuzzle","host","options","cb","self","Error","Object","defineProperties","collections","value","writable","connectCB","eventListeners","connected","lastEmitted","listeners","error","disconnected","reconnected","jwtTokenExpired","loginAttempt","offlineQueuePush","offlineQueuePop","queryError","eventTimeout","queuing","requestHistory","state","subscriptions","pending","autoReconnect","enumerable","defaultIndex","undefined","reconnectionDelay","wsPort","ioPort","sslConnection","autoQueue","autoReplay","autoResubscribe","headers","metadata","offlineQueue","queueFilter","queueMaxSize","queueTTL","replayInterval","jwtToken","offlineQueueLoader","keys","forEach","opt","hasOwnProperty","getOwnPropertyDescriptor","offlineMode","defineProperty","query","header","errorMessagePrefix","callback","KuzzleSecurity","event","now","Date","args","Array","prototype","slice","arguments","eventProperties","listener","process","nextTick","fn","apply","KuzzleMemoryStorage","connect","cleanHistory","bluebird","promisifyAll","suffix","filter","name","func","target","passes","whitelist","indexOf","cleanQueue","lastDocumentIndex","index","ts","splice","droppedRequest","emitEvent","length","key","setTimeout","emitRequest","request","network","once","requestId","response","action","message","assign","status","send","dequeue","additionalQueue","uniqueQueue","dequeuingProcess","shift","Math","max","isArray","concat","controller","renewAllSubscriptions","roomId","subscriptionId","subscription","renew","removeAllSubscriptions","unsubscribe","uuid","KuzzleDataCollection","KuzzleUser","networkWrapper","disconnect","onConnect","onConnectError","connectionError","internal","onDisconnect","onReconnect","reconnect","checkToken","err","res","valid","setJwtToken","token","success","result","jwt","JSON","stringify","unsetJwtToken","getJwtToken","login","strategy","credentials","expiresIn","body","queuable","createIndex","logout","v4","callbackRequired","whoAmI","security","_id","_source","getMyRights","hits","updateSelf","content","data","queryArgs","addListener","listenerId","knownEvents","listenerType","isValid","toString","push","getAllStatistics","getStatistics","timestamp","queryCB","startTime","dataCollectionFactory","collection","flushQueue","listCollections","collectionType","arg","type","from","size","listIndexes","indexes","close","getServerInfo","serverInfo","refreshIndex","getAutoRefresh","setAutoRefresh","autoRefresh","attr","object","refresh","meta","addHeaders","removeAllListeners","eventName","removeListener","replayQueue","setDefaultIndex","setHeaders","replace","startQueuing","stopQueuing","KuzzleSecurityDocument","kuzzleSecurity","kuzzle","setContent","serialize","delete","buildQueryArgs","deleteActionName","update","updateActionName","WSNode","port","ssl","WebSocket","e","code","client","wasConnected","retrying","lasturl","url","window","perMessageDeflate","onopen","poke","onclose","onClientError","onerror","onmessage","payload","parse","room","keep","on","off","some","readyState","OPEN","create","constructor","setProfiles","profileIds","addProfile","profileId","save","saveRestricted","getProfiles","v1","bytesToUuid","buf","offset","bth","byteToHex","substr","rng","crypto","msCrypto","getRandomValues","rnds8","Uint8Array","rnds","r","random","blacklist","KuzzleSearchResult","KuzzleDocument","KuzzleDataMapping","KuzzleRoom","KuzzleSubscribeResult","count","filters","createDocument","document","updateIfExist","doc","version","_version","deleteDocument","ids","fetchDocument","documentId","fetchAllDocuments","warnEmitted","documents","search","getNextDocuments","searchResult","total","console","warn","next","getMapping","kuzzleMapping","publishMessage","replaceDocument","newDocument","_scroll_id","scrollId","aggregations","scroll","subscribe","subscribeResult","done","bind","truncate","updateDocument","documentFactory","roomFactory","dataMappingFactory","mapping","kuzzleDataCollection","properties","mappings","set","field","dataCollection","publish","values","keyVal","idOrKeys","commands","append","bgrewriteaof","bgsave","bitcount","bitop","bitpos","__opts__","blpop","brpoplpush","dbsize","decrby","del","discard","exec","exists","expire","expireat","flushdb","getbit","getrange","hdel","hexists","hincrby","hmset","hset","info","lastsave","lindex","linsert","lpush","lrange","lrem","lset","ltrim","mset","multi","pexpire","pexpireat","pfadd","pfmerge","ping","psetex","randomkey","rename","renamenx","restore","rpoplpush","sadd","sdiffstore","setbit","setex","setrange","sinterstore","sismember","smove","sort","spop","srem","sunionstore","unwatch","wait","zadd","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrangebyscore","zrem","zremrangebylex","zremrangebyscore","zrevrangebylex","zrevrangebyscore","zrevrank","decr","get","dump","hgetall","hkeys","hlen","hstrlen","hvals","incr","llen","lpop","persist","pttl","rpop","scard","smembers","strlen","ttl","zcard","getset","lpushx","mget","pfcount","sdiff","sinter","sunion","watch","incrby","incrbyfloat","brpop","hget","hmget","hsetnx","msetnx","rpush","hincrbyfloat","srandmember","zrevrange","zscore","command","pop","v","channel","lastRenewal","notifier","onDoneCB","queue","renewalDelay","scope","subscribing","users","subscribeToSelf","notificationCallback","element","isReady","notificationCB","subscribeQuery","interval","setInterval","clearInterval","searchArgs","previous","fetchedDocument","_previous","_next","handleNextSearchResults","currentSearchResults","newSearchResults","cbs","onDone","io","SocketIO","socket","reconnection","forceNew","emit","KuzzleProfile","policies","addPolicy","policy","roleId","setPolicies","map","getPolicies","KuzzleRole","getRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","roleFactory","getProfile","searchProfiles","profiles","createProfile","updateProfile","updatedContent","property","deleteProfile","profileFactory","getUser","searchUsers","createUser","createRestrictedUser","updateUser","deleteUser","userFactory","isActionAllowed","rights","filteredRights","right","item","getUserRights","userId","b","clockseq","_clockseq","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","node","_nodeId","n","_seedBytes","ii"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*! Javascript SDK version 2.3.0 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuid = __webpack_require__(4),\n\t  KuzzleDataCollection = __webpack_require__(7),\n\t  KuzzleSecurity = __webpack_require__(18),\n\t  KuzzleMemoryStorage = __webpack_require__(10),\n\t  KuzzleUser = __webpack_require__(3),\n\t  networkWrapper = __webpack_require__(14);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle object constructor.\n\t *\n\t * @constructor\n\t * @param host - Server name or IP Address to the Kuzzle instance\n\t * @param [options] - Connection options\n\t * @param {responseCallback} [cb] - Handles connection response\n\t * @constructor\n\t */\n\tfunction Kuzzle (host, options, cb) {\n\t  var self = this;\n\t\n\t  if (!(this instanceof Kuzzle)) {\n\t    return new Kuzzle(host, options, cb);\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!host || host === '') {\n\t    throw new Error('host argument missing');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // 'private' properties\n\t    collections: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    connectCB: {\n\t      value: cb\n\t    },\n\t    eventListeners: {\n\t      value: {\n\t        connected: {lastEmitted: null, listeners: []},\n\t        error: {lastEmitted: null, listeners: []},\n\t        disconnected: {lastEmitted: null, listeners: []},\n\t        reconnected: {lastEmitted: null, listeners: []},\n\t        jwtTokenExpired: {lastEmitted: null, listeners: []},\n\t        loginAttempt: {lastEmitted: null, listeners: []},\n\t        offlineQueuePush: {listeners: []},\n\t        offlineQueuePop: {listeners: []},\n\t        queryError: {listeners: []}\n\t      }\n\t    },\n\t    eventTimeout: {\n\t      value: 200\n\t    },\n\t    queuing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    requestHistory: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    state: {\n\t      value: 'initializing',\n\t      writable: true\n\t    },\n\t    subscriptions: {\n\t      /*\n\t       Contains the centralized subscription list in the following format:\n\t          pending: <number of pending subscriptions>\n\t          'roomId': {\n\t            kuzzleRoomID_1: kuzzleRoomInstance_1,\n\t            kuzzleRoomID_2: kuzzleRoomInstance_2,\n\t            kuzzleRoomID_...: kuzzleRoomInstance_...\n\t          }\n\t\n\t       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n\t       This structure also allows renewing subscriptions after a connection loss\n\t       */\n\t      value: {\n\t        pending: {}\n\t      },\n\t      writable: true\n\t    },\n\t    // read-only properties\n\t    autoReconnect: {\n\t      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n\t      enumerable: true\n\t    },\n\t    defaultIndex: {\n\t      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    reconnectionDelay: {\n\t      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n\t      enumerable: true\n\t    },\n\t    host: {\n\t      value: host,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    wsPort: {\n\t      value: (options && typeof options.wsPort === 'number') ? options.wsPort : 7513,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    ioPort: {\n\t      value: (options && typeof options.ioPort === 'number') ? options.ioPort : 7512,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    sslConnection: {\n\t      value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n\t      enumerable: true\n\t    },\n\t    autoQueue: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoReplay: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoResubscribe: {\n\t      value: true,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    metadata: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    /*\n\t      Offline queue use the following format:\n\t            [\n\t              {\n\t                ts: <query timestamp>,\n\t                query: 'query',\n\t                cb: callbackFunction\n\t              }\n\t            ]\n\t     */\n\t    offlineQueue: {\n\t      value: [],\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueFilter: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueMaxSize: {\n\t      value: 500,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueTTL: {\n\t      value: 120000,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    replayInterval: {\n\t      value: 10,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    jwtToken: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    offlineQueueLoader: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (options) {\n\t    Object.keys(options).forEach(function (opt) {\n\t      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n\t        self[opt] = options[opt];\n\t      }\n\t    });\n\t\n\t    if (options.offlineMode === 'auto' && this.autoReconnect) {\n\t      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n\t    }\n\t  }\n\t\n\t  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n\t  Object.defineProperty(this, 'isValid', {\n\t    value: function () {\n\t      if (self.state === 'disconnected') {\n\t        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n\t      }\n\t    }\n\t  });\n\t\n\t  // Helper function copying headers to the query data\n\t  Object.defineProperty(this, 'addHeaders', {\n\t    value: function (query, headers) {\n\t      Object.keys(headers).forEach(function (header) {\n\t        if (!query[header]) {\n\t          query[header] = headers[header];\n\t        }\n\t      });\n\t\n\t      return query;\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n\t   * and is called by these methods\n\t   */\n\t  Object.defineProperty(this, 'callbackRequired', {\n\t    value: function (errorMessagePrefix, callback) {\n\t      if (!callback || typeof callback !== 'function') {\n\t        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Create an attribute security that embed all methods to manage Role, Profile and User\n\t   */\n\t  Object.defineProperty(this, 'security', {\n\t    value: new KuzzleSecurity(this),\n\t    enumerable: true\n\t  });\n\t\n\t  /**\n\t   * Emit an event to all registered listeners\n\t   * An event cannot be emitted multiple times before a timeout has been reached.\n\t   */\n\t  Object.defineProperty(this, 'emitEvent', {\n\t    value: function emitEvent(event) {\n\t      var\n\t        now = Date.now(),\n\t        args = Array.prototype.slice.call(arguments, 1),\n\t        eventProperties = this.eventListeners[event];\n\t\n\t      if (eventProperties.lastEmitted && eventProperties.lastEmitted >= now - this.eventTimeout) {\n\t        return false;\n\t      }\n\t\n\t      eventProperties.listeners.forEach(function (listener) {\n\t        process.nextTick(function () {\n\t          listener.fn.apply(undefined, args);\n\t        });\n\t      });\n\t\n\t      // Events without the 'lastEmitted' property can be emitted without minimum time between emissions\n\t      if (eventProperties.lastEmitted !== undefined) {\n\t        eventProperties.lastEmitted = now;\n\t      }\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'memoryStorage', {\n\t    value: new KuzzleMemoryStorage(this),\n\t    enumerable: true\n\t  });\n\t\n\t\n\t  if (!options || !options.connect || options.connect === 'auto') {\n\t    this.connect();\n\t  } else {\n\t    this.state = 'ready';\n\t  }\n\t\n\t  cleanHistory(this.requestHistory);\n\t\n\t  if (this.bluebird) {\n\t    return this.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n\t          'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n\t          'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n\t          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n\t        ];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Connects to a Kuzzle instance using the provided host name.\n\t * @returns {Object} this\n\t */\n\tKuzzle.prototype.connect = function () {\n\t  var self = this;\n\t\n\t  if (self.network) {\n\t    self.disconnect();\n\t  }\n\t\n\t  self.network = networkWrapper(self.host, self.wsPort, self.ioPort, self.sslConnection);\n\t\n\t  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t    return self;\n\t  }\n\t\n\t  self.state = 'connecting';\n\t  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\t\n\t  self.network.onConnect(function () {\n\t    self.state = 'connected';\n\t    renewAllSubscriptions.call(self);\n\t    dequeue.call(self);\n\t    self.emitEvent('connected');\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t  });\n\t\n\t  self.network.onConnectError(function (error) {\n\t    var connectionError = new Error('Unable to connect to kuzzle proxy server at \"' + self.host + '\"');\n\t\n\t    connectionError.internal = error;\n\t    self.state = 'error';\n\t    self.emitEvent('error', connectionError);\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(connectionError);\n\t    }\n\t  });\n\t\n\t  self.network.onDisconnect(function () {\n\t    self.state = 'offline';\n\t\n\t    if (!self.autoReconnect) {\n\t      self.disconnect();\n\t    }\n\t\n\t    if (self.autoQueue) {\n\t      self.queuing = true;\n\t    }\n\t\n\t    self.emitEvent('disconnected');\n\t  });\n\t\n\t  self.network.onReconnect(function () {\n\t    var reconnect = function () {\n\t      // renew subscriptions\n\t      if (self.autoResubscribe) {\n\t        renewAllSubscriptions.call(self);\n\t      }\n\t\n\t      // replay queued requests\n\t      if (self.autoReplay) {\n\t        cleanQueue.call(self);\n\t        dequeue.call(self);\n\t      }\n\t\n\t      // alert listeners\n\t      self.emitEvent('reconnected');\n\t    };\n\t\n\t    self.state = 'connected';\n\t\n\t    if (self.jwtToken) {\n\t      self.checkToken(self.jwtToken, function (err, res) {\n\t        // shouldn't obtain an error but let's invalidate the token anyway\n\t        if (err || !res.valid) {\n\t          self.jwtToken = undefined;\n\t          self.emitEvent('jwtTokenExpired');\n\t        }\n\t\n\t        reconnect();\n\t      });\n\t    } else {\n\t      reconnect();\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the jwtToken used to query kuzzle\n\t * @param token\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.setJwtToken = function(token) {\n\t  if (typeof token === 'string') {\n\t    this.jwtToken = token;\n\t  } else if (typeof token === 'object') {\n\t    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n\t      this.jwtToken = token.result.jwt;\n\t    } else {\n\t      this.emitEvent('loginAttempt', {\n\t        success: false,\n\t        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n\t      });\n\t\n\t      return this;\n\t    }\n\t  } else {\n\t    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n\t    return this;\n\t  }\n\t\n\t  renewAllSubscriptions.call(this);\n\t  this.emitEvent('loginAttempt', {success: true});\n\t  return this;\n\t};\n\t\n\t/**\n\t * Unset the jwtToken used to query kuzzle\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.unsetJwtToken = function() {\n\t  this.jwtToken = undefined;\n\t\n\t  removeAllSubscriptions.call(this);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Get the jwtToken used by kuzzle\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.getJwtToken = function() {\n\t  return this.jwtToken;\n\t};\n\t\n\t/**\n\t * Send login request to kuzzle with credentials\n\t * If login success, store the jwtToken into kuzzle object\n\t *\n\t * @param strategy\n\t * @param credentials\n\t * @param expiresIn\n\t * @param cb\n\t */\n\tKuzzle.prototype.login = function (strategy) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      strategy: strategy\n\t    },\n\t    credentials,\n\t    cb = null;\n\t\n\t  // Handle arguments (credentials, expiresIn, cb)\n\t  if (arguments[1]) {\n\t    if (typeof arguments[1] === 'object') {\n\t      credentials = arguments[1];\n\t    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n\t      request.expiresIn = arguments[1];\n\t    } else if (typeof arguments[1] === 'function') {\n\t      cb = arguments[1];\n\t    }\n\t  }\n\t  if (arguments[2]) {\n\t    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n\t      request.expiresIn = arguments[2];\n\t    } else if (typeof arguments[2] === 'function') {\n\t      cb = arguments[2];\n\t    }\n\t  }\n\t  if (arguments[3] && typeof arguments[3] === 'function') {\n\t    cb = arguments[3];\n\t  }\n\t\n\t  if (typeof credentials === 'object') {\n\t    Object.keys(credentials).forEach(function (key) {\n\t      request[key] = credentials[key];\n\t    });\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'login'}, {body: request}, {queuable: false}, function(error, response) {\n\t    if (!error) {\n\t      if (response.result.jwt) {\n\t        self.setJwtToken(response.result.jwt);\n\t      }\n\t\n\t      cb && cb(null, response.result);\n\t    }\n\t    else {\n\t      cb && cb(error);\n\t      self.emitEvent('loginAttempt', {success: false, error: error.message});\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Create a kuzzle index\n\t *\n\t * @param {string} index\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.createIndex = function (index, options, cb) {\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.createIndex: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'admin', action: 'createIndex'}, {index: index}, options, typeof cb !== 'function' ? null : cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Send logout request to kuzzle with jwtToken.\n\t *\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.logout = function (cb) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      action: 'logout',\n\t      controller: 'auth',\n\t      requestId: uuid.v4(),\n\t      body: {}\n\t    };\n\t\n\t  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, typeof cb !== 'function' ? null : function(error) {\n\t    cb(error, self);\n\t  });\n\t\n\t  self.unsetJwtToken();\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Checks whether a given jwt token still represents a valid session in Kuzzle.\n\t *\n\t * @param  {string}   token     The jwt token to check\n\t * @param  {function} callback  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t */\n\tKuzzle.prototype.checkToken = function (token, callback) {\n\t  var\n\t    request = {\n\t      body: {\n\t        token: token\n\t      }\n\t    };\n\t\n\t  this.callbackRequired('Kuzzle.checkToken', callback);\n\t\n\t  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, response) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t\n\t    callback(null, response.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Fetches the current user.\n\t *\n\t * @param  {function} callback  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t */\n\tKuzzle.prototype.whoAmI = function (callback) {\n\t  var self = this;\n\t\n\t  self.callbackRequired('Kuzzle.whoAmI', callback);\n\t\n\t  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, response) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t\n\t    callback(null, new KuzzleUser(self.security, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Gets the rights array of the currently logged user.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param  {function} cb The callback containing the normalized array of rights.\n\t */\n\tKuzzle.prototype.getMyRights = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.callbackRequired('Kuzzle.getMyRights', cb);\n\t\n\t  self.query({controller: 'auth', action:'getMyRights'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Update current user in Kuzzle.\n\t *\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Kuzzle} this object\n\t */\n\tKuzzle.prototype.updateSelf = function (content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data.body = content;\n\t\n\t  self.query(queryArgs, data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n\t */\n\tfunction cleanQueue () {\n\t  var\n\t    self = this,\n\t    now = Date.now(),\n\t    lastDocumentIndex = -1;\n\t\n\t  if (self.queueTTL > 0) {\n\t    self.offlineQueue.forEach(function (query, index) {\n\t      if (query.ts < now - self.queueTTL) {\n\t        lastDocumentIndex = index;\n\t      }\n\t    });\n\t\n\t    if (lastDocumentIndex !== -1) {\n\t      self.offlineQueue\n\t        .splice(0, lastDocumentIndex + 1)\n\t        .forEach(function (droppedRequest) {\n\t          self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t        });\n\t    }\n\t  }\n\t\n\t  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n\t    self.offlineQueue\n\t      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n\t      .forEach(function (droppedRequest) {\n\t        self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t      });\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Clean history from requests made more than 10s ago\n\t */\n\tfunction cleanHistory (requestHistory) {\n\t  var\n\t    now = Date.now();\n\t\n\t  Object.keys(requestHistory).forEach(function (key) {\n\t    if (requestHistory[key] < now - 10000) {\n\t      delete requestHistory[key];\n\t    }\n\t  });\n\t\n\t  setTimeout(function () {\n\t    cleanHistory(requestHistory);\n\t  }, 1000);\n\t}\n\t\n\t/**\n\t * Emit a request to Kuzzle\n\t *\n\t * @param {object} request\n\t * @param {responseCallback} [cb]\n\t */\n\tfunction emitRequest (request, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (self.jwtToken !== undefined || cb) {\n\t    self.network.once(request.requestId, function (response) {\n\t      var error = null;\n\t\n\t      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n\t        self.jwtToken = undefined;\n\t        self.emitEvent('jwtTokenExpired', request, cb);\n\t      }\n\t\n\t      if (response.error) {\n\t        error = new Error(response.error.message);\n\t        Object.assign(error, response.error);\n\t        error.status = response.status;\n\t        self.emitEvent('queryError', error, request, cb);\n\t      }\n\t\n\t      if (cb) {\n\t        cb(error, response);\n\t      }\n\t    });\n\t  }\n\t\n\t  this.network.send(request);\n\t\n\t  // Track requests made to allow KuzzleRoom.subscribeToSelf to work\n\t  self.requestHistory[request.requestId] = Date.now();\n\t}\n\t\n\t/**\n\t * Play all queued requests, in order.\n\t */\n\tfunction dequeue () {\n\t  var\n\t    self = this,\n\t    additionalQueue,\n\t    uniqueQueue = {},\n\t    dequeuingProcess = function () {\n\t      if (self.offlineQueue.length > 0) {\n\t        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n\t        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\t\n\t        setTimeout(function () {\n\t          dequeuingProcess();\n\t        }, Math.max(0, self.replayInterval));\n\t      } else {\n\t        self.queuing = false;\n\t      }\n\t    };\n\t\n\t  if (self.offlineQueueLoader) {\n\t    if (typeof self.offlineQueueLoader !== 'function') {\n\t      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n\t    }\n\t\n\t    additionalQueue = self.offlineQueueLoader();\n\t    if (Array.isArray(additionalQueue)) {\n\t      self.offlineQueue = additionalQueue\n\t        .concat(self.offlineQueue)\n\t        .filter(function (request) {\n\t          // throws if the query object does not contain required attributes\n\t          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n\t            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n\t          }\n\t\n\t          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n\t        });\n\t    } else {\n\t      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n\t    }\n\t  }\n\t\n\t  dequeuingProcess();\n\t}\n\t\n\t/**\n\t * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n\t * successful login attempt\n\t */\n\tfunction renewAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.renew(subscription.callback);\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Remove all registered subscriptions. Triggered either by a logout query or by un-setting the token\n\t */\n\tfunction removeAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.unsubscribe();\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n\t * insertion.\n\t *\n\t * The ID returned by this function is required to remove this listener at a later time.\n\t *\n\t * @param {string} event - name of the global event to subscribe to (see the 'eventListeners' object property)\n\t * @param {function} listener - callback to invoke each time an event is fired\n\t * @returns {string} Unique listener ID\n\t */\n\tKuzzle.prototype.addListener = function(event, listener) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    listenerType = typeof listener,\n\t    listenerId;\n\t\n\t  this.isValid();\n\t\n\t  if (knownEvents.indexOf(event) === -1) {\n\t    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t  }\n\t\n\t  if (listenerType !== 'function') {\n\t    throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n\t  }\n\t\n\t  listenerId = uuid.v4();\n\t  this.eventListeners[event].listeners.push({id: listenerId, fn: listener});\n\t  return listenerId;\n\t};\n\t\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method returns all available statistics from Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getAllStatistics = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\t\n\t  this.query({controller:'server', action: 'getAllStats'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n\t *\n\t * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n\t  var\n\t    queryCB,\n\t    body;\n\t\n\t  if (!cb) {\n\t    if (arguments.length === 1) {\n\t      cb = arguments[0];\n\t      options = null;\n\t      timestamp = null;\n\t    } else {\n\t      cb = arguments[1];\n\t      if (typeof arguments[0] === 'object') {\n\t        options = arguments[0];\n\t        timestamp = null;\n\t      } else {\n\t        timestamp = arguments[0];\n\t        options = null;\n\t      }\n\t    }\n\t  }\n\t\n\t  queryCB = function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, timestamp ? res.result.hits : [res.result]);\n\t  };\n\t\n\t  this.callbackRequired('Kuzzle.getStatistics', cb);\n\t\n\t  body = timestamp ? {body: {startTime: timestamp}} : {};\n\t  this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n\t};\n\t\n\t/**\n\t * Create a new instance of a KuzzleDataCollection object.\n\t * If no index is specified, takes the default index.\n\t *\n\t * @param {string} collection - The name of the data collection you want to manipulate\n\t * @param {string} [index] - The name of the data index containing the data collection\n\t * @returns {KuzzleDataCollection} A KuzzleDataCollection instance\n\t */\n\tKuzzle.prototype.dataCollectionFactory = function(collection, index) {\n\t  this.isValid();\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Unable to create a new data collection object: no index specified');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (typeof index !== 'string' || typeof collection !== 'string') {\n\t    throw new Error('Invalid index or collection argument: string expected');\n\t  }\n\t\n\t  if (!this.collections[index]) {\n\t    this.collections[index] = {};\n\t  }\n\t\n\t  if (!this.collections[index][collection]) {\n\t    this.collections[index][collection] = new KuzzleDataCollection(this, collection, index);\n\t  }\n\t\n\t  return this.collections[index][collection];\n\t};\n\t\n\t/**\n\t * Empties the offline queue without replaying it.\n\t *\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.flushQueue = function () {\n\t  this.offlineQueue = [];\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns the list of known persisted data collections.\n\t *\n\t * @param {string} [index] - Index containing collections to be listed\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.listCollections = function () {\n\t  var\n\t    collectionType = 'all',\n\t    index,\n\t    options,\n\t    cb,\n\t    args = Array.prototype.slice.call(arguments),\n\t    query;\n\t\n\t  args.forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.listCollections: index required');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listCollections', cb);\n\t\n\t  if (options && options.type) {\n\t    collectionType = options.type;\n\t  }\n\t\n\t  query = {body: {type: collectionType}};\n\t\n\t  if (options && options.from) {\n\t    query.body.from = options.from;\n\t  }\n\t\n\t  if (options && options.size) {\n\t    query.body.size = options.size;\n\t  }\n\t\n\t  this.query({index: index, controller: 'collection', action: 'list'}, query, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.collections);\n\t  });\n\t};\n\t\n\t/**\n\t * Returns the list of existing indexes in Kuzzle\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.listIndexes = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listIndexes', cb);\n\t\n\t  this.query({controller: 'index', action: 'list'}, {}, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.indexes);\n\t  });\n\t};\n\t\n\t/**\n\t * Disconnects from Kuzzle and invalidate this instance.\n\t */\n\tKuzzle.prototype.disconnect = function () {\n\t  var collection;\n\t\n\t  this.state = 'disconnected';\n\t  this.network.close();\n\t  this.network = null;\n\t\n\t  for (collection in this.collections) {\n\t    if (this.collections.hasOwnProperty(collection)) {\n\t      delete this.collections[collection];\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the server informations\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getServerInfo = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\t\n\t  this.query({controller: 'server', action: 'info'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.serverInfo);\n\t  });\n\t};\n\t\n\t/**\n\t * Forces an index refresh\n\t *\n\t * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.refreshIndex = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.refreshIndex: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.query({ index: index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns de current autoRefresh status for the given index\n\t *\n\t * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optinal arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getAutoRefresh = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.getAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n\t  this.query({ index: index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n\t};\n\t\n\t/**\n\t * (Un)Sets the autoRefresh flag on the given index\n\t *\n\t * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n\t * @param {boolean} autoRefresh - The autoRefresh value to set\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query result\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.setAutoRefresh = function () {\n\t  var\n\t    index,\n\t    autoRefresh,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'boolean':\n\t        autoRefresh = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.setAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (autoRefresh === undefined) {\n\t    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n\t  }\n\t\n\t  this.query({ index: index, controller: 'index', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return the current Kuzzle's UTC Epoch time, in milliseconds\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.now = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.now', cb);\n\t\n\t  this.query({controller: 'server', action: 'now'}, {}, options, function (err, res) {\n\t    cb(err, res && res.result.now);\n\t  });\n\t};\n\t\n\t/**\n\t * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n\t * Base method used to send read queries to Kuzzle\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} queryArgs - Query configuration\n\t * @param {object} query - The query data\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n\t  var\n\t    attr,\n\t    object = {\n\t      action: queryArgs.action,\n\t      controller: queryArgs.controller,\n\t      metadata: this.metadata\n\t    },\n\t    self = this;\n\t\n\t  this.isValid();\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options) {\n\t    if (options.queuable === false && self.state === 'offline') {\n\t      return self;\n\t    }\n\t\n\t    if (options.refresh) {\n\t      object.refresh = options.refresh;\n\t    }\n\t\n\t    if (options.from) {\n\t      object.from = options.from;\n\t    }\n\t\n\t    if (options.size) {\n\t      object.size = options.size;\n\t    }\n\t\n\t    if (options.metadata) {\n\t      Object.keys(options.metadata).forEach(function (meta) {\n\t        object.metadata[meta] = options.metadata[meta];\n\t      });\n\t    }\n\t  }\n\t\n\t  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n\t    throw new Error('Invalid query parameter: ' + query);\n\t  }\n\t\n\t  if (query.metadata) {\n\t    Object.keys(query.metadata).forEach(function (meta) {\n\t      object.metadata[meta] = query.metadata[meta];\n\t    });\n\t  }\n\t\n\t  for (attr in query) {\n\t    if (attr !== 'metadata' && query.hasOwnProperty(attr)) {\n\t      object[attr] = query[attr];\n\t    }\n\t  }\n\t\n\t  object = self.addHeaders(object, this.headers);\n\t\n\t  /*\n\t   * Do not add the token for the checkToken route, to avoid getting a token error when\n\t   * a developer simply wish to verify his token\n\t   */\n\t  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n\t    object.jwt = self.jwtToken;\n\t  }\n\t\n\t  if (queryArgs.collection) {\n\t    object.collection = queryArgs.collection;\n\t  }\n\t\n\t  if (queryArgs.index) {\n\t    object.index = queryArgs.index;\n\t  }\n\t\n\t  if (!object.requestId) {\n\t    object.requestId = uuid.v4();\n\t  }\n\t\n\t  if (self.state === 'connected' || (options && options.queuable === false)) {\n\t    if (self.state === 'connected') {\n\t      emitRequest.call(this, object, cb);\n\t    } else if (cb) {\n\t      cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n\t    }\n\t  } else if (self.queuing || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n\t    cleanQueue.call(this, object, cb);\n\t\n\t    if (!self.queueFilter || self.queueFilter(object)) {\n\t      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n\t      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n\t    }\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Removes all listeners, either from a specific event or from all events\n\t *\n\t * @param {string} event - One of the event described in the Event Handling section of this documentation\n\t * @returns {Kuzzle} this object\n\t */\n\tKuzzle.prototype.removeAllListeners = function (event) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    self = this;\n\t\n\t  if (event) {\n\t    if (knownEvents.indexOf(event) === -1) {\n\t      throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t    }\n\t\n\t    this.eventListeners[event].listeners = [];\n\t  } else {\n\t    knownEvents.forEach(function (eventName) {\n\t      self.eventListeners[eventName].listeners = [];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Removes a listener from an event.\n\t *\n\t * @param {string} event - One of the event described in the Event Handling section of this documentation\n\t * @param {string} listenerId - The ID returned by addListener\n\t * @returns {Kuzzle} this object\n\t */\n\tKuzzle.prototype.removeListener = function (event, listenerId) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    self = this;\n\t\n\t  if (knownEvents.indexOf(event) === -1) {\n\t    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t  }\n\t\n\t  this.eventListeners[event].listeners.forEach(function (listener, index) {\n\t    if (listener.id === listenerId) {\n\t      self.eventListeners[event].listeners.splice(index, 1);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replays the requests queued during offline mode.\n\t * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n\t */\n\tKuzzle.prototype.replayQueue = function () {\n\t  if (this.state !== 'offline' && !this.autoReplay) {\n\t    cleanQueue.call(this);\n\t    dequeue.call(this);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the default Kuzzle index\n\t *\n\t * @param index\n\t * @returns this\n\t */\n\tKuzzle.prototype.setDefaultIndex = function (index) {\n\t  if (typeof index !== 'string') {\n\t    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n\t  }\n\t\n\t  if (index.length === 0) {\n\t    throw new Error('Cannot set an empty index as the default index');\n\t  }\n\t\n\t  this.defaultIndex = index;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzle.prototype.setHeaders = function (content, replace) {\n\t  var self = this;\n\t\n\t  if (typeof content !== 'object' || Array.isArray(content)) {\n\t    throw new Error('Expected a content object, received a ' + typeof content);\n\t  }\n\t\n\t  if (replace) {\n\t    self.headers = content;\n\t  } else {\n\t    Object.keys(content).forEach(function (key) {\n\t      self.headers[key] = content[key];\n\t    });\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.startQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = true;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.stopQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = false;\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = Kuzzle;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tfunction KuzzleSecurityDocument(kuzzleSecurity, id, content) {\n\t\n\t  if (!id) {\n\t    throw new Error('A security document must have an id');\n\t  }\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    kuzzle: {\n\t      value: kuzzleSecurity.kuzzle\n\t    },\n\t    kuzzleSecurity: {\n\t      value: kuzzleSecurity\n\t    },\n\t    // read-only properties\n\t    // writable properties\n\t    id: {\n\t      value: id,\n\t      enumerable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (content) {\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'update'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {Object} data - New securityDocument content\n\t * @return {KuzzleSecurityDocument} this\n\t */\n\tKuzzleSecurityDocument.prototype.setContent = function (data) {\n\t  this.content = data;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a pojo\n\t *\n\t * @return {object} pojo representing this securityDocument\n\t */\n\tKuzzleSecurityDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Delete the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleSecurityDocument.prototype.delete = function (options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, res.result._id);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} content - Content to add to KuzzleSecurityDocument\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurityDocument} this\n\t */\n\tKuzzleSecurityDocument.prototype.update = function (content, options, cb) {\n\t  var\n\t    data = {},\n\t    self = this;\n\t\n\t  if (typeof content !== 'object') {\n\t    throw new Error('Parameter \"content\" must be a object');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = self.id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.setContent(response.result._source);\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleSecurityDocument;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tfunction WSNode(host, port, ssl) {\n\t  var self = this;\n\t  this.WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"ws\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t  this.host = host;\n\t  this.port = port;\n\t  this.ssl = ssl;\n\t  this.client = null;\n\t  this.wasConnected = false;\n\t  this.retrying = false;\n\t  this.lasturl = null;\n\t\n\t  /*\n\t   Listeners are stored using the following format:\n\t   roomId: {\n\t   fn: callback_function,\n\t   once: boolean\n\t   }\n\t   */\n\t  this.listeners = {\n\t    error: [],\n\t    connect: [],\n\t    disconnect: [],\n\t    reconnect: []\n\t  };\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   * @returns {Object} Socket\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    var\n\t      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n\t      options = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\t\n\t    if (url !== this.lasturl) {\n\t      self.wasConnected = false;\n\t      this.lasturl = url;\n\t    }\n\t\n\t    this.client = new this.WebSocket(url, options);\n\t\n\t    this.client.onopen = function () {\n\t      if (self.wasConnected) {\n\t        poke(self.listeners, 'reconnect');\n\t      }\n\t      else {\n\t        poke(self.listeners, 'connect');\n\t      }\n\t      self.wasConnected = true;\n\t    };\n\t\n\t    this.client.onclose = function (code, message) {\n\t      if (code === 1000) {\n\t        poke(self.listeners, 'disconnect');\n\t      }\n\t      else {\n\t        onClientError.call(self, autoReconnect, reconnectionDelay, message);\n\t      }\n\t    };\n\t\n\t    this.client.onerror = function (error) {\n\t      onClientError.call(self, autoReconnect, reconnectionDelay, error);\n\t    };\n\t\n\t    this.client.onmessage = function (payload) {\n\t      var data = JSON.parse(payload.data || payload);\n\t\n\t      if (data.room && self.listeners[data.room]) {\n\t        poke(self.listeners, data.room, data);\n\t      }\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    this.listeners.connect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    this.listeners.error.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    this.listeners.disconnect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    this.listeners.reconnect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room. Once 1 message is received, fires the\n\t   * callback and unregister it afterward.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.once = function (roomId, callback) {\n\t    if (!this.listeners[roomId]) {\n\t      this.listeners[roomId] = [];\n\t    }\n\t\n\t    this.listeners[roomId].push({\n\t      fn: callback,\n\t      keep: false\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.on = function (roomId, callback) {\n\t    if (!this.listeners[roomId]) {\n\t      this.listeners[roomId] = [];\n\t    }\n\t\n\t    this.listeners[roomId].push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Unregisters a callback from a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.off = function (roomId, callback) {\n\t    var index = -1;\n\t\n\t    if (this.listeners[roomId]) {\n\t      // Array.findIndex is not supported by internet explorer\n\t      this.listeners[roomId].some(function (listener, i) {\n\t        if (listener.fn === callback) {\n\t          index = i;\n\t          return true;\n\t        }\n\t\n\t        return false;\n\t      });\n\t\n\t      if (index !== -1) {\n\t        if (this.listeners[roomId].length === 1 && ['error', 'connect', 'disconnect', 'reconnect'].indexOf(roomId) === -1) {\n\t          delete this.listeners[roomId];\n\t        }\n\t        else {\n\t          this.listeners[roomId].splice(index, 1);\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    if (this.client && this.client.readyState === this.client.OPEN) {\n\t      this.client.send(JSON.stringify(payload));\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.listeners = {\n\t      error: [],\n\t      connect: [],\n\t      disconnect: [],\n\t      reconnect: []\n\t    };\n\t\n\t    this.wasConnected = false;\n\t    this.client.close();\n\t    this.client = null;\n\t  };\n\t}\n\t\n\t/**\n\t * Executes all registered listeners in the provided\n\t * \"listeners\" structure.\n\t *\n\t * Listeners are of the following format:\n\t * [\n\t *    { fn: callback, once: boolean },\n\t *    ...\n\t * ]\n\t *\n\t * @private\n\t * @param {Object} listeners\n\t * @param {string} roomId\n\t * @param {Object} [payload]\n\t */\n\tfunction poke (listeners, roomId, payload) {\n\t  var\n\t    i,\n\t    length = listeners[roomId].length;\n\t\n\t  for (i = 0; i < length; ++i) {\n\t    listeners[roomId][i].fn(payload);\n\t\n\t    if (!listeners[roomId][i].keep) {\n\t      if (listeners[roomId].length > 1) {\n\t        listeners[roomId].splice(i, 1);\n\t        --i;\n\t        --length;\n\t      }\n\t      else {\n\t        delete listeners[roomId];\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Called when the connection closes with an error state\n\t *\n\t * @param {boolean} autoReconnect\n\t * @param {number} reconnectionDelay\n\t * @param {string|Object} message\n\t */\n\tfunction onClientError(autoReconnect, reconnectionDelay, message) {\n\t  var self = this;\n\t\n\t  if (autoReconnect && !self.retrying) {\n\t    self.retrying = true;\n\t    setTimeout(function () {\n\t      self.retrying = false;\n\t      self.connect(autoReconnect, reconnectionDelay);\n\t    }, reconnectionDelay);\n\t  }\n\t\n\t  poke(self.listeners, 'error', message);\n\t}\n\t\n\tmodule.exports = WSNode;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\t/**\n\t * @param {KuzzleSecurity} kuzzleSecurity\n\t * @param {string} id\n\t * @param {Object} content\n\t * @constructor\n\t */\n\tfunction KuzzleUser(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteUser'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateUser'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save', 'saveRestricted'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tKuzzleUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleUser\n\t  }\n\t});\n\t\n\t/**\n\t * Set profiles in content\n\t * @param {array} profileIds - an array of profiles ids string\n\t *\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.setProfiles = function (profileIds) {\n\t  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n\t    throw new Error('Parameter \"profileIds\" must be an array of strings');\n\t  }\n\t\n\t  this.content.profileIds = profileIds;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a profile\n\t * @param {string} profileId - a profile ids string\n\t *\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.addProfile = function (profileId) {\n\t  if (typeof profileId !== 'string') {\n\t    throw new Error('Parameter \"profileId\" must be a string');\n\t  }\n\t\n\t  if (!this.content.profileIds) {\n\t    this.content.profileIds = [];\n\t  }\n\t\n\t  if (this.content.profileIds.indexOf(profileId) === -1) {\n\t    this.content.profileIds.push(profileId);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Saves this user into Kuzzle.\n\t *\n\t * If this is a new user, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this user in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Saves this user as restricted into Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.saveRestricted = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tKuzzleUser.prototype.serialize = function () {\n\t  return {_id: this.id, body: this.content};\n\t};\n\t\n\t/**\n\t * Return the associated profiles IDs\n\t *\n\t * @return {array} the associated profiles IDs\n\t */\n\tKuzzleUser.prototype.getProfiles = function () {\n\t  return this.content.profileIds;\n\t};\n\t\n\tmodule.exports = KuzzleUser;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar v1 = __webpack_require__(19);\n\tvar v4 = __webpack_require__(20);\n\t\n\tvar uuid = v4;\n\tuuid.v1 = v1;\n\tuuid.v4 = v4;\n\t\n\tmodule.exports = uuid;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return  bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\tvar rng;\n\t\n\tvar crypto = (window).crypto || (window).msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16);\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var  rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSearchResult = __webpack_require__(12),\n\t  KuzzleDocument = __webpack_require__(9),\n\t  KuzzleDataMapping = __webpack_require__(8),\n\t  KuzzleRoom = __webpack_require__(11),\n\t  KuzzleSubscribeResult = __webpack_require__(13);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n\t * or like a room for pub/sub messages.\n\t *\n\t * @property {string} collection\n\t * @property {string} index\n\t * @property {Kuzzle} kuzzle\n\t * @property {Array.<string>} collection\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @param {string} collection - name of the data collection to handle\n\t * @param {string} index - Index containing the data collection\n\t * @constructor\n\t */\n\tfunction KuzzleDataCollection(kuzzle, collection, index) {\n\t  if (!index || !collection) {\n\t    throw new Error('The KuzzleDataCollection object constructor needs an index and a collection arguments');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    index: {\n\t      value: index,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (controller, action) {\n\t      return {\n\t        controller: controller,\n\t        action: action,\n\t        collection: this.collection,\n\t        index: this.index\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of documents matching the provided set of filters.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleDataCollection.prototype.count = function (filters, options, cb) {\n\t  var\n\t    query;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.count', cb);\n\t\n\t  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (error, result) {\n\t    cb(error, result && result.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new empty data collection, with no associated mapping.\n\t * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n\t * want to create and prepare data collections before storing documents in it.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.create = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *    - updateIfExist (boolean, default: false):\n\t *        If the same document already exists: throw an error if sets to false.\n\t *        Update the existing document otherwise\n\t *\n\t * @param {string} [id] - (optional) document identifier\n\t * @param {object} document - either an instance of a KuzzleDocument object, or a document\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.createDocument = function (id, document, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'create';\n\t\n\t  if (id && typeof id !== 'string') {\n\t    cb = options;\n\t    options = document;\n\t    document = id;\n\t    id = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (document instanceof KuzzleDocument) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  if (options) {\n\t    action = options.updateIfExist ? 'createOrReplace' : 'create';\n\t  }\n\t\n\t  if (id) {\n\t    data._id = id;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, self.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    var doc;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    doc = new KuzzleDocument(self, res.result._id, res.result._source);\n\t    doc.version = res.result._version;\n\t    cb(null, doc);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete persistent documents.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleDataCollection} this\n\t */\n\tKuzzleDataCollection.prototype.deleteDocument = function (arg, options, cb) {\n\t  var\n\t    action,\n\t    data = {};\n\t\n\t  if (typeof arg === 'string') {\n\t    data._id = arg;\n\t    action = 'delete';\n\t  } else {\n\t    data.body = arg;\n\t    action = 'deleteByQuery';\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      cb(err);\n\t    }\n\t    else {\n\t      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieve a single stored document using its unique document ID.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleDataCollection.prototype.fetchDocument = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleDataCollection.fetch', cb);\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new KuzzleDocument(self, res.result._id, res.result._source);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieves all documents stored in this data collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleDataCollection.prototype.fetchAllDocuments = function (options, cb) {\n\t  var\n\t    warnEmitted = false,\n\t    documents = [],\n\t    filters = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  // copying pagination options to the search filter\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t\n\t  if (!options.from) {\n\t    options.from = 0;\n\t  }\n\t\n\t  if (!options.size) {\n\t    options.size = 1000;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.fetchAllDocuments', cb);\n\t\n\t  this.search(filters, options, function getNextDocuments (error, searchResult) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    if (searchResult instanceof KuzzleSearchResult) {\n\t      if (searchResult.total > 10000 && !warnEmitted) {\n\t        warnEmitted = true;\n\t        console.warn('KuzzleDataCollection.fetchAllDocuments may return extremely large amounts of documents, which may cause performance issues. Unless you know what you are doing, consider using KuzzleDataCollection.search or KuzzleDataCollection.scroll instead'); // eslint-disable-line no-console\n\t      }\n\t\n\t      searchResult.documents.forEach(function (document) {\n\t        documents.push(document);\n\t      });\n\t      searchResult.next(getNextDocuments);\n\t    }\n\t    else {\n\t      cb(null, documents);\n\t    }\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Instantiates a KuzzleDataMapping object containing the current mapping of this collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated KuzzleDataMapping object\n\t */\n\tKuzzleDataCollection.prototype.getMapping = function (options, cb) {\n\t  var kuzzleMapping;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.getMapping', cb);\n\t\n\t  kuzzleMapping = new KuzzleDataMapping(this);\n\t  kuzzleMapping.refresh(options, cb);\n\t};\n\t\n\t/**\n\t * Publish a realtime message\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} document - either a KuzzleDocument instance or a JSON object\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.publishMessage = function (document, options, cb) {\n\t  var data = {};\n\t\n\t  if (document instanceof KuzzleDocument) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replace an existing document with a new one.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to replace\n\t * @param {object} content - JSON object representing the new document version\n\t * @param {object} [options] - additional arguments\n\t * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n\t * @return {object} this\n\t */\n\tKuzzleDataCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new KuzzleDocument(self, res.result._id, res.result._source);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Executes an advanced search on the data collection.\n\t *\n\t * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function.\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\t\n\tKuzzleDataCollection.prototype.search = function (filters, options, cb) {\n\t  var\n\t    query,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleDataCollection.search', cb);\n\t\n\t  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      result.result.aggregations ? result.result.aggregations : [],\n\t      {options: options, filters: filters}\n\t    ));\n\t  });\n\t};\n\t\n\t/**\n\t * A \"scroll\" option can be passed to search queries, creating persistent\n\t * paginated results.\n\t * This method can be used to manually get the next page of a search result,\n\t * instead of using KuzzleSearchResult.next()\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {object} [filters]\n\t * @param {responseCallback} cb\n\t */\n\tKuzzleDataCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n\t  var\n\t    request = {body: {}},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('KuzzleDataCollection.scroll: scrollId required');\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t\n\t  options.scrollId = scrollId;\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.scroll', cb);\n\t\n\t  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      result.result.aggregations ? result.result.aggregations : [],\n\t      {options: options, filters: filters}\n\t    ));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Subscribes to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @param {responseCallback} cb - called for each new notification\n\t * @returns {*} KuzzleSubscribeResult object\n\t */\n\tKuzzleDataCollection.prototype.subscribe = function (filters, options, cb) {\n\t  var\n\t    room,\n\t    subscribeResult;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.subscribe', cb);\n\t\n\t  subscribeResult = new KuzzleSubscribeResult();\n\t  room = new KuzzleRoom(this, options);\n\t\n\t  room.renew(filters, cb, subscribeResult.done.bind(subscribeResult));\n\t\n\t  return subscribeResult;\n\t};\n\t\n\t/**\n\t * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n\t * This method is a lot faster than removing all documents using a query.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.truncate = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Update parts of a document\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to update\n\t * @param {object} content - JSON object containing changes to perform on the document\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n\t * @return {object} this\n\t */\n\tKuzzleDataCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n\t  var\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    (new KuzzleDocument(self, res.result._id)).refresh(cb);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Instantiate a new KuzzleDocument object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - document id\n\t * @param {object} content - document content\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.documentFactory = function (id, content) {\n\t  return new KuzzleDocument(this, id, content);\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleRoom object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [options] - subscription configuration\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.roomFactory = function (options) {\n\t  return new KuzzleRoom(this, options);\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleDataMapping object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [mapping] - mapping to instantiate the KuzzleDataMapping object with\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.dataMappingFactory = function (mapping) {\n\t  return new KuzzleDataMapping(this, mapping);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDataCollection.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleDataCollection;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n\t *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n\t *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n\t *  the amount of data you stored in a collection and the complexity of your database.\n\t *\n\t *  The KuzzleDataMapping object allow to get the current mapping of a data collection and to modify it if needed.\n\t *\n\t * @param {object} kuzzleDataCollection - Instance of the inherited KuzzleDataCollection object\n\t * @param {object} [mapping] - mappings\n\t * @constructor\n\t */\n\tfunction KuzzleDataMapping(kuzzleDataCollection, mapping) {\n\t  Object.defineProperties(this, {\n\t    //read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    mapping: {\n\t      value: mapping || {},\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['set', 'setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Applies the new mapping to the data collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleDataMapping.prototype.apply = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n\t    if (err) {\n\t      return cb && cb(err);\n\t    }\n\t\n\t    self.refresh(options, cb);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with the mapping stored in Kuzzle\n\t *\n\t * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDataMapping.prototype.refresh = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    if (res.result[self.collection.index]) {\n\t      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n\t        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\t\n\t        // Mappings can be empty. The mapping property should never be \"undefined\"\n\t        if (self.mapping === undefined) {\n\t          self.mapping = {};\n\t        }\n\t      } else {\n\t        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n\t      }\n\t    } else {\n\t      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds or updates a field mapping.\n\t *\n\t * Changes made by this function wont be applied until you call the apply method\n\t *\n\t * @param {string} field - Name of the field from which the mapping is to be added or updated\n\t * @param {object} mapping - corresponding field mapping\n\t * @returns {KuzzleDataMapping}\n\t */\n\tKuzzleDataMapping.prototype.set = function (field, mapping) {\n\t  this.mapping[field] = mapping;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDataMapping.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleDataMapping;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle handles documents either as realtime messages or as stored documents.\n\t * KuzzleDocument is the object representation of one of these documents.\n\t *\n\t * Notes:\n\t *   - this constructor may be called either with a documentId, a content, neither or both.\n\t *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n\t *\n\t *\n\t * @param {object} kuzzleDataCollection - an instanciated KuzzleDataCollection object\n\t * @param {string} [documentId] - ID of an existing document\n\t * @param {object} [content] - Initializes this document with the provided content\n\t * @constructor\n\t */\n\tfunction KuzzleDocument(kuzzleDataCollection, documentId, content) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection.collection,\n\t      enumerable: true\n\t    },\n\t    dataCollection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    id: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    version: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  // handling provided arguments\n\t  if (!content && documentId && typeof documentId === 'object') {\n\t    content = documentId;\n\t    documentId = null;\n\t  }\n\t\n\t  if (content) {\n\t    if (content._version) {\n\t      this.version = content._version;\n\t      delete content._version;\n\t    }\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  if (documentId) {\n\t    Object.defineProperty(this, 'id', {\n\t      value: documentId,\n\t      enumerable: true\n\t    });\n\t  }\n\t\n\t  // promisifying\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'refresh', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this document\n\t */\n\tKuzzleDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data._version = this.version;\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Overrides the toString() method in order to return a serialized version of the document\n\t *\n\t * @return {string} serialized version of this object\n\t */\n\tKuzzleDocument.prototype.toString = function () {\n\t  return JSON.stringify(this.serialize());\n\t};\n\t\n\t/**\n\t * Deletes this document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.delete = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('KuzzleDocument.delete: cannot delete a document without a document ID');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n\t    cb(err, err ? undefined : self.id);\n\t  });\n\t};\n\t\n\t/**\n\t * Replaces the current content with the last version of this document stored in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.refresh = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('KuzzleDocument.refresh: cannot retrieve a document if no ID has been provided');\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDocument.refresh', cb);\n\t\n\t  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n\t    var newDocument;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    newDocument = new KuzzleDocument(self.dataCollection, self.id, res.result._source);\n\t    newDocument.version = res.result._version;\n\t\n\t    cb(null, newDocument);\n\t  });\n\t};\n\t\n\t/**\n\t * Saves this document into Kuzzle.\n\t *\n\t * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n\t * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n\t    if (error) {\n\t      return cb && cb(error);\n\t    }\n\t\n\t    self.id = res.result._id;\n\t    self.version = res.result._version;\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Sends the content of this document as a realtime message.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.publish = function (options) {\n\t  var data = this.serialize();\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {object} data - New content\n\t * @param {boolean} replace - if true: replace this document content with the provided data\n\t */\n\tKuzzleDocument.prototype.setContent = function (data, replace) {\n\t  var self = this;\n\t\n\t  if (replace) {\n\t    this.content = data;\n\t  }\n\t  else {\n\t    Object.keys(data).forEach(function (key) {\n\t      self.content[key] = data[key];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Listens to events concerning this document. Has no effect if the document does not have an ID\n\t * (i.e. if the document has not yet been created as a persisted document).\n\t *\n\t * @param {object} [options] - subscription options\n\t * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n\t */\n\tKuzzleDocument.prototype.subscribe = function (options, cb) {\n\t  var filters;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDocument.subscribe', cb);\n\t\n\t  if (!this.id) {\n\t    throw new Error('KuzzleDocument.subscribe: cannot subscribe to a document if no ID has been provided');\n\t  }\n\t\n\t  filters = { ids: { values: [this.id] } };\n\t\n\t  return this.dataCollection.subscribe(filters, options, cb);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDocument.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t\n\tmodule.exports = KuzzleDocument;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t * Kuzzle's memory storage is a separate data store from the database layer.\n\t * It is internaly based on Redis. You can access most of Redis functions (all\n\t * lowercased), excepting:\n\t *   * all cluster based functions\n\t *   * all script based functions\n\t *   * all cursors functions\n\t *\n\t * For instance:\n\t *     kuzzle.memoryStorage\n\t *      .set('myKey', 'myValue')\n\t *      .get('myKey', function (err, response) {\n\t *        console.log(response.result);\n\t *\n\t *        // { _id: 'foo', body: { value: 'myValue' }}\n\t *      });\n\t *\n\t *\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @constructor\n\t */\n\tfunction KuzzleMemoryStorage(kuzzle) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  this.setHeaders = kuzzle.setHeaders.bind(this);\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * constructs the memoryStorage functions.\n\t */\n\t(function() {\n\t\n\t  var\n\t    keyVal = ['id', 'value'],\n\t    idOrKeys = ['id', 'keys'],\n\t    commands = {\n\t      append: keyVal,\n\t      bgrewriteaof: [],\n\t      bgsave: [],\n\t      bitcount: ['id', 'start', 'end'],\n\t      bitop: ['operation', 'destkey', idOrKeys],\n\t      bitpos: ['id', 'bit', { __opts__: ['start', 'end']}],\n\t      blpop: [idOrKeys, 'timeout'],\n\t      brpoplpush: ['source', 'destination'],\n\t      dbsize: [],\n\t      decrby: keyVal,\n\t      del: [idOrKeys],\n\t      discard: [],\n\t      exec: [],\n\t      exists: [idOrKeys],\n\t      expire: ['id', 'seconds'],\n\t      expireat: ['id', 'timestamp'],\n\t      flushdb: [],\n\t      // @todo: implement geolocation methods once available in Redis stable release\n\t      getbit: ['id', 'offset'],\n\t      getrange: ['id', 'start', 'end'],\n\t      hdel: ['id', ['field', 'fields']],\n\t      hexists: ['id', 'field'],\n\t      hincrby: ['id', 'field', 'value'],\n\t      hmset: ['id', 'values'],\n\t      hset: ['id', 'field', 'value'],\n\t      info: ['section'],\n\t      keys: [ 'pattern' ],\n\t      lastsave: [],\n\t      lindex: ['id', 'idx'],\n\t      linsert: ['id', 'position', 'pivot', 'value'],\n\t      lpush: ['id', ['value', 'values']],\n\t      lrange: ['id', 'start', 'stop'],\n\t      lrem: ['id', 'count', 'value'],\n\t      lset: ['id', 'idx', 'value'],\n\t      ltrim: ['id', 'start', 'stop'],\n\t      mset: ['values'],\n\t      multi: [],\n\t      object: ['subcommand', 'args'],\n\t      pexpire: ['id', 'milliseconds'],\n\t      pexpireat: ['id', 'timestamp'],\n\t      pfadd: ['id', ['element', 'elements']],\n\t      pfmerge: ['destkey', ['sourcekey', 'sourcekeys']],\n\t      ping: [],\n\t      psetex: ['id', 'milliseconds', 'value'],\n\t      publish: ['channel', 'message'],\n\t      randomkey: [],\n\t      rename: ['id', 'newkey'],\n\t      renamenx: ['id', 'newkey'],\n\t      restore: ['id', 'ttl', 'content'],\n\t      rpoplpush: ['source', 'destination'],\n\t      sadd: ['id', ['member', 'members']],\n\t      save: [],\n\t      set: ['id', 'value', {__opts__:['ex', 'px', 'nx', 'xx']}],\n\t      sdiffstore: ['destination', idOrKeys],\n\t      setbit: ['id', 'offset', 'value'],\n\t      setex: ['id', 'seconds', 'value'],\n\t      setrange: ['id', 'offset', 'value'],\n\t      sinterstore: ['destination', idOrKeys],\n\t      sismember: ['id', 'member'],\n\t      smove: ['id', 'destination', 'member'],\n\t      sort: ['id', {__opts__:['by', 'offset', 'count', 'get', 'direction', 'alpha', 'store']}],\n\t      spop: ['id', 'count'],\n\t      srem: ['id', ['member', 'members']],\n\t      sunionstore: ['destination', idOrKeys],\n\t      unwatch: [],\n\t      wait: ['numslaves', 'timeout'],\n\t      zadd: ['id', {__opts__: ['nx', 'xx', 'ch', 'incr', 'score', 'member', 'members']}],\n\t      zcount: ['id', 'min', 'max'],\n\t      zincrby: ['id', 'value', 'member'],\n\t      zinterstore: ['destination', idOrKeys, {__opts__: ['weight', 'weights', 'aggregate']}],\n\t      zlexcount: ['id', 'min', 'max'],\n\t      zrange: ['id', 'start', 'stop', {__opts__: ['withscores']}],\n\t      zrangebylex: ['id', 'min', 'max', {__opts__: ['offset', 'count']}],\n\t      zrangebyscore: ['id', 'min', 'max', {__opts__: ['withscores', 'offset', 'count']}],\n\t      zrem: ['id', 'member'],\n\t      zremrangebylex: ['id', 'min', 'max'],\n\t      zremrangebyscore: ['id', 'min', 'max'],\n\t      zrevrangebylex: ['id', 'max', 'min', {__opts__: ['offset', 'count']}],\n\t      zrevrangebyscore: ['id', 'max', 'min', {__opts__: ['withscores', 'offset', 'count']}],\n\t      zrevrank: ['id', 'member']\n\t    };\n\t\n\t  // unique argument key\n\t  commands.decr = commands.get = commands.dump = commands.hgetall = commands.hkeys = commands.hlen = commands.hstrlen = commands.hvals = commands.incr = commands.llen = commands.lpop = commands.persist = commands.pttl = commands.rpop = commands.scard = commands.smembers = commands.strlen = commands.ttl = commands.type = commands.zcard = ['id'];\n\t\n\t  // key value\n\t  commands.getset = commands.lpushx = keyVal;\n\t\n\t  // key key...\n\t  commands.del = commands.exists = commands.mget = commands.pfcount = commands.sdiff = commands.sinter = commands.sunion = commands.watch = [idOrKeys];\n\t\n\t  commands.incrby = commands.incrbyfloat = commands.decrby;\n\t  commands.brpop = commands.blpop;\n\t  commands.hget = commands.hexists;\n\t  commands.hmget = commands.hdel;\n\t  commands.hsetnx = commands.hset;\n\t  commands.msetnx = commands.mset;\n\t  commands.rpush = commands.lpush;\n\t  commands.hincrbyfloat = commands.hincrby;\n\t  commands.srandmember = commands.spop;\n\t  commands.zrevrange = commands.zrange;\n\t  commands.zscore = commands.zrevrank;\n\t\n\t  Object.keys(commands).forEach(function (command) {\n\t    KuzzleMemoryStorage.prototype[command] = function () {\n\t      var\n\t        args = Array.prototype.slice.call(arguments),\n\t        options = null,\n\t        cb,\n\t        query = {\n\t          controller: 'ms',\n\t          action: command\n\t        },\n\t        data = {};\n\t\n\t      if (typeof args[args.length - 1] === 'function') {\n\t        cb = args.pop();\n\t      }\n\t\n\t      if (args.length && typeof args[args.length - 1] === 'object' && Object.keys(args[args.length - 1]).length === 1 && args[args.length - 1].queuable !== undefined) {\n\t        options = args.pop();\n\t      }\n\t\n\t      commands[command].forEach(function (v, i) {\n\t        if (args[i] === undefined) {\n\t          return;\n\t        }\n\t\n\t        if (Array.isArray(v)) {\n\t          v = Array.isArray(args[i]) ? v[1] : v[0];\n\t        }\n\t\n\t        if (v === 'id') {\n\t          data._id = args[i];\n\t        }\n\t        else {\n\t          if (!data.body) {\n\t            data.body = {};\n\t          }\n\t\n\t          if (typeof v === 'object' && v.__opts__ !== undefined) {\n\t            v.__opts__.forEach(function (arg) {\n\t              if (args[i][arg] !== undefined) {\n\t                data.body[arg] = args[i][arg];\n\t              }\n\t            });\n\t          }\n\t          else {\n\t            data.body[v] = args[i];\n\t          }\n\t        }\n\t      });\n\t\n\t      this.kuzzle.query(query, data, options, cb);\n\t\n\t      return this;\n\t\n\t    };\n\t  });\n\t\n\t})();\n\t\n\tmodule.exports = KuzzleMemoryStorage;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuid = __webpack_require__(4);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n\t *\n\t * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n\t *\n\t * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n\t * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n\t * document change (because it is created, updated or deleted), then youll receive a notification about it.\n\t *\n\t * @param {object} kuzzleDataCollection - an instantiated and valid kuzzle object\n\t * @param {object} [options] - subscription optional configuration\n\t * @constructor\n\t */\n\tfunction KuzzleRoom(kuzzleDataCollection, options) {\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    callback: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    channel: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    id: {\n\t      value: uuid.v4()\n\t    },\n\t    lastRenewal: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    notifier: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    onDoneCB: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    queue: {\n\t      value: [],\n\t      writable: true\n\t    },\n\t    // Delay before allowing a subscription renewal\n\t    renewalDelay: {\n\t      value: 500\n\t    },\n\t    scope: {\n\t      value: options && options.scope ? options.scope : 'all'\n\t    },\n\t    state: {\n\t      value: options && options.state ? options.state : 'done'\n\t    },\n\t    subscribing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    users: {\n\t      value: options && options.users ? options.users : 'none'\n\t    },\n\t    // read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    filters: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    metadata: {\n\t      value: (options && options.metadata) ? options.metadata : {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    roomId: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    subscribeToSelf: {\n\t      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['count'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of other subscriptions on that room.\n\t *\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleRoom.prototype.count = function (cb) {\n\t  var data;\n\t\n\t  this.kuzzle.callbackRequired('KuzzleRoom.count', cb);\n\t\n\t  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\t\n\t  if (!isReady.call(this)) {\n\t    this.queue.push({action: 'count', args: [cb]});\n\t    return;\n\t  }\n\t\n\t  if (!this.roomId) {\n\t    throw new Error('KuzzleRoom.count: cannot count subscriptions on an inactive room');\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n\t    cb(err, res && res.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Renew the subscription using new filters\n\t *\n\t * @param {object} [filters] - Filters in Kuzzle DSL format\n\t * @param {responseCallback} notificationCB - called for each new notification\n\t * @param {responseCallback} [cb] - handles the query response\n\t */\n\tKuzzleRoom.prototype.renew = function (filters, notificationCB, cb) {\n\t  var\n\t    now = Date.now(),\n\t    subscribeQuery = {\n\t      scope: this.scope,\n\t      state: this.state,\n\t      users: this.users\n\t    },\n\t    self = this;\n\t\n\t  if (typeof filters === 'function') {\n\t    cb = notificationCB;\n\t    notificationCB = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = self.onDoneCB;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleRoom.renew', notificationCB);\n\t\n\t  /*\n\t    Skip subscription renewal if another one was performed a moment before\n\t   */\n\t  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n\t    return cb && cb(new Error('Subscription already renewed less than ' + self.renewalDelay + 'ms ago'));\n\t  }\n\t\n\t  if (filters) {\n\t    self.filters = filters;\n\t  }\n\t\n\t  /*\n\t   if not yet connected, register itself to the subscriptions list and wait for the\n\t   main Kuzzle object to renew once online\n\t    */\n\t  if (self.kuzzle.state !== 'connected') {\n\t    self.callback = notificationCB;\n\t    self.onDoneCB = cb;\n\t    self.kuzzle.subscriptions.pending[self.id] = self;\n\t    return;\n\t  }\n\t\n\t  if (self.subscribing) {\n\t    self.queue.push({action: 'renew', args: [filters, notificationCB, cb]});\n\t    return;\n\t  }\n\t\n\t  self.unsubscribe();\n\t  self.roomId = null;\n\t  self.subscribing = true;\n\t  self.callback = notificationCB;\n\t  self.onDoneCB = cb;\n\t  self.kuzzle.subscriptions.pending[self.id] = self;\n\t\n\t  subscribeQuery.body = self.filters;\n\t  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, this.headers);\n\t\n\t  self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'subscribe'), subscribeQuery, {metadata: self.metadata}, function (error, response) {\n\t    delete self.kuzzle.subscriptions.pending[self.id];\n\t    self.subscribing = false;\n\t\n\t    if (error) {\n\t      self.queue = [];\n\t      return cb && cb(new Error('Error during Kuzzle subscription: ' + error.message));\n\t    }\n\t\n\t    self.lastRenewal = now;\n\t    self.roomId = response.result.roomId;\n\t    self.channel = response.result.channel;\n\t\n\t    if (!self.kuzzle.subscriptions[self.roomId]) {\n\t      self.kuzzle.subscriptions[self.roomId] = {};\n\t    }\n\t\n\t    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\t\n\t    self.notifier = notificationCallback.bind(self);\n\t    self.kuzzle.network.on(self.channel, self.notifier);\n\t\n\t    dequeue.call(self);\n\t    cb && cb(null, self);\n\t  });\n\t};\n\t\n\t/**\n\t * Unsubscribes from Kuzzle.\n\t *\n\t * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n\t * pending subscriptions reaches 0, and only if there is still no listener on that room.\n\t * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n\t *\n\t * @return {*} this\n\t */\n\tKuzzleRoom.prototype.unsubscribe = function () {\n\t  var\n\t    self = this,\n\t    room = self.roomId,\n\t    interval;\n\t\n\t  if (!isReady.call(this)) {\n\t    self.queue.push({action: 'unsubscribe', args: []});\n\t    return self;\n\t  }\n\t\n\t  if (room) {\n\t    self.kuzzle.network.off(self.channel, this.notifier);\n\t\n\t    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n\t      delete self.kuzzle.subscriptions[room];\n\t\n\t      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t        self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n\t      } else {\n\t        interval = setInterval(function () {\n\t          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t            if (!self.kuzzle.subscriptions[room]) {\n\t              self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n\t            }\n\t            clearInterval(interval);\n\t          }\n\t        }, 100);\n\t      }\n\t    } else {\n\t      delete self.kuzzle.subscriptions[room][self.id];\n\t    }\n\t\n\t    self.roomId = null;\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleRoom.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Callback called by the network handler when a message is sent to the subscribed room ID\n\t * Calls the registered callback if the notification passes the subscription filters\n\t *\n\t * @param {object} data - data\n\t * @returns {*}\n\t */\n\tfunction notificationCallback (data) {\n\t  if (data.error) {\n\t    return this.callback(data.error);\n\t  }\n\t\n\t  if (data.action === 'jwtTokenExpired') {\n\t    this.kuzzle.jwtToken = undefined;\n\t    return this.kuzzle.emitEvent('jwtTokenExpired');\n\t  }\n\t\n\t  if (this.kuzzle.requestHistory[data.requestId]) {\n\t    if (this.subscribeToSelf) {\n\t      this.callback(null, data);\n\t    }\n\t    delete this.kuzzle.requestHistory[data.requestId];\n\t  } else {\n\t    this.callback(null, data);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Dequeue actions performed while subscription was being renewed\n\t */\n\tfunction dequeue () {\n\t  var element;\n\t\n\t  while (this.queue.length > 0) {\n\t    element = this.queue.shift();\n\t\n\t    this[element.action].apply(this, element.args);\n\t  }\n\t}\n\t\n\tfunction isReady() {\n\t  return this.kuzzle.state === 'connected' && !this.subscribing;\n\t}\n\t\n\tmodule.exports = KuzzleRoom;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t *\n\t * @param {KuzzleDataCollection} dataCollection\n\t * @param {int} total\n\t * @param {KuzzleDocument[]} documents\n\t * @param {object} [aggregations]\n\t * @param {object} [searchArgs]\n\t * @param {KuzzleSearchResult} [previous]\n\t * @constructor\n\t */\n\tfunction KuzzleSearchResult (dataCollection, total, documents, aggregations, searchArgs, previous) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    dataCollection: {\n\t      value: dataCollection,\n\t    },\n\t    total: {\n\t      value: total,\n\t      enumerable: true\n\t    },\n\t    documents: {\n\t      value: documents,\n\t      enumerable: true\n\t    },\n\t    aggregations: {\n\t      value: aggregations || {},\n\t      enumerable: true\n\t    },\n\t    searchArgs: {\n\t      value: searchArgs || {},\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    fetchedDocument: {\n\t      value: documents.length,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    _previous: {\n\t      value: previous || null,\n\t      writable: true\n\t    },\n\t    _next: {\n\t      value: null,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this._previous instanceof KuzzleSearchResult) {\n\t    this._previous._next = this;\n\t    this.fetchedDocument += this._previous.fetchedDocument;\n\t  }\n\t\n\t  // promisifying\n\t  if (this.dataCollection.kuzzle.bluebird) {\n\t    return this.dataCollection.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['previous', 'next'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * @param cb\n\t * @returns {*}\n\t */\n\tKuzzleSearchResult.prototype.previous = function (cb) {\n\t  cb(null, this._previous);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {function} cb\n\t */\n\tKuzzleSearchResult.prototype.next = function (cb) {\n\t  var\n\t    filters,\n\t    options = Object.assign({}, this.searchArgs.options),\n\t    self = this;\n\t\n\t  if (!this._next) {\n\t    // retrieve next results with scroll if original search use it\n\t    if (options.scrollId) {\n\t      if (this.fetchedDocument >= this.total) {\n\t        cb(null, null);\n\t        return;\n\t      }\n\t\n\t      this.dataCollection.scroll(\n\t        options.scrollId,\n\t        options,\n\t        this.searchArgs.filters || {},\n\t        function(error, newSearchResults) {\n\t          handleNextSearchResults(error, self, newSearchResults, cb);\n\t        }\n\t      );\n\t\n\t      return;\n\t    }\n\t    // retrieve next results with from/size if original search use it\n\t    else if (options.from !== undefined && options.size !== undefined) {\n\t      filters = Object.assign({}, this.searchArgs.filters);\n\t\n\t      // check if we need to do next request to fetch all matching documents\n\t      options.from += options.size;\n\t\n\t      if (options.from >= this.total) {\n\t        cb(null, null);\n\t\n\t        return;\n\t      }\n\t\n\t      this.dataCollection.search(\n\t        filters,\n\t        options,\n\t        function(error, newSearchResults) {\n\t          handleNextSearchResults(error, self, newSearchResults, cb);\n\t        }\n\t      );\n\t\n\t      return;\n\t    }\n\t  }\n\t\n\t  if (this._next instanceof KuzzleSearchResult) {\n\t    cb(null, this._next);\n\t\n\t    return;\n\t  }\n\t\n\t  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n\t};\n\t\n\t/**\n\t * @param {Error} error\n\t * @param {KuzzleSearchResult} currentSearchResults\n\t * @param {KuzzleSearchResult} newSearchResults\n\t * @param {Function} cb\n\t */\n\tfunction handleNextSearchResults (error, currentSearchResults, newSearchResults, cb) {\n\t  if (error) {\n\t    cb(error);\n\t    return;\n\t  }\n\t\n\t  newSearchResults.fetchedDocument += currentSearchResults.fetchedDocument;\n\t\n\t  newSearchResults._previous = currentSearchResults;\n\t  currentSearchResults._next = newSearchResults;\n\t\n\t\n\t  cb(null, newSearchResults);\n\t}\n\t\n\tmodule.exports = KuzzleSearchResult;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Sugar-code handling the result of a KuzzleRoom.renew call\n\t * @constructor\n\t */\n\tfunction KuzzleSubscribeResult() {\n\t  this.cbs = [];\n\t  this.error = null;\n\t  this.room = null;\n\t}\n\t\n\t/**\n\t * Registers a callback to be called with a subscription result\n\t * @param {Function} cb\n\t */\n\tKuzzleSubscribeResult.prototype.onDone = function (cb) {\n\t  if (this.error || this.room) {\n\t    cb(this.error, this.room);\n\t  }\n\t  else {\n\t    this.cbs.push(cb);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Calls all registered callbacks\n\t *\n\t * @param {Object} error object\n\t * @param {KuzzleRoom} room\n\t */\n\tKuzzleSubscribeResult.prototype.done = function (error, room) {\n\t  this.error = error;\n\t  this.room = room;\n\t\n\t  this.cbs.forEach(function (cb) {\n\t    cb(error, room);\n\t  });\n\t};\n\t\n\tmodule.exports = KuzzleSubscribeResult;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *\n\t * @param host\n\t * @param wsPort\n\t * @param ioPort\n\t * @param sslConnection\n\t * @returns {Object} tnstantiated WebSocket/Socket.IO object\n\t */\n\t\n\tfunction network(host, wsPort, ioPort, sslConnection) {\n\t  // Web browser / NodeJS websocket handling\n\t  if (typeof window !== 'undefined') {\n\t    // use native websockets if the browser supports it\n\t    if (typeof WebSocket !== 'undefined') {\n\t      return new (__webpack_require__(2))(host, wsPort, sslConnection);\n\t    }\n\t    // otherwise fallback to socket.io, if available\n\t    else if (window.io) {\n\t      return new (__webpack_require__(15))(host, ioPort, sslConnection);\n\t    }\n\t\n\t    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n\t  }\n\t\n\t  return new (__webpack_require__(2))(host, wsPort, sslConnection);\n\t}\n\t\n\tmodule.exports = network;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tfunction SocketIO(host, port, ssl) {\n\t  this.host = host;\n\t  this.port = port;\n\t  this.ssl = ssl;\n\t  this.socket = null;\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n\t      reconnection: autoReconnect,\n\t      reconnectionDelay: reconnectionDelay,\n\t      forceNew: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    this.socket.on('connect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    this.socket.on('connect_error', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    this.socket.on('disconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    this.socket.on('reconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room. Once 1 message is received, fires the\n\t   * callback and unregister it afterward.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.once = function (roomId, callback) {\n\t    this.socket.once(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.on = function (roomId, callback) {\n\t    this.socket.on(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Unregisters a callback from a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.off = function (roomId, callback) {\n\t    this.socket.off(roomId, callback);\n\t  };\n\t\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    this.socket.emit('kuzzle', payload);\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.socket.close();\n\t    this.socket = null;\n\t  };\n\t}\n\t\n\tmodule.exports = SocketIO;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\tfunction KuzzleProfile(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteProfile'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateProfile'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['hydrate', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tKuzzleProfile.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleProfile\n\t  }\n\t});\n\t\n\t/**\n\t * Persist to the persistent layer the current profile\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.save = function (options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!this.content.policies) {\n\t    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.serialize();\n\t\n\t  self.kuzzle.query(self.kuzzleSecurity.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Add a policy in the policies list\n\t * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n\t *\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.addPolicy = function (policy) {\n\t\n\t  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n\t  }\n\t\n\t  if (!this.content.policies) {\n\t    this.content.policies = [];\n\t  }\n\t\n\t  this.content.policies.push(policy);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set policies list\n\t * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.setPolicies = function (policies) {\n\t\n\t  if (!Array.isArray(policies)) {\n\t    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t  }\n\t\n\t  policies.map(function (policy) {\n\t    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t    }\n\t  });\n\t\n\t  this.content.policies = policies;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this securityDocument\n\t */\n\tKuzzleProfile.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Returns the list of policies associated to this profile.\n\t * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @return {object} an array of policies\n\t */\n\tKuzzleProfile.prototype.getPolicies = function () {\n\t  return this.content.policies;\n\t};\n\t\n\tmodule.exports = KuzzleProfile;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\tfunction KuzzleRole(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteRole'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateRole'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tKuzzleRole.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleRole\n\t  }\n\t});\n\t\n\t/**\n\t * Saves this role into Kuzzle.\n\t *\n\t * If this is a new role, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleRole} this object\n\t */\n\tKuzzleRole.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleRole;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleRole = __webpack_require__(17),\n\t  KuzzleProfile = __webpack_require__(16),\n\t  KuzzleUser = __webpack_require__(3);\n\t\n\t/**\n\t * Kuzzle security constructor\n\t *\n\t * @param kuzzle\n\t * @returns {KuzzleSecurity}\n\t * @constructor\n\t */\n\tfunction KuzzleSecurity(kuzzle) {\n\t\n\t  Object.defineProperty(this, 'kuzzle', {\n\t    value: kuzzle\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (action) {\n\t      return {\n\t        controller: 'security',\n\t        action: action\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['roleFactory', 'profileFactory', 'userFactory', 'isActionAllowed'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Retrieve a single Role using its unique role ID.\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getRole = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id) {\n\t    throw new Error('Id parameter is mandatory for getRole function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getRole', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new KuzzleRole(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on roles according to a filter\n\t *\n\t * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t *\n\t */\n\tKuzzleSecurity.prototype.searchRoles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchRoles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = result.result.hits.map(function (doc) {\n\t      return new KuzzleRole(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, roles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new role in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same role already exists: throw an error if sets to false.\n\t *        Replace the existing role otherwise\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createRole: cannot create a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleRole(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a role in Kuzzle.\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.updateRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'updateRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateRole: cannot update a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err) {\n\t    cb(err, err ? undefined : new KuzzleRole(self, id, content));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete role.\n\t *\n\t * There is a small delay between role deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Role id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.deleteRole = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleRole object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - role id\n\t * @param {object} content - role content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.roleFactory = function(id, content) {\n\t  return new KuzzleRole(this, id, content);\n\t};\n\t\n\t\n\t/**\n\t * Get a specific profile from kuzzle\n\t *\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getProfile = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for getProfile function');\n\t  }\n\t\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getProfile', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n\t    cb(error, error ? undefined : new KuzzleProfile(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on profiles according to a filter\n\t *\n\t *\n\t * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.searchProfiles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchProfiles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new KuzzleProfile(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: response.result.total, profiles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new profile in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same profile already exists: throw an error if sets to false.\n\t *        Replace the existing profile otherwise\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {object} content - attribute `roles` in `content` must only contains an array of role id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createProfile = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createProfile: cannot create a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleProfile(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a profile in Kuzzle.\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {object} content - a plain javascript object representing the profile's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.updateProfile = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateProfile: cannot update a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    var updatedContent = {};\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    Object.keys(res.result._source).forEach(function (property) {\n\t      updatedContent[property] = res.result._source[property];\n\t    });\n\t\n\t    cb(null, new KuzzleProfile(self, res.result._id, updatedContent));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete profile.\n\t *\n\t * There is a small delay between profile deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.deleteProfile = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleProfile object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - profile id\n\t * @param {object} content - profile content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.profileFactory = function(id, content) {\n\t  return new KuzzleProfile(this, id, content);\n\t};\n\t\n\t/**\n\t * Get a specific user from kuzzle using its unique ID\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getUser = function (id, options, cb) {\n\t  var\n\t    data = {_id: id},\n\t    self = this;\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for getUser function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getUser', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on user according to a filter\n\t *\n\t * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - same filters as documents filters\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.searchUsers = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchUsers', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new KuzzleUser(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: response.result.total, users: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new user in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same user already exists: throw an error if sets to false.\n\t *        Replace the existing user otherwise\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'createUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createUser: cannot create a user without a user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceUser' : 'createUser';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new restricted user in Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profile` in `content` must only contains the profile id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createRestrictedUser: cannot create a user without a user ID');\n\t  }\n\t\n\t  if (content.profileIds) {\n\t    throw new Error('KuzzleSecurity.createRestrictedUser: cannot provide profileIds');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.updateUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateUser: cannot update an user without an user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete user.\n\t *\n\t * There is a small delay between user deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.deleteUser = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleUser object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - user id\n\t * @param {object} content - user content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.userFactory = function(id, content) {\n\t  return new KuzzleUser(this, id, content);\n\t};\n\t\n\t/**\n\t * Tells whether an action is allowed, denied or conditional based on the rights\n\t * rights provided as the first argument. An action is defined as a couple of\n\t * action and controller (mandatory), plus an index and a collection(optional).\n\t *\n\t * @param {object} rights - The rights rights associated to a user\n\t *                            (see getMyrights and getUserrights).\n\t * @param {string} controller - The controller to check the action onto.\n\t * @param {string} action - The action to perform.\n\t * @param {string} index - (optional) The name of index to perform the action onto.\n\t * @param {string} collection - (optional) The name of the collection to perform the action onto.\n\t *\n\t * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n\t *                   correspond to rights containing closures.\n\t *                   See also http://kuzzle.io/guide/#roles-definition\n\t */\n\tKuzzleSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n\t  var filteredRights;\n\t\n\t  if (!rights || typeof rights !== 'object') {\n\t    throw new Error('rights parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!controller || typeof controller !== 'string') {\n\t    throw new Error('controller parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!action || typeof action !== 'string') {\n\t    throw new Error('action parameter is mandatory for isActionAllowed function');\n\t  }\n\t\n\t  // We filter in all the rights that match the request (including wildcards).\n\t  filteredRights = rights\n\t    .filter(function (right) {\n\t      return right.controller === controller || right.controller === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.action === action || right.action === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.index === index || right.index === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.collection === collection || right.collection === '*';\n\t    });\n\t\n\t  // Then, if at least one right allows the action, we return 'allowed'\n\t  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n\t    return 'allowed';\n\t  }\n\t  // If no right allows the action, we check for conditionals.\n\t  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n\t    return 'conditional';\n\t  }\n\t  // Otherwise we return 'denied'.\n\t  return 'denied';\n\t};\n\t\n\t\n\t/**\n\t * Gets the rights array of a given user.\n\t *\n\t * @param {string} userId The id of the user.\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {function} cb The callback containing the normalized array of rights.\n\t */\n\tKuzzleSecurity.prototype.getUserRights = function (userId, options, cb) {\n\t  var\n\t    data = {_id: userId},\n\t    self = this;\n\t\n\t  if (!userId || typeof userId !== 'string') {\n\t    throw new Error('userId parameter is mandatory for getUserRights function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\tmodule.exports = KuzzleSecurity;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  We feature\n\t// detect to determine the best RNG source, normalizing to a function that\n\t// returns 128-bits of randomness, since that's what's usually required\n\tvar rng = __webpack_require__(6);\n\tvar bytesToUuid = __webpack_require__(5);\n\t\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\t\n\t// random #'s we need to init node and clockseq\n\tvar _seedBytes = rng();\n\t\n\t// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\tvar _nodeId = [\n\t  _seedBytes[0] | 0x01,\n\t  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n\t];\n\t\n\t// Per 4.2.2, randomize (14 bit) clockseq\n\tvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\t\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0, _lastNSecs = 0;\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || [];\n\t\n\t  options = options || {};\n\t\n\t  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\t\n\t  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\t\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\t\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\t\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\t\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\t\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t  }\n\t\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\t\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\t\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\t\n\t  // `time_mid`\n\t  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\t\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\t\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\t\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\t\n\t  // `node`\n\t  var node = options.node || _nodeId;\n\t  for (var n = 0; n < 6; ++n) {\n\t    b[i + n] = node[n];\n\t  }\n\t\n\t  return buf ? buf : bytesToUuid(b);\n\t}\n\t\n\tmodule.exports = v1;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(6);\n\tvar bytesToUuid = __webpack_require__(5);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// kuzzle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8c3162cebc031ff3d690","var\n  uuid = require('uuid'),\n  KuzzleDataCollection = require('./kuzzleDataCollection'),\n  KuzzleSecurity = require('./security/kuzzleSecurity'),\n  KuzzleMemoryStorage = require('./kuzzleMemoryStorage'),\n  KuzzleUser = require('./security/kuzzleUser'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n * @constructor\n */\nfunction Kuzzle (host, options, cb) {\n  var self = this;\n\n  if (!(this instanceof Kuzzle)) {\n    return new Kuzzle(host, options, cb);\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!host || host === '') {\n    throw new Error('host argument missing');\n  }\n\n  Object.defineProperties(this, {\n    // 'private' properties\n    collections: {\n      value: {},\n      writable: true\n    },\n    connectCB: {\n      value: cb\n    },\n    eventListeners: {\n      value: {\n        connected: {lastEmitted: null, listeners: []},\n        error: {lastEmitted: null, listeners: []},\n        disconnected: {lastEmitted: null, listeners: []},\n        reconnected: {lastEmitted: null, listeners: []},\n        jwtTokenExpired: {lastEmitted: null, listeners: []},\n        loginAttempt: {lastEmitted: null, listeners: []},\n        offlineQueuePush: {listeners: []},\n        offlineQueuePop: {listeners: []},\n        queryError: {listeners: []}\n      }\n    },\n    eventTimeout: {\n      value: 200\n    },\n    queuing: {\n      value: false,\n      writable: true\n    },\n    requestHistory: {\n      value: {},\n      writable: true\n    },\n    state: {\n      value: 'initializing',\n      writable: true\n    },\n    subscriptions: {\n      /*\n       Contains the centralized subscription list in the following format:\n          pending: <number of pending subscriptions>\n          'roomId': {\n            kuzzleRoomID_1: kuzzleRoomInstance_1,\n            kuzzleRoomID_2: kuzzleRoomInstance_2,\n            kuzzleRoomID_...: kuzzleRoomInstance_...\n          }\n\n       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n       This structure also allows renewing subscriptions after a connection loss\n       */\n      value: {\n        pending: {}\n      },\n      writable: true\n    },\n    // read-only properties\n    autoReconnect: {\n      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n      enumerable: true\n    },\n    defaultIndex: {\n      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n      writable: true,\n      enumerable: true\n    },\n    reconnectionDelay: {\n      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n      enumerable: true\n    },\n    host: {\n      value: host,\n      writable: true,\n      enumerable: true\n    },\n    wsPort: {\n      value: (options && typeof options.wsPort === 'number') ? options.wsPort : 7513,\n      enumerable: true,\n      writable: true\n    },\n    ioPort: {\n      value: (options && typeof options.ioPort === 'number') ? options.ioPort : 7512,\n      enumerable: true,\n      writable: true\n    },\n    sslConnection: {\n      value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n      enumerable: true\n    },\n    autoQueue: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoReplay: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoResubscribe: {\n      value: true,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    metadata: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    /*\n      Offline queue use the following format:\n            [\n              {\n                ts: <query timestamp>,\n                query: 'query',\n                cb: callbackFunction\n              }\n            ]\n     */\n    offlineQueue: {\n      value: [],\n      enumerable: true,\n      writable: true\n    },\n    queueFilter: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    queueMaxSize: {\n      value: 500,\n      enumerable: true,\n      writable: true\n    },\n    queueTTL: {\n      value: 120000,\n      enumerable: true,\n      writable: true\n    },\n    replayInterval: {\n      value: 10,\n      enumerable: true,\n      writable: true\n    },\n    jwtToken: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    offlineQueueLoader: {\n      value: null,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (options) {\n    Object.keys(options).forEach(function (opt) {\n      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n        self[opt] = options[opt];\n      }\n    });\n\n    if (options.offlineMode === 'auto' && this.autoReconnect) {\n      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n    }\n  }\n\n  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n  Object.defineProperty(this, 'isValid', {\n    value: function () {\n      if (self.state === 'disconnected') {\n        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n      }\n    }\n  });\n\n  // Helper function copying headers to the query data\n  Object.defineProperty(this, 'addHeaders', {\n    value: function (query, headers) {\n      Object.keys(headers).forEach(function (header) {\n        if (!query[header]) {\n          query[header] = headers[header];\n        }\n      });\n\n      return query;\n    }\n  });\n\n  /**\n   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n   * and is called by these methods\n   */\n  Object.defineProperty(this, 'callbackRequired', {\n    value: function (errorMessagePrefix, callback) {\n      if (!callback || typeof callback !== 'function') {\n        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n      }\n    }\n  });\n\n  /**\n   * Create an attribute security that embed all methods to manage Role, Profile and User\n   */\n  Object.defineProperty(this, 'security', {\n    value: new KuzzleSecurity(this),\n    enumerable: true\n  });\n\n  /**\n   * Emit an event to all registered listeners\n   * An event cannot be emitted multiple times before a timeout has been reached.\n   */\n  Object.defineProperty(this, 'emitEvent', {\n    value: function emitEvent(event) {\n      var\n        now = Date.now(),\n        args = Array.prototype.slice.call(arguments, 1),\n        eventProperties = this.eventListeners[event];\n\n      if (eventProperties.lastEmitted && eventProperties.lastEmitted >= now - this.eventTimeout) {\n        return false;\n      }\n\n      eventProperties.listeners.forEach(function (listener) {\n        process.nextTick(function () {\n          listener.fn.apply(undefined, args);\n        });\n      });\n\n      // Events without the 'lastEmitted' property can be emitted without minimum time between emissions\n      if (eventProperties.lastEmitted !== undefined) {\n        eventProperties.lastEmitted = now;\n      }\n    }\n  });\n\n  Object.defineProperty(this, 'memoryStorage', {\n    value: new KuzzleMemoryStorage(this),\n    enumerable: true\n  });\n\n\n  if (!options || !options.connect || options.connect === 'auto') {\n    this.connect();\n  } else {\n    this.state = 'ready';\n  }\n\n  cleanHistory(this.requestHistory);\n\n  if (this.bluebird) {\n    return this.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n          'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n          'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n        ];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Connects to a Kuzzle instance using the provided host name.\n * @returns {Object} this\n */\nKuzzle.prototype.connect = function () {\n  var self = this;\n\n  if (self.network) {\n    self.disconnect();\n  }\n\n  self.network = networkWrapper(self.host, self.wsPort, self.ioPort, self.sslConnection);\n\n  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n    return self;\n  }\n\n  self.state = 'connecting';\n  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\n  self.network.onConnect(function () {\n    self.state = 'connected';\n    renewAllSubscriptions.call(self);\n    dequeue.call(self);\n    self.emitEvent('connected');\n\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n  });\n\n  self.network.onConnectError(function (error) {\n    var connectionError = new Error('Unable to connect to kuzzle proxy server at \"' + self.host + '\"');\n\n    connectionError.internal = error;\n    self.state = 'error';\n    self.emitEvent('error', connectionError);\n\n    if (self.connectCB) {\n      self.connectCB(connectionError);\n    }\n  });\n\n  self.network.onDisconnect(function () {\n    self.state = 'offline';\n\n    if (!self.autoReconnect) {\n      self.disconnect();\n    }\n\n    if (self.autoQueue) {\n      self.queuing = true;\n    }\n\n    self.emitEvent('disconnected');\n  });\n\n  self.network.onReconnect(function () {\n    var reconnect = function () {\n      // renew subscriptions\n      if (self.autoResubscribe) {\n        renewAllSubscriptions.call(self);\n      }\n\n      // replay queued requests\n      if (self.autoReplay) {\n        cleanQueue.call(self);\n        dequeue.call(self);\n      }\n\n      // alert listeners\n      self.emitEvent('reconnected');\n    };\n\n    self.state = 'connected';\n\n    if (self.jwtToken) {\n      self.checkToken(self.jwtToken, function (err, res) {\n        // shouldn't obtain an error but let's invalidate the token anyway\n        if (err || !res.valid) {\n          self.jwtToken = undefined;\n          self.emitEvent('jwtTokenExpired');\n        }\n\n        reconnect();\n      });\n    } else {\n      reconnect();\n    }\n  });\n\n  return this;\n};\n\n/**\n * Set the jwtToken used to query kuzzle\n * @param token\n * @returns {Kuzzle}\n */\nKuzzle.prototype.setJwtToken = function(token) {\n  if (typeof token === 'string') {\n    this.jwtToken = token;\n  } else if (typeof token === 'object') {\n    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n      this.jwtToken = token.result.jwt;\n    } else {\n      this.emitEvent('loginAttempt', {\n        success: false,\n        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n      });\n\n      return this;\n    }\n  } else {\n    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n    return this;\n  }\n\n  renewAllSubscriptions.call(this);\n  this.emitEvent('loginAttempt', {success: true});\n  return this;\n};\n\n/**\n * Unset the jwtToken used to query kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.unsetJwtToken = function() {\n  this.jwtToken = undefined;\n\n  removeAllSubscriptions.call(this);\n\n  return this;\n};\n\n/**\n * Get the jwtToken used by kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.getJwtToken = function() {\n  return this.jwtToken;\n};\n\n/**\n * Send login request to kuzzle with credentials\n * If login success, store the jwtToken into kuzzle object\n *\n * @param strategy\n * @param credentials\n * @param expiresIn\n * @param cb\n */\nKuzzle.prototype.login = function (strategy) {\n  var\n    self = this,\n    request = {\n      strategy: strategy\n    },\n    credentials,\n    cb = null;\n\n  // Handle arguments (credentials, expiresIn, cb)\n  if (arguments[1]) {\n    if (typeof arguments[1] === 'object') {\n      credentials = arguments[1];\n    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n      request.expiresIn = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n    }\n  }\n  if (arguments[2]) {\n    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n      request.expiresIn = arguments[2];\n    } else if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n    }\n  }\n  if (arguments[3] && typeof arguments[3] === 'function') {\n    cb = arguments[3];\n  }\n\n  if (typeof credentials === 'object') {\n    Object.keys(credentials).forEach(function (key) {\n      request[key] = credentials[key];\n    });\n  }\n\n  this.query({controller: 'auth', action: 'login'}, {body: request}, {queuable: false}, function(error, response) {\n    if (!error) {\n      if (response.result.jwt) {\n        self.setJwtToken(response.result.jwt);\n      }\n\n      cb && cb(null, response.result);\n    }\n    else {\n      cb && cb(error);\n      self.emitEvent('loginAttempt', {success: false, error: error.message});\n    }\n  });\n};\n\n/**\n * Create a kuzzle index\n *\n * @param {string} index\n * @param {object} [options]\n * @param {responseCallback} cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.createIndex = function (index, options, cb) {\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.createIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'admin', action: 'createIndex'}, {index: index}, options, typeof cb !== 'function' ? null : cb);\n\n  return this;\n};\n\n/**\n * Send logout request to kuzzle with jwtToken.\n *\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.logout = function (cb) {\n  var\n    self = this,\n    request = {\n      action: 'logout',\n      controller: 'auth',\n      requestId: uuid.v4(),\n      body: {}\n    };\n\n  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, typeof cb !== 'function' ? null : function(error) {\n    cb(error, self);\n  });\n\n  self.unsetJwtToken();\n\n  return self;\n};\n\n/**\n * Checks whether a given jwt token still represents a valid session in Kuzzle.\n *\n * @param  {string}   token     The jwt token to check\n * @param  {function} callback  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.checkToken = function (token, callback) {\n  var\n    request = {\n      body: {\n        token: token\n      }\n    };\n\n  this.callbackRequired('Kuzzle.checkToken', callback);\n\n  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, response) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, response.result);\n  });\n};\n\n/**\n * Fetches the current user.\n *\n * @param  {function} callback  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.whoAmI = function (callback) {\n  var self = this;\n\n  self.callbackRequired('Kuzzle.whoAmI', callback);\n\n  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, response) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new KuzzleUser(self.security, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Gets the rights array of the currently logged user.\n *\n * @param {object} [options] - Optional parameters\n * @param  {function} cb The callback containing the normalized array of rights.\n */\nKuzzle.prototype.getMyRights = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.callbackRequired('Kuzzle.getMyRights', cb);\n\n  self.query({controller: 'auth', action:'getMyRights'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.hits);\n  });\n};\n\n/**\n * Update current user in Kuzzle.\n *\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.updateSelf = function (content, options, cb) {\n  var\n    self = this,\n    data = {},\n    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data.body = content;\n\n  self.query(queryArgs, data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return this;\n};\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n */\nfunction cleanQueue () {\n  var\n    self = this,\n    now = Date.now(),\n    lastDocumentIndex = -1;\n\n  if (self.queueTTL > 0) {\n    self.offlineQueue.forEach(function (query, index) {\n      if (query.ts < now - self.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      self.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(function (droppedRequest) {\n          self.emitEvent('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n    self.offlineQueue\n      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n      .forEach(function (droppedRequest) {\n        self.emitEvent('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n\n/**\n * Clean history from requests made more than 10s ago\n */\nfunction cleanHistory (requestHistory) {\n  var\n    now = Date.now();\n\n  Object.keys(requestHistory).forEach(function (key) {\n    if (requestHistory[key] < now - 10000) {\n      delete requestHistory[key];\n    }\n  });\n\n  setTimeout(function () {\n    cleanHistory(requestHistory);\n  }, 1000);\n}\n\n/**\n * Emit a request to Kuzzle\n *\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (request, cb) {\n  var\n    self = this;\n\n  if (self.jwtToken !== undefined || cb) {\n    self.network.once(request.requestId, function (response) {\n      var error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        self.jwtToken = undefined;\n        self.emitEvent('jwtTokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        self.emitEvent('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n\n  this.network.send(request);\n\n  // Track requests made to allow KuzzleRoom.subscribeToSelf to work\n  self.requestHistory[request.requestId] = Date.now();\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue () {\n  var\n    self = this,\n    additionalQueue,\n    uniqueQueue = {},\n    dequeuingProcess = function () {\n      if (self.offlineQueue.length > 0) {\n        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\n        setTimeout(function () {\n          dequeuingProcess();\n        }, Math.max(0, self.replayInterval));\n      } else {\n        self.queuing = false;\n      }\n    };\n\n  if (self.offlineQueueLoader) {\n    if (typeof self.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n    }\n\n    additionalQueue = self.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      self.offlineQueue = additionalQueue\n        .concat(self.offlineQueue)\n        .filter(function (request) {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\n/**\n * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n * successful login attempt\n */\nfunction renewAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.renew(subscription.callback);\n    });\n  });\n}\n\n/**\n * Remove all registered subscriptions. Triggered either by a logout query or by un-setting the token\n */\nfunction removeAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.unsubscribe();\n    });\n  });\n}\n\n/**\n * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n * insertion.\n *\n * The ID returned by this function is required to remove this listener at a later time.\n *\n * @param {string} event - name of the global event to subscribe to (see the 'eventListeners' object property)\n * @param {function} listener - callback to invoke each time an event is fired\n * @returns {string} Unique listener ID\n */\nKuzzle.prototype.addListener = function(event, listener) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    listenerType = typeof listener,\n    listenerId;\n\n  this.isValid();\n\n  if (knownEvents.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n  }\n\n  if (listenerType !== 'function') {\n    throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n  }\n\n  listenerId = uuid.v4();\n  this.eventListeners[event].listeners.push({id: listenerId, fn: listener});\n  return listenerId;\n};\n\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method returns all available statistics from Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAllStatistics = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n  this.query({controller:'server', action: 'getAllStats'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.hits);\n  });\n};\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n *\n * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n  var\n    queryCB,\n    body;\n\n  if (!cb) {\n    if (arguments.length === 1) {\n      cb = arguments[0];\n      options = null;\n      timestamp = null;\n    } else {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'object') {\n        options = arguments[0];\n        timestamp = null;\n      } else {\n        timestamp = arguments[0];\n        options = null;\n      }\n    }\n  }\n\n  queryCB = function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, timestamp ? res.result.hits : [res.result]);\n  };\n\n  this.callbackRequired('Kuzzle.getStatistics', cb);\n\n  body = timestamp ? {body: {startTime: timestamp}} : {};\n  this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n};\n\n/**\n * Create a new instance of a KuzzleDataCollection object.\n * If no index is specified, takes the default index.\n *\n * @param {string} collection - The name of the data collection you want to manipulate\n * @param {string} [index] - The name of the data index containing the data collection\n * @returns {KuzzleDataCollection} A KuzzleDataCollection instance\n */\nKuzzle.prototype.dataCollectionFactory = function(collection, index) {\n  this.isValid();\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Unable to create a new data collection object: no index specified');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  if (typeof index !== 'string' || typeof collection !== 'string') {\n    throw new Error('Invalid index or collection argument: string expected');\n  }\n\n  if (!this.collections[index]) {\n    this.collections[index] = {};\n  }\n\n  if (!this.collections[index][collection]) {\n    this.collections[index][collection] = new KuzzleDataCollection(this, collection, index);\n  }\n\n  return this.collections[index][collection];\n};\n\n/**\n * Empties the offline queue without replaying it.\n *\n * @returns {Kuzzle}\n */\nKuzzle.prototype.flushQueue = function () {\n  this.offlineQueue = [];\n  return this;\n};\n\n/**\n * Returns the list of known persisted data collections.\n *\n * @param {string} [index] - Index containing collections to be listed\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listCollections = function () {\n  var\n    collectionType = 'all',\n    index,\n    options,\n    cb,\n    args = Array.prototype.slice.call(arguments),\n    query;\n\n  args.forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.listCollections: index required');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.listCollections', cb);\n\n  if (options && options.type) {\n    collectionType = options.type;\n  }\n\n  query = {body: {type: collectionType}};\n\n  if (options && options.from) {\n    query.body.from = options.from;\n  }\n\n  if (options && options.size) {\n    query.body.size = options.size;\n  }\n\n  this.query({index: index, controller: 'collection', action: 'list'}, query, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.collections);\n  });\n};\n\n/**\n * Returns the list of existing indexes in Kuzzle\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listIndexes = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.listIndexes', cb);\n\n  this.query({controller: 'index', action: 'list'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.indexes);\n  });\n};\n\n/**\n * Disconnects from Kuzzle and invalidate this instance.\n */\nKuzzle.prototype.disconnect = function () {\n  var collection;\n\n  this.state = 'disconnected';\n  this.network.close();\n  this.network = null;\n\n  for (collection in this.collections) {\n    if (this.collections.hasOwnProperty(collection)) {\n      delete this.collections[collection];\n    }\n  }\n};\n\n/**\n * Returns the server informations\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getServerInfo = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n  this.query({controller: 'server', action: 'info'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.serverInfo);\n  });\n};\n\n/**\n * Forces an index refresh\n *\n * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {Kuzzle}\n */\nKuzzle.prototype.refreshIndex = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.refreshIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.query({ index: index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n  return this;\n};\n\n/**\n * Returns de current autoRefresh status for the given index\n *\n * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optinal arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAutoRefresh = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.getAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n  this.query({ index: index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n};\n\n/**\n * (Un)Sets the autoRefresh flag on the given index\n *\n * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n * @param {boolean} autoRefresh - The autoRefresh value to set\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query result\n * @returns {object} this\n */\nKuzzle.prototype.setAutoRefresh = function () {\n  var\n    index,\n    autoRefresh,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'boolean':\n        autoRefresh = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.setAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (autoRefresh === undefined) {\n    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n  }\n\n  this.query({ index: index, controller: 'index', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\n  return this;\n};\n\n/**\n * Return the current Kuzzle's UTC Epoch time, in milliseconds\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.now = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.now', cb);\n\n  this.query({controller: 'server', action: 'now'}, {}, options, function (err, res) {\n    cb(err, res && res.result.now);\n  });\n};\n\n/**\n * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n * Base method used to send read queries to Kuzzle\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} queryArgs - Query configuration\n * @param {object} query - The query data\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n  var\n    attr,\n    object = {\n      action: queryArgs.action,\n      controller: queryArgs.controller,\n      metadata: this.metadata\n    },\n    self = this;\n\n  this.isValid();\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options) {\n    if (options.queuable === false && self.state === 'offline') {\n      return self;\n    }\n\n    if (options.refresh) {\n      object.refresh = options.refresh;\n    }\n\n    if (options.from) {\n      object.from = options.from;\n    }\n\n    if (options.size) {\n      object.size = options.size;\n    }\n\n    if (options.metadata) {\n      Object.keys(options.metadata).forEach(function (meta) {\n        object.metadata[meta] = options.metadata[meta];\n      });\n    }\n  }\n\n  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n    throw new Error('Invalid query parameter: ' + query);\n  }\n\n  if (query.metadata) {\n    Object.keys(query.metadata).forEach(function (meta) {\n      object.metadata[meta] = query.metadata[meta];\n    });\n  }\n\n  for (attr in query) {\n    if (attr !== 'metadata' && query.hasOwnProperty(attr)) {\n      object[attr] = query[attr];\n    }\n  }\n\n  object = self.addHeaders(object, this.headers);\n\n  /*\n   * Do not add the token for the checkToken route, to avoid getting a token error when\n   * a developer simply wish to verify his token\n   */\n  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n    object.jwt = self.jwtToken;\n  }\n\n  if (queryArgs.collection) {\n    object.collection = queryArgs.collection;\n  }\n\n  if (queryArgs.index) {\n    object.index = queryArgs.index;\n  }\n\n  if (!object.requestId) {\n    object.requestId = uuid.v4();\n  }\n\n  if (self.state === 'connected' || (options && options.queuable === false)) {\n    if (self.state === 'connected') {\n      emitRequest.call(this, object, cb);\n    } else if (cb) {\n      cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n    }\n  } else if (self.queuing || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n    cleanQueue.call(this, object, cb);\n\n    if (!self.queueFilter || self.queueFilter(object)) {\n      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n    }\n  }\n\n  return self;\n};\n\n/**\n * Removes all listeners, either from a specific event or from all events\n *\n * @param {string} event - One of the event described in the Event Handling section of this documentation\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.removeAllListeners = function (event) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    self = this;\n\n  if (event) {\n    if (knownEvents.indexOf(event) === -1) {\n      throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n    }\n\n    this.eventListeners[event].listeners = [];\n  } else {\n    knownEvents.forEach(function (eventName) {\n      self.eventListeners[eventName].listeners = [];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Removes a listener from an event.\n *\n * @param {string} event - One of the event described in the Event Handling section of this documentation\n * @param {string} listenerId - The ID returned by addListener\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.removeListener = function (event, listenerId) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    self = this;\n\n  if (knownEvents.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n  }\n\n  this.eventListeners[event].listeners.forEach(function (listener, index) {\n    if (listener.id === listenerId) {\n      self.eventListeners[event].listeners.splice(index, 1);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Replays the requests queued during offline mode.\n * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n */\nKuzzle.prototype.replayQueue = function () {\n  if (this.state !== 'offline' && !this.autoReplay) {\n    cleanQueue.call(this);\n    dequeue.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Sets the default Kuzzle index\n *\n * @param index\n * @returns this\n */\nKuzzle.prototype.setDefaultIndex = function (index) {\n  if (typeof index !== 'string') {\n    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n  }\n\n  if (index.length === 0) {\n    throw new Error('Cannot set an empty index as the default index');\n  }\n\n  this.defaultIndex = index;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzle.prototype.setHeaders = function (content, replace) {\n  var self = this;\n\n  if (typeof content !== 'object' || Array.isArray(content)) {\n    throw new Error('Expected a content object, received a ' + typeof content);\n  }\n\n  if (replace) {\n    self.headers = content;\n  } else {\n    Object.keys(content).forEach(function (key) {\n      self.headers[key] = content[key];\n    });\n  }\n\n  return self;\n};\n\n/**\n * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.startQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = true;\n  }\n  return this;\n};\n\n/**\n * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.stopQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = false;\n  }\n\n  return this;\n};\n\nmodule.exports = Kuzzle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzle.js\n// module id = 0\n// module chunks = 0","function KuzzleSecurityDocument(kuzzleSecurity, id, content) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: kuzzleSecurity.kuzzle\n    },\n    kuzzleSecurity: {\n      value: kuzzleSecurity\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {KuzzleSecurityDocument} this\n */\nKuzzleSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nKuzzleSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurityDocument} this\n */\nKuzzleSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = KuzzleSecurityDocument;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleSecurityDocument.js\n// module id = 1\n// module chunks = 0","function WSNode(host, port, ssl) {\n  var self = this;\n  this.WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.client = null;\n  this.wasConnected = false;\n  this.retrying = false;\n  this.lasturl = null;\n\n  /*\n   Listeners are stored using the following format:\n   roomId: {\n   fn: callback_function,\n   once: boolean\n   }\n   */\n  this.listeners = {\n    error: [],\n    connect: [],\n    disconnect: [],\n    reconnect: []\n  };\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   * @returns {Object} Socket\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    var\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      options = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    if (url !== this.lasturl) {\n      self.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new this.WebSocket(url, options);\n\n    this.client.onopen = function () {\n      if (self.wasConnected) {\n        poke(self.listeners, 'reconnect');\n      }\n      else {\n        poke(self.listeners, 'connect');\n      }\n      self.wasConnected = true;\n    };\n\n    this.client.onclose = function (code, message) {\n      if (code === 1000) {\n        poke(self.listeners, 'disconnect');\n      }\n      else {\n        onClientError.call(self, autoReconnect, reconnectionDelay, message);\n      }\n    };\n\n    this.client.onerror = function (error) {\n      onClientError.call(self, autoReconnect, reconnectionDelay, error);\n    };\n\n    this.client.onmessage = function (payload) {\n      var data = JSON.parse(payload.data || payload);\n\n      if (data.room && self.listeners[data.room]) {\n        poke(self.listeners, data.room, data);\n      }\n    };\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.listeners.connect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.listeners.error.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.listeners.disconnect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.listeners.reconnect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    if (!this.listeners[roomId]) {\n      this.listeners[roomId] = [];\n    }\n\n    this.listeners[roomId].push({\n      fn: callback,\n      keep: false\n    });\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    if (!this.listeners[roomId]) {\n      this.listeners[roomId] = [];\n    }\n\n    this.listeners[roomId].push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    var index = -1;\n\n    if (this.listeners[roomId]) {\n      // Array.findIndex is not supported by internet explorer\n      this.listeners[roomId].some(function (listener, i) {\n        if (listener.fn === callback) {\n          index = i;\n          return true;\n        }\n\n        return false;\n      });\n\n      if (index !== -1) {\n        if (this.listeners[roomId].length === 1 && ['error', 'connect', 'disconnect', 'reconnect'].indexOf(roomId) === -1) {\n          delete this.listeners[roomId];\n        }\n        else {\n          this.listeners[roomId].splice(index, 1);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.listeners = {\n      error: [],\n      connect: [],\n      disconnect: [],\n      reconnect: []\n    };\n\n    this.wasConnected = false;\n    this.client.close();\n    this.client = null;\n  };\n}\n\n/**\n * Executes all registered listeners in the provided\n * \"listeners\" structure.\n *\n * Listeners are of the following format:\n * [\n *    { fn: callback, once: boolean },\n *    ...\n * ]\n *\n * @private\n * @param {Object} listeners\n * @param {string} roomId\n * @param {Object} [payload]\n */\nfunction poke (listeners, roomId, payload) {\n  var\n    i,\n    length = listeners[roomId].length;\n\n  for (i = 0; i < length; ++i) {\n    listeners[roomId][i].fn(payload);\n\n    if (!listeners[roomId][i].keep) {\n      if (listeners[roomId].length > 1) {\n        listeners[roomId].splice(i, 1);\n        --i;\n        --length;\n      }\n      else {\n        delete listeners[roomId];\n      }\n    }\n  }\n}\n\n/**\n * Called when the connection closes with an error state\n *\n * @param {boolean} autoReconnect\n * @param {number} reconnectionDelay\n * @param {string|Object} message\n */\nfunction onClientError(autoReconnect, reconnectionDelay, message) {\n  var self = this;\n\n  if (autoReconnect && !self.retrying) {\n    self.retrying = true;\n    setTimeout(function () {\n      self.retrying = false;\n      self.connect(autoReconnect, reconnectionDelay);\n    }, reconnectionDelay);\n  }\n\n  poke(self.listeners, 'error', message);\n}\n\nmodule.exports = WSNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/wrappers/websocket.js\n// module id = 2\n// module chunks = 0","var\n  KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\n/**\n * @param {KuzzleSecurity} kuzzleSecurity\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction KuzzleUser(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save', 'saveRestricted'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nKuzzleUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleUser\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Saves this user into Kuzzle.\n *\n * If this is a new user, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this user in Kuzzle by the current content\n * of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nKuzzleUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array} the associated profiles IDs\n */\nKuzzleUser.prototype.getProfiles = function () {\n  return this.content.profileIds;\n};\n\nmodule.exports = KuzzleUser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleUser.js\n// module id = 3\n// module chunks = 0","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/index.js\n// module id = 4\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/bytesToUuid.js\n// module id = 5\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/rng-browser.js\n// module id = 6\n// module chunks = 0","var\n  KuzzleSearchResult = require('./kuzzleSearchResult'),\n  KuzzleDocument = require('./kuzzleDocument'),\n  KuzzleDataMapping = require('./kuzzleDataMapping'),\n  KuzzleRoom = require('./kuzzleRoom'),\n  KuzzleSubscribeResult = require('./kuzzleSubscribeResult');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction KuzzleDataCollection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The KuzzleDataCollection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleDataCollection.prototype.count = function (filters, options, cb) {\n  var\n    query;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.count', cb);\n\n  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (error, result) {\n    cb(error, result && result.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.create = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *    - updateIfExist (boolean, default: false):\n *        If the same document already exists: throw an error if sets to false.\n *        Update the existing document otherwise\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a KuzzleDocument object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof KuzzleDocument) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options) {\n    action = options.updateIfExist ? 'createOrReplace' : 'create';\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  data = self.kuzzle.addHeaders(data, self.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new KuzzleDocument(self, res.result._id, res.result._source);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleDataCollection} this\n */\nKuzzleDataCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = arg;\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleDataCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleDataCollection.fetch', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new KuzzleDocument(self, res.result._id, res.result._source);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Retrieves all documents stored in this data collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleDataCollection.prototype.fetchAllDocuments = function (options, cb) {\n  var\n    warnEmitted = false,\n    documents = [],\n    filters = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  // copying pagination options to the search filter\n  if (!options) {\n    options = {};\n  }\n\n  if (!options.from) {\n    options.from = 0;\n  }\n\n  if (!options.size) {\n    options.size = 1000;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.fetchAllDocuments', cb);\n\n  this.search(filters, options, function getNextDocuments (error, searchResult) {\n    if (error) {\n      return cb(error);\n    }\n\n    if (searchResult instanceof KuzzleSearchResult) {\n      if (searchResult.total > 10000 && !warnEmitted) {\n        warnEmitted = true;\n        console.warn('KuzzleDataCollection.fetchAllDocuments may return extremely large amounts of documents, which may cause performance issues. Unless you know what you are doing, consider using KuzzleDataCollection.search or KuzzleDataCollection.scroll instead'); // eslint-disable-line no-console\n      }\n\n      searchResult.documents.forEach(function (document) {\n        documents.push(document);\n      });\n      searchResult.next(getNextDocuments);\n    }\n    else {\n      cb(null, documents);\n    }\n  });\n};\n\n\n/**\n * Instantiates a KuzzleDataMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated KuzzleDataMapping object\n */\nKuzzleDataCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.getMapping', cb);\n\n  kuzzleMapping = new KuzzleDataMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a KuzzleDocument instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof KuzzleDocument) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n * @return {object} this\n */\nKuzzleDataCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new KuzzleDocument(self, res.result._id, res.result._source);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nKuzzleDataCollection.prototype.search = function (filters, options, cb) {\n  var\n    query,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('KuzzleDataCollection.search', cb);\n\n  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      result.result.aggregations ? result.result.aggregations : [],\n      {options: options, filters: filters}\n    ));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nKuzzleDataCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {body: {}},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('KuzzleDataCollection.scroll: scrollId required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  options.scrollId = scrollId;\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.scroll', cb);\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      result.result.aggregations ? result.result.aggregations : [],\n      {options: options, filters: filters}\n    ));\n  });\n\n  return this;\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} cb - called for each new notification\n * @returns {*} KuzzleSubscribeResult object\n */\nKuzzleDataCollection.prototype.subscribe = function (filters, options, cb) {\n  var\n    room,\n    subscribeResult;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.subscribe', cb);\n\n  subscribeResult = new KuzzleSubscribeResult();\n  room = new KuzzleRoom(this, options);\n\n  room.renew(filters, cb, subscribeResult.done.bind(subscribeResult));\n\n  return subscribeResult;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n * @return {object} this\n */\nKuzzleDataCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var\n    data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new KuzzleDocument(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n\n/**\n * Instantiate a new KuzzleDocument object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nKuzzleDataCollection.prototype.documentFactory = function (id, content) {\n  return new KuzzleDocument(this, id, content);\n};\n\n/**\n * Instantiate a new KuzzleRoom object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [options] - subscription configuration\n * @constructor\n */\nKuzzleDataCollection.prototype.roomFactory = function (options) {\n  return new KuzzleRoom(this, options);\n};\n\n/**\n * Instantiate a new KuzzleDataMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the KuzzleDataMapping object with\n * @constructor\n */\nKuzzleDataCollection.prototype.dataMappingFactory = function (mapping) {\n  return new KuzzleDataMapping(this, mapping);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDataCollection.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = KuzzleDataCollection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleDataCollection.js\n// module id = 7\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The KuzzleDataMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} kuzzleDataCollection - Instance of the inherited KuzzleDataCollection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction KuzzleDataMapping(kuzzleDataCollection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set', 'setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleDataMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDataMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function wont be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {KuzzleDataMapping}\n */\nKuzzleDataMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDataMapping.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = KuzzleDataMapping;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleDataMapping.js\n// module id = 8\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * KuzzleDocument is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {object} kuzzleDataCollection - an instanciated KuzzleDataCollection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @constructor\n */\nfunction KuzzleDocument(kuzzleDataCollection, documentId, content) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: kuzzleDataCollection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nKuzzleDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data._version = this.version;\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nKuzzleDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('KuzzleDocument.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('KuzzleDocument.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDocument.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new KuzzleDocument(self.dataCollection, self.id, res.result._source);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nKuzzleDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nKuzzleDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nKuzzleDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDocument.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('KuzzleDocument.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDocument.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n\nmodule.exports = KuzzleDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleDocument.js\n// module id = 9\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), excepting:\n *   * all cluster based functions\n *   * all script based functions\n *   * all cursors functions\n *\n * For instance:\n *     kuzzle.memoryStorage\n *      .set('myKey', 'myValue')\n *      .get('myKey', function (err, response) {\n *        console.log(response.result);\n *\n *        // { _id: 'foo', body: { value: 'myValue' }}\n *      });\n *\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction KuzzleMemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  this.setHeaders = kuzzle.setHeaders.bind(this);\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * constructs the memoryStorage functions.\n */\n(function() {\n\n  var\n    keyVal = ['id', 'value'],\n    idOrKeys = ['id', 'keys'],\n    commands = {\n      append: keyVal,\n      bgrewriteaof: [],\n      bgsave: [],\n      bitcount: ['id', 'start', 'end'],\n      bitop: ['operation', 'destkey', idOrKeys],\n      bitpos: ['id', 'bit', { __opts__: ['start', 'end']}],\n      blpop: [idOrKeys, 'timeout'],\n      brpoplpush: ['source', 'destination'],\n      dbsize: [],\n      decrby: keyVal,\n      del: [idOrKeys],\n      discard: [],\n      exec: [],\n      exists: [idOrKeys],\n      expire: ['id', 'seconds'],\n      expireat: ['id', 'timestamp'],\n      flushdb: [],\n      // @todo: implement geolocation methods once available in Redis stable release\n      getbit: ['id', 'offset'],\n      getrange: ['id', 'start', 'end'],\n      hdel: ['id', ['field', 'fields']],\n      hexists: ['id', 'field'],\n      hincrby: ['id', 'field', 'value'],\n      hmset: ['id', 'values'],\n      hset: ['id', 'field', 'value'],\n      info: ['section'],\n      keys: [ 'pattern' ],\n      lastsave: [],\n      lindex: ['id', 'idx'],\n      linsert: ['id', 'position', 'pivot', 'value'],\n      lpush: ['id', ['value', 'values']],\n      lrange: ['id', 'start', 'stop'],\n      lrem: ['id', 'count', 'value'],\n      lset: ['id', 'idx', 'value'],\n      ltrim: ['id', 'start', 'stop'],\n      mset: ['values'],\n      multi: [],\n      object: ['subcommand', 'args'],\n      pexpire: ['id', 'milliseconds'],\n      pexpireat: ['id', 'timestamp'],\n      pfadd: ['id', ['element', 'elements']],\n      pfmerge: ['destkey', ['sourcekey', 'sourcekeys']],\n      ping: [],\n      psetex: ['id', 'milliseconds', 'value'],\n      publish: ['channel', 'message'],\n      randomkey: [],\n      rename: ['id', 'newkey'],\n      renamenx: ['id', 'newkey'],\n      restore: ['id', 'ttl', 'content'],\n      rpoplpush: ['source', 'destination'],\n      sadd: ['id', ['member', 'members']],\n      save: [],\n      set: ['id', 'value', {__opts__:['ex', 'px', 'nx', 'xx']}],\n      sdiffstore: ['destination', idOrKeys],\n      setbit: ['id', 'offset', 'value'],\n      setex: ['id', 'seconds', 'value'],\n      setrange: ['id', 'offset', 'value'],\n      sinterstore: ['destination', idOrKeys],\n      sismember: ['id', 'member'],\n      smove: ['id', 'destination', 'member'],\n      sort: ['id', {__opts__:['by', 'offset', 'count', 'get', 'direction', 'alpha', 'store']}],\n      spop: ['id', 'count'],\n      srem: ['id', ['member', 'members']],\n      sunionstore: ['destination', idOrKeys],\n      unwatch: [],\n      wait: ['numslaves', 'timeout'],\n      zadd: ['id', {__opts__: ['nx', 'xx', 'ch', 'incr', 'score', 'member', 'members']}],\n      zcount: ['id', 'min', 'max'],\n      zincrby: ['id', 'value', 'member'],\n      zinterstore: ['destination', idOrKeys, {__opts__: ['weight', 'weights', 'aggregate']}],\n      zlexcount: ['id', 'min', 'max'],\n      zrange: ['id', 'start', 'stop', {__opts__: ['withscores']}],\n      zrangebylex: ['id', 'min', 'max', {__opts__: ['offset', 'count']}],\n      zrangebyscore: ['id', 'min', 'max', {__opts__: ['withscores', 'offset', 'count']}],\n      zrem: ['id', 'member'],\n      zremrangebylex: ['id', 'min', 'max'],\n      zremrangebyscore: ['id', 'min', 'max'],\n      zrevrangebylex: ['id', 'max', 'min', {__opts__: ['offset', 'count']}],\n      zrevrangebyscore: ['id', 'max', 'min', {__opts__: ['withscores', 'offset', 'count']}],\n      zrevrank: ['id', 'member']\n    };\n\n  // unique argument key\n  commands.decr = commands.get = commands.dump = commands.hgetall = commands.hkeys = commands.hlen = commands.hstrlen = commands.hvals = commands.incr = commands.llen = commands.lpop = commands.persist = commands.pttl = commands.rpop = commands.scard = commands.smembers = commands.strlen = commands.ttl = commands.type = commands.zcard = ['id'];\n\n  // key value\n  commands.getset = commands.lpushx = keyVal;\n\n  // key key...\n  commands.del = commands.exists = commands.mget = commands.pfcount = commands.sdiff = commands.sinter = commands.sunion = commands.watch = [idOrKeys];\n\n  commands.incrby = commands.incrbyfloat = commands.decrby;\n  commands.brpop = commands.blpop;\n  commands.hget = commands.hexists;\n  commands.hmget = commands.hdel;\n  commands.hsetnx = commands.hset;\n  commands.msetnx = commands.mset;\n  commands.rpush = commands.lpush;\n  commands.hincrbyfloat = commands.hincrby;\n  commands.srandmember = commands.spop;\n  commands.zrevrange = commands.zrange;\n  commands.zscore = commands.zrevrank;\n\n  Object.keys(commands).forEach(function (command) {\n    KuzzleMemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      if (args.length && typeof args[args.length - 1] === 'object' && Object.keys(args[args.length - 1]).length === 1 && args[args.length - 1].queuable !== undefined) {\n        options = args.pop();\n      }\n\n      commands[command].forEach(function (v, i) {\n        if (args[i] === undefined) {\n          return;\n        }\n\n        if (Array.isArray(v)) {\n          v = Array.isArray(args[i]) ? v[1] : v[0];\n        }\n\n        if (v === 'id') {\n          data._id = args[i];\n        }\n        else {\n          if (!data.body) {\n            data.body = {};\n          }\n\n          if (typeof v === 'object' && v.__opts__ !== undefined) {\n            v.__opts__.forEach(function (arg) {\n              if (args[i][arg] !== undefined) {\n                data.body[arg] = args[i][arg];\n              }\n            });\n          }\n          else {\n            data.body[v] = args[i];\n          }\n        }\n      });\n\n      this.kuzzle.query(query, data, options, cb);\n\n      return this;\n\n    };\n  });\n\n})();\n\nmodule.exports = KuzzleMemoryStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleMemoryStorage.js\n// module id = 10\n// module chunks = 0","var\n  uuid = require('uuid');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then youll receive a notification about it.\n *\n * @param {object} kuzzleDataCollection - an instantiated and valid kuzzle object\n * @param {object} [options] - subscription optional configuration\n * @constructor\n */\nfunction KuzzleRoom(kuzzleDataCollection, options) {\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    callback: {\n      value: null,\n      writable: true\n    },\n    channel: {\n      value: null,\n      writable: true\n    },\n    id: {\n      value: uuid.v4()\n    },\n    lastRenewal: {\n      value: null,\n      writable: true\n    },\n    notifier: {\n      value: null,\n      writable: true\n    },\n    onDoneCB: {\n      value: null,\n      writable: true\n    },\n    queue: {\n      value: [],\n      writable: true\n    },\n    // Delay before allowing a subscription renewal\n    renewalDelay: {\n      value: 500\n    },\n    scope: {\n      value: options && options.scope ? options.scope : 'all'\n    },\n    state: {\n      value: options && options.state ? options.state : 'done'\n    },\n    subscribing: {\n      value: false,\n      writable: true\n    },\n    users: {\n      value: options && options.users ? options.users : 'none'\n    },\n    // read-only properties\n    collection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    filters: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    metadata: {\n      value: (options && options.metadata) ? options.metadata : {},\n      enumerable: true,\n      writable: true\n    },\n    roomId: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    subscribeToSelf: {\n      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['count'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of other subscriptions on that room.\n *\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleRoom.prototype.count = function (cb) {\n  var data;\n\n  this.kuzzle.callbackRequired('KuzzleRoom.count', cb);\n\n  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\n  if (!isReady.call(this)) {\n    this.queue.push({action: 'count', args: [cb]});\n    return;\n  }\n\n  if (!this.roomId) {\n    throw new Error('KuzzleRoom.count: cannot count subscriptions on an inactive room');\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n    cb(err, res && res.result.count);\n  });\n};\n\n/**\n * Renew the subscription using new filters\n *\n * @param {object} [filters] - Filters in Kuzzle DSL format\n * @param {responseCallback} notificationCB - called for each new notification\n * @param {responseCallback} [cb] - handles the query response\n */\nKuzzleRoom.prototype.renew = function (filters, notificationCB, cb) {\n  var\n    now = Date.now(),\n    subscribeQuery = {\n      scope: this.scope,\n      state: this.state,\n      users: this.users\n    },\n    self = this;\n\n  if (typeof filters === 'function') {\n    cb = notificationCB;\n    notificationCB = filters;\n    filters = null;\n  }\n\n  if (!cb) {\n    cb = self.onDoneCB;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleRoom.renew', notificationCB);\n\n  /*\n    Skip subscription renewal if another one was performed a moment before\n   */\n  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n    return cb && cb(new Error('Subscription already renewed less than ' + self.renewalDelay + 'ms ago'));\n  }\n\n  if (filters) {\n    self.filters = filters;\n  }\n\n  /*\n   if not yet connected, register itself to the subscriptions list and wait for the\n   main Kuzzle object to renew once online\n    */\n  if (self.kuzzle.state !== 'connected') {\n    self.callback = notificationCB;\n    self.onDoneCB = cb;\n    self.kuzzle.subscriptions.pending[self.id] = self;\n    return;\n  }\n\n  if (self.subscribing) {\n    self.queue.push({action: 'renew', args: [filters, notificationCB, cb]});\n    return;\n  }\n\n  self.unsubscribe();\n  self.roomId = null;\n  self.subscribing = true;\n  self.callback = notificationCB;\n  self.onDoneCB = cb;\n  self.kuzzle.subscriptions.pending[self.id] = self;\n\n  subscribeQuery.body = self.filters;\n  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, this.headers);\n\n  self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'subscribe'), subscribeQuery, {metadata: self.metadata}, function (error, response) {\n    delete self.kuzzle.subscriptions.pending[self.id];\n    self.subscribing = false;\n\n    if (error) {\n      self.queue = [];\n      return cb && cb(new Error('Error during Kuzzle subscription: ' + error.message));\n    }\n\n    self.lastRenewal = now;\n    self.roomId = response.result.roomId;\n    self.channel = response.result.channel;\n\n    if (!self.kuzzle.subscriptions[self.roomId]) {\n      self.kuzzle.subscriptions[self.roomId] = {};\n    }\n\n    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\n    self.notifier = notificationCallback.bind(self);\n    self.kuzzle.network.on(self.channel, self.notifier);\n\n    dequeue.call(self);\n    cb && cb(null, self);\n  });\n};\n\n/**\n * Unsubscribes from Kuzzle.\n *\n * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n * pending subscriptions reaches 0, and only if there is still no listener on that room.\n * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n *\n * @return {*} this\n */\nKuzzleRoom.prototype.unsubscribe = function () {\n  var\n    self = this,\n    room = self.roomId,\n    interval;\n\n  if (!isReady.call(this)) {\n    self.queue.push({action: 'unsubscribe', args: []});\n    return self;\n  }\n\n  if (room) {\n    self.kuzzle.network.off(self.channel, this.notifier);\n\n    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n      delete self.kuzzle.subscriptions[room];\n\n      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n        self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n      } else {\n        interval = setInterval(function () {\n          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n            if (!self.kuzzle.subscriptions[room]) {\n              self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n            }\n            clearInterval(interval);\n          }\n        }, 100);\n      }\n    } else {\n      delete self.kuzzle.subscriptions[room][self.id];\n    }\n\n    self.roomId = null;\n  }\n\n  return self;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleRoom.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n/**\n * Callback called by the network handler when a message is sent to the subscribed room ID\n * Calls the registered callback if the notification passes the subscription filters\n *\n * @param {object} data - data\n * @returns {*}\n */\nfunction notificationCallback (data) {\n  if (data.error) {\n    return this.callback(data.error);\n  }\n\n  if (data.action === 'jwtTokenExpired') {\n    this.kuzzle.jwtToken = undefined;\n    return this.kuzzle.emitEvent('jwtTokenExpired');\n  }\n\n  if (this.kuzzle.requestHistory[data.requestId]) {\n    if (this.subscribeToSelf) {\n      this.callback(null, data);\n    }\n    delete this.kuzzle.requestHistory[data.requestId];\n  } else {\n    this.callback(null, data);\n  }\n}\n\n\n/**\n * Dequeue actions performed while subscription was being renewed\n */\nfunction dequeue () {\n  var element;\n\n  while (this.queue.length > 0) {\n    element = this.queue.shift();\n\n    this[element.action].apply(this, element.args);\n  }\n}\n\nfunction isReady() {\n  return this.kuzzle.state === 'connected' && !this.subscribing;\n}\n\nmodule.exports = KuzzleRoom;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleRoom.js\n// module id = 11\n// module chunks = 0","/**\n *\n * @param {KuzzleDataCollection} dataCollection\n * @param {int} total\n * @param {KuzzleDocument[]} documents\n * @param {object} [aggregations]\n * @param {object} [searchArgs]\n * @param {KuzzleSearchResult} [previous]\n * @constructor\n */\nfunction KuzzleSearchResult (dataCollection, total, documents, aggregations, searchArgs, previous) {\n  Object.defineProperties(this, {\n    // read-only properties\n    dataCollection: {\n      value: dataCollection,\n    },\n    total: {\n      value: total,\n      enumerable: true\n    },\n    documents: {\n      value: documents,\n      enumerable: true\n    },\n    aggregations: {\n      value: aggregations || {},\n      enumerable: true\n    },\n    searchArgs: {\n      value: searchArgs || {},\n      enumerable: true\n    },\n    // writable properties\n    fetchedDocument: {\n      value: documents.length,\n      enumerable: true,\n      writable: true\n    },\n    _previous: {\n      value: previous || null,\n      writable: true\n    },\n    _next: {\n      value: null,\n      writable: true\n    }\n  });\n\n  if (this._previous instanceof KuzzleSearchResult) {\n    this._previous._next = this;\n    this.fetchedDocument += this._previous.fetchedDocument;\n  }\n\n  // promisifying\n  if (this.dataCollection.kuzzle.bluebird) {\n    return this.dataCollection.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['previous', 'next'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * @param cb\n * @returns {*}\n */\nKuzzleSearchResult.prototype.previous = function (cb) {\n  cb(null, this._previous);\n\n  return this;\n};\n\n/**\n * @param {function} cb\n */\nKuzzleSearchResult.prototype.next = function (cb) {\n  var\n    filters,\n    options = Object.assign({}, this.searchArgs.options),\n    self = this;\n\n  if (!this._next) {\n    // retrieve next results with scroll if original search use it\n    if (options.scrollId) {\n      if (this.fetchedDocument >= this.total) {\n        cb(null, null);\n        return;\n      }\n\n      this.dataCollection.scroll(\n        options.scrollId,\n        options,\n        this.searchArgs.filters || {},\n        function(error, newSearchResults) {\n          handleNextSearchResults(error, self, newSearchResults, cb);\n        }\n      );\n\n      return;\n    }\n    // retrieve next results with from/size if original search use it\n    else if (options.from !== undefined && options.size !== undefined) {\n      filters = Object.assign({}, this.searchArgs.filters);\n\n      // check if we need to do next request to fetch all matching documents\n      options.from += options.size;\n\n      if (options.from >= this.total) {\n        cb(null, null);\n\n        return;\n      }\n\n      this.dataCollection.search(\n        filters,\n        options,\n        function(error, newSearchResults) {\n          handleNextSearchResults(error, self, newSearchResults, cb);\n        }\n      );\n\n      return;\n    }\n  }\n\n  if (this._next instanceof KuzzleSearchResult) {\n    cb(null, this._next);\n\n    return;\n  }\n\n  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n};\n\n/**\n * @param {Error} error\n * @param {KuzzleSearchResult} currentSearchResults\n * @param {KuzzleSearchResult} newSearchResults\n * @param {Function} cb\n */\nfunction handleNextSearchResults (error, currentSearchResults, newSearchResults, cb) {\n  if (error) {\n    cb(error);\n    return;\n  }\n\n  newSearchResults.fetchedDocument += currentSearchResults.fetchedDocument;\n\n  newSearchResults._previous = currentSearchResults;\n  currentSearchResults._next = newSearchResults;\n\n\n  cb(null, newSearchResults);\n}\n\nmodule.exports = KuzzleSearchResult;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleSearchResult.js\n// module id = 12\n// module chunks = 0","/**\n * Sugar-code handling the result of a KuzzleRoom.renew call\n * @constructor\n */\nfunction KuzzleSubscribeResult() {\n  this.cbs = [];\n  this.error = null;\n  this.room = null;\n}\n\n/**\n * Registers a callback to be called with a subscription result\n * @param {Function} cb\n */\nKuzzleSubscribeResult.prototype.onDone = function (cb) {\n  if (this.error || this.room) {\n    cb(this.error, this.room);\n  }\n  else {\n    this.cbs.push(cb);\n  }\n\n  return this;\n};\n\n/**\n * Calls all registered callbacks\n *\n * @param {Object} error object\n * @param {KuzzleRoom} room\n */\nKuzzleSubscribeResult.prototype.done = function (error, room) {\n  this.error = error;\n  this.room = room;\n\n  this.cbs.forEach(function (cb) {\n    cb(error, room);\n  });\n};\n\nmodule.exports = KuzzleSubscribeResult;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleSubscribeResult.js\n// module id = 13\n// module chunks = 0","/**\n *\n * @param host\n * @param wsPort\n * @param ioPort\n * @param sslConnection\n * @returns {Object} tnstantiated WebSocket/Socket.IO object\n */\n\nfunction network(host, wsPort, ioPort, sslConnection) {\n  // Web browser / NodeJS websocket handling\n  if (typeof window !== 'undefined') {\n    // use native websockets if the browser supports it\n    if (typeof WebSocket !== 'undefined') {\n      return new (require('./wrappers/websocket'))(host, wsPort, sslConnection);\n    }\n    // otherwise fallback to socket.io, if available\n    else if (window.io) {\n      return new (require('./wrappers/socketio'))(host, ioPort, sslConnection);\n    }\n\n    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n  }\n\n  return new (require('./wrappers/websocket'))(host, wsPort, sslConnection);\n}\n\nmodule.exports = network;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/index.js\n// module id = 14\n// module chunks = 0","function SocketIO(host, port, ssl) {\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.socket = null;\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: autoReconnect,\n      reconnectionDelay: reconnectionDelay,\n      forceNew: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.socket.on('connect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.socket.on('connect_error', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.socket.on('disconnect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.socket.on('reconnect', callback);\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    this.socket.once(roomId, callback);\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    this.socket.on(roomId, callback);\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    this.socket.off(roomId, callback);\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    this.socket.emit('kuzzle', payload);\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.socket.close();\n    this.socket = null;\n  };\n}\n\nmodule.exports = SocketIO;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/wrappers/socketio.js\n// module id = 15\n// module chunks = 0","var\n  KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\nfunction KuzzleProfile(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nKuzzleProfile.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleProfile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.kuzzleSecurity.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nKuzzleProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nKuzzleProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = KuzzleProfile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleProfile.js\n// module id = 16\n// module chunks = 0","var KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\nfunction KuzzleRole(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nKuzzleRole.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleRole\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleRole} this object\n */\nKuzzleRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = KuzzleRole;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleRole.js\n// module id = 17\n// module chunks = 0","var\n  KuzzleRole = require('./kuzzleRole'),\n  KuzzleProfile = require('./kuzzleProfile'),\n  KuzzleUser = require('./kuzzleUser');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {KuzzleSecurity}\n * @constructor\n */\nfunction KuzzleSecurity(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['roleFactory', 'profileFactory', 'userFactory', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for getRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new KuzzleRole(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nKuzzleSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new KuzzleRole(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleRole(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err) {\n    cb(err, err ? undefined : new KuzzleRole(self, id, content));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new KuzzleRole object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @constructor\n */\nKuzzleSecurity.prototype.roleFactory = function(id, content) {\n  return new KuzzleRole(this, id, content);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for getProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new KuzzleProfile(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new KuzzleProfile(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: response.result.total, profiles: documents });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {object} content - attribute `roles` in `content` must only contains an array of role id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createProfile = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleProfile(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {object} content - a plain javascript object representing the profile's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.updateProfile = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new KuzzleProfile(self, res.result._id, updatedContent));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new KuzzleProfile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @constructor\n */\nKuzzleSecurity.prototype.profileFactory = function(id, content) {\n  return new KuzzleProfile(this, id, content);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for getUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new KuzzleUser(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created wont be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new KuzzleUser(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: response.result.total, users: documents });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same user already exists: throw an error if sets to false.\n *        Replace the existing user otherwise\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'createUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createUser: cannot create a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceUser' : 'createUser';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createRestrictedUser: cannot create a user without a user ID');\n  }\n\n  if (content.profileIds) {\n    throw new Error('KuzzleSecurity.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new KuzzleUser object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @constructor\n */\nKuzzleSecurity.prototype.userFactory = function(id, content) {\n  return new KuzzleUser(this, id, content);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nKuzzleSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nKuzzleSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\nmodule.exports = KuzzleSecurity;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleSecurity.js\n// module id = 18\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v1.js\n// module id = 19\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v4.js\n// module id = 20\n// module chunks = 0"],"sourceRoot":""}
=======
{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kuzzle.js","webpack:///webpack/bootstrap e8d22660bfe8c421070c","webpack:///./src/kuzzle.js","webpack:///./src/security/kuzzleSecurityDocument.js","webpack:///./src/networkWrapper/wrappers/websocket.js","webpack:///./src/security/kuzzleUser.js","webpack:///../~/uuid/uuid.js","webpack:///./src/kuzzleDataCollection.js","webpack:///./src/kuzzleDataMapping.js","webpack:///./src/kuzzleDocument.js","webpack:///./src/kuzzleMemoryStorage.js","webpack:///./src/kuzzleRoom.js","webpack:///./src/kuzzleSearchResult.js","webpack:///./src/kuzzleSubscribeResult.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/networkWrapper/wrappers/socketio.js","webpack:///./src/security/kuzzleProfile.js","webpack:///./src/security/kuzzleRole.js","webpack:///./src/security/kuzzleSecurity.js","webpack:///../~/uuid/lib/rng-browser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Kuzzle","host","options","cb","self","Error","Object","defineProperties","collections","value","writable","connectCB","eventListeners","connected","lastEmitted","listeners","error","disconnected","reconnected","jwtTokenExpired","loginAttempt","offlineQueuePush","offlineQueuePop","queryError","eventTimeout","queuing","requestHistory","state","subscriptions","pending","autoReconnect","enumerable","defaultIndex","undefined","reconnectionDelay","wsPort","ioPort","sslConnection","autoQueue","autoReplay","autoResubscribe","headers","metadata","offlineQueue","queueFilter","queueMaxSize","queueTTL","replayInterval","jwtToken","offlineQueueLoader","keys","forEach","opt","hasOwnProperty","getOwnPropertyDescriptor","offlineMode","defineProperty","query","header","errorMessagePrefix","callback","KuzzleSecurity","event","now","Date","args","Array","prototype","slice","arguments","eventProperties","listener","process","nextTick","fn","apply","KuzzleMemoryStorage","connect","cleanHistory","bluebird","promisifyAll","suffix","filter","name","func","target","passes","whitelist","indexOf","cleanQueue","lastDocumentIndex","index","ts","splice","droppedRequest","emitEvent","length","key","setTimeout","emitRequest","request","network","once","requestId","response","action","message","assign","status","send","dequeue","additionalQueue","uniqueQueue","dequeuingProcess","shift","Math","max","isArray","concat","controller","renewAllSubscriptions","roomId","subscriptionId","subscription","renew","removeAllSubscriptions","unsubscribe","uuid","KuzzleDataCollection","KuzzleUser","networkWrapper","disconnect","onConnect","onConnectError","connectionError","internal","onDisconnect","onReconnect","reconnect","checkToken","err","res","valid","setJwtToken","token","success","result","jwt","JSON","stringify","unsetJwtToken","getJwtToken","login","strategy","credentials","expiresIn","body","queuable","createIndex","logout","v4","callbackRequired","whoAmI","security","_id","_source","getMyRights","hits","updateSelf","content","data","queryArgs","addListener","listenerId","knownEvents","listenerType","isValid","toString","push","getAllStatistics","getStatistics","timestamp","queryCB","startTime","dataCollectionFactory","collection","flushQueue","listCollections","collectionType","arg","type","from","size","listIndexes","indexes","close","getServerInfo","serverInfo","refreshIndex","getAutoRefresh","setAutoRefresh","autoRefresh","attr","object","refresh","meta","addHeaders","removeAllListeners","eventName","removeListener","replayQueue","setDefaultIndex","setHeaders","replace","startQueuing","stopQueuing","KuzzleSecurityDocument","kuzzleSecurity","kuzzle","setContent","serialize","delete","buildQueryArgs","deleteActionName","update","updateActionName","WSNode","port","ssl","WebSocket","e","code","client","wasConnected","retrying","lasturl","url","window","perMessageDeflate","onopen","poke","onclose","onClientError","onerror","onmessage","payload","parse","room","keep","on","off","some","i","readyState","OPEN","create","constructor","setProfiles","profileIds","addProfile","profileId","save","saveRestricted","getProfiles","buff_to_string","buf","offset","bth","_byteToHex","v1","b","clockseq","_clockseq","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","node","_nodeId","n","rnds","random","rng","_rng","ii","_hexToByte","substr","_seedBytes","blacklist","KuzzleSearchResult","KuzzleDocument","KuzzleDataMapping","KuzzleRoom","KuzzleSubscribeResult","count","filters","createDocument","document","updateIfExist","doc","version","_version","deleteDocument","ids","fetchDocument","documentId","fetchAllDocuments","warnEmitted","documents","search","getNextDocuments","searchResult","total","console","warn","next","getMapping","kuzzleMapping","publishMessage","replaceDocument","newDocument","_scroll_id","scrollId","aggregations","scroll","subscribe","subscribeResult","done","bind","truncate","updateDocument","documentFactory","roomFactory","dataMappingFactory","mapping","kuzzleDataCollection","properties","mappings","set","field","dataCollection","publish","values","keyVal","idOrKeys","commands","append","bgrewriteaof","bgsave","bitcount","bitop","bitpos","__opts__","blpop","brpoplpush","dbsize","decrby","del","discard","exec","exists","expire","expireat","flushdb","getbit","getrange","hdel","hexists","hincrby","hmset","hset","info","lastsave","lindex","linsert","lpush","lrange","lrem","lset","ltrim","mset","multi","pexpire","pexpireat","pfadd","pfmerge","ping","psetex","randomkey","rename","renamenx","restore","rpoplpush","sadd","sdiffstore","setbit","setex","setrange","sinterstore","sismember","smove","sort","spop","srem","sunionstore","unwatch","wait","zadd","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrangebyscore","zrem","zremrangebylex","zremrangebyscore","zrevrangebylex","zrevrangebyscore","zrevrank","decr","get","dump","hgetall","hkeys","hlen","hstrlen","hvals","incr","llen","lpop","persist","pttl","rpop","scard","smembers","strlen","ttl","zcard","getset","lpushx","mget","pfcount","sdiff","sinter","sunion","watch","incrby","incrbyfloat","brpop","hget","hmget","hsetnx","msetnx","rpush","hincrbyfloat","srandmember","zrevrange","zscore","command","pop","v","channel","lastRenewal","notifier","onDoneCB","queue","renewalDelay","scope","subscribing","users","subscribeToSelf","notificationCallback","element","isReady","notificationCB","subscribeQuery","interval","setInterval","clearInterval","searchArgs","previous","fetchedDocument","_previous","_next","handleNextSearchResults","currentSearchResults","newSearchResults","cbs","onDone","io","SocketIO","socket","reconnection","forceNew","emit","KuzzleProfile","policies","addPolicy","policy","roleId","setPolicies","map","getPolicies","KuzzleRole","getRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","roleFactory","getProfile","searchProfiles","profiles","createProfile","updateProfile","updatedContent","property","deleteProfile","profileFactory","getUser","searchUsers","createUser","createRestrictedUser","updateUser","deleteUser","userFactory","isActionAllowed","rights","filteredRights","right","item","getUserRights","userId","crypto","msCrypto","getRandomValues","_rnds8","Uint8Array","_rnds","r"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuid = __webpack_require__(4),\n\t  KuzzleDataCollection = __webpack_require__(5),\n\t  KuzzleSecurity = __webpack_require__(16),\n\t  KuzzleMemoryStorage = __webpack_require__(8),\n\t  KuzzleUser = __webpack_require__(3),\n\t  networkWrapper = __webpack_require__(12);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle object constructor.\n\t *\n\t * @constructor\n\t * @param host - Server name or IP Address to the Kuzzle instance\n\t * @param [options] - Connection options\n\t * @param {responseCallback} [cb] - Handles connection response\n\t * @constructor\n\t */\n\tfunction Kuzzle (host, options, cb) {\n\t  var self = this;\n\t\n\t  if (!(this instanceof Kuzzle)) {\n\t    return new Kuzzle(host, options, cb);\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!host || host === '') {\n\t    throw new Error('host argument missing');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // 'private' properties\n\t    collections: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    connectCB: {\n\t      value: cb\n\t    },\n\t    eventListeners: {\n\t      value: {\n\t        connected: {lastEmitted: null, listeners: []},\n\t        error: {lastEmitted: null, listeners: []},\n\t        disconnected: {lastEmitted: null, listeners: []},\n\t        reconnected: {lastEmitted: null, listeners: []},\n\t        jwtTokenExpired: {lastEmitted: null, listeners: []},\n\t        loginAttempt: {lastEmitted: null, listeners: []},\n\t        offlineQueuePush: {listeners: []},\n\t        offlineQueuePop: {listeners: []},\n\t        queryError: {listeners: []}\n\t      }\n\t    },\n\t    eventTimeout: {\n\t      value: 200\n\t    },\n\t    queuing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    requestHistory: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    state: {\n\t      value: 'initializing',\n\t      writable: true\n\t    },\n\t    subscriptions: {\n\t      /*\n\t       Contains the centralized subscription list in the following format:\n\t          pending: <number of pending subscriptions>\n\t          'roomId': {\n\t            kuzzleRoomID_1: kuzzleRoomInstance_1,\n\t            kuzzleRoomID_2: kuzzleRoomInstance_2,\n\t            kuzzleRoomID_...: kuzzleRoomInstance_...\n\t          }\n\t\n\t       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n\t       This structure also allows renewing subscriptions after a connection loss\n\t       */\n\t      value: {\n\t        pending: {}\n\t      },\n\t      writable: true\n\t    },\n\t    // read-only properties\n\t    autoReconnect: {\n\t      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n\t      enumerable: true\n\t    },\n\t    defaultIndex: {\n\t      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    reconnectionDelay: {\n\t      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n\t      enumerable: true\n\t    },\n\t    host: {\n\t      value: host,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    wsPort: {\n\t      value: (options && typeof options.wsPort === 'number') ? options.wsPort : 7513,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    ioPort: {\n\t      value: (options && typeof options.ioPort === 'number') ? options.ioPort : 7512,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    sslConnection: {\n\t      value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n\t      enumerable: true\n\t    },\n\t    autoQueue: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoReplay: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoResubscribe: {\n\t      value: true,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    metadata: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    /*\n\t      Offline queue use the following format:\n\t            [\n\t              {\n\t                ts: <query timestamp>,\n\t                query: 'query',\n\t                cb: callbackFunction\n\t              }\n\t            ]\n\t     */\n\t    offlineQueue: {\n\t      value: [],\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueFilter: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueMaxSize: {\n\t      value: 500,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueTTL: {\n\t      value: 120000,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    replayInterval: {\n\t      value: 10,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    jwtToken: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    offlineQueueLoader: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (options) {\n\t    Object.keys(options).forEach(function (opt) {\n\t      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n\t        self[opt] = options[opt];\n\t      }\n\t    });\n\t\n\t    if (options.offlineMode === 'auto' && this.autoReconnect) {\n\t      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n\t    }\n\t  }\n\t\n\t  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n\t  Object.defineProperty(this, 'isValid', {\n\t    value: function () {\n\t      if (self.state === 'disconnected') {\n\t        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n\t      }\n\t    }\n\t  });\n\t\n\t  // Helper function copying headers to the query data\n\t  Object.defineProperty(this, 'addHeaders', {\n\t    value: function (query, headers) {\n\t      Object.keys(headers).forEach(function (header) {\n\t        if (!query[header]) {\n\t          query[header] = headers[header];\n\t        }\n\t      });\n\t\n\t      return query;\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n\t   * and is called by these methods\n\t   */\n\t  Object.defineProperty(this, 'callbackRequired', {\n\t    value: function (errorMessagePrefix, callback) {\n\t      if (!callback || typeof callback !== 'function') {\n\t        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Create an attribute security that embed all methods to manage Role, Profile and User\n\t   */\n\t  Object.defineProperty(this, 'security', {\n\t    value: new KuzzleSecurity(this),\n\t    enumerable: true\n\t  });\n\t\n\t  /**\n\t   * Emit an event to all registered listeners\n\t   * An event cannot be emitted multiple times before a timeout has been reached.\n\t   */\n\t  Object.defineProperty(this, 'emitEvent', {\n\t    value: function emitEvent(event) {\n\t      var\n\t        now = Date.now(),\n\t        args = Array.prototype.slice.call(arguments, 1),\n\t        eventProperties = this.eventListeners[event];\n\t\n\t      if (eventProperties.lastEmitted && eventProperties.lastEmitted >= now - this.eventTimeout) {\n\t        return false;\n\t      }\n\t\n\t      eventProperties.listeners.forEach(function (listener) {\n\t        process.nextTick(function () {\n\t          listener.fn.apply(undefined, args);\n\t        });\n\t      });\n\t\n\t      // Events without the 'lastEmitted' property can be emitted without minimum time between emissions\n\t      if (eventProperties.lastEmitted !== undefined) {\n\t        eventProperties.lastEmitted = now;\n\t      }\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'memoryStorage', {\n\t    value: new KuzzleMemoryStorage(this),\n\t    enumerable: true\n\t  });\n\t\n\t\n\t  if (!options || !options.connect || options.connect === 'auto') {\n\t    this.connect();\n\t  } else {\n\t    this.state = 'ready';\n\t  }\n\t\n\t  cleanHistory(this.requestHistory);\n\t\n\t  if (this.bluebird) {\n\t    return this.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n\t          'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n\t          'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n\t          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n\t        ];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Connects to a Kuzzle instance using the provided host name.\n\t * @returns {Object} this\n\t */\n\tKuzzle.prototype.connect = function () {\n\t  var self = this;\n\t\n\t  if (self.network) {\n\t    self.disconnect();\n\t  }\n\t\n\t  self.network = networkWrapper(self.host, self.wsPort, self.ioPort, self.sslConnection);\n\t\n\t  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t    return self;\n\t  }\n\t\n\t  self.state = 'connecting';\n\t  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\t\n\t  self.network.onConnect(function () {\n\t    self.state = 'connected';\n\t    renewAllSubscriptions.call(self);\n\t    dequeue.call(self);\n\t    self.emitEvent('connected');\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t  });\n\t\n\t  self.network.onConnectError(function (error) {\n\t    var connectionError = new Error('Unable to connect to kuzzle proxy server at \"' + self.host + '\"');\n\t\n\t    connectionError.internal = error;\n\t    self.state = 'error';\n\t    self.emitEvent('error', connectionError);\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(connectionError);\n\t    }\n\t  });\n\t\n\t  self.network.onDisconnect(function () {\n\t    self.state = 'offline';\n\t\n\t    if (!self.autoReconnect) {\n\t      self.disconnect();\n\t    }\n\t\n\t    if (self.autoQueue) {\n\t      self.queuing = true;\n\t    }\n\t\n\t    self.emitEvent('disconnected');\n\t  });\n\t\n\t  self.network.onReconnect(function () {\n\t    var reconnect = function () {\n\t      // renew subscriptions\n\t      if (self.autoResubscribe) {\n\t        renewAllSubscriptions.call(self);\n\t      }\n\t\n\t      // replay queued requests\n\t      if (self.autoReplay) {\n\t        cleanQueue.call(self);\n\t        dequeue.call(self);\n\t      }\n\t\n\t      // alert listeners\n\t      self.emitEvent('reconnected');\n\t    };\n\t\n\t    self.state = 'connected';\n\t\n\t    if (self.jwtToken) {\n\t      self.checkToken(self.jwtToken, function (err, res) {\n\t        // shouldn't obtain an error but let's invalidate the token anyway\n\t        if (err || !res.valid) {\n\t          self.jwtToken = undefined;\n\t          self.emitEvent('jwtTokenExpired');\n\t        }\n\t\n\t        reconnect();\n\t      });\n\t    } else {\n\t      reconnect();\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the jwtToken used to query kuzzle\n\t * @param token\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.setJwtToken = function(token) {\n\t  if (typeof token === 'string') {\n\t    this.jwtToken = token;\n\t  } else if (typeof token === 'object') {\n\t    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n\t      this.jwtToken = token.result.jwt;\n\t    } else {\n\t      this.emitEvent('loginAttempt', {\n\t        success: false,\n\t        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n\t      });\n\t\n\t      return this;\n\t    }\n\t  } else {\n\t    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n\t    return this;\n\t  }\n\t\n\t  renewAllSubscriptions.call(this);\n\t  this.emitEvent('loginAttempt', {success: true});\n\t  return this;\n\t};\n\t\n\t/**\n\t * Unset the jwtToken used to query kuzzle\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.unsetJwtToken = function() {\n\t  this.jwtToken = undefined;\n\t\n\t  removeAllSubscriptions.call(this);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Get the jwtToken used by kuzzle\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.getJwtToken = function() {\n\t  return this.jwtToken;\n\t};\n\t\n\t/**\n\t * Send login request to kuzzle with credentials\n\t * If login success, store the jwtToken into kuzzle object\n\t *\n\t * @param strategy\n\t * @param credentials\n\t * @param expiresIn\n\t * @param cb\n\t */\n\tKuzzle.prototype.login = function (strategy) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      strategy: strategy\n\t    },\n\t    credentials,\n\t    cb = null;\n\t\n\t  // Handle arguments (credentials, expiresIn, cb)\n\t  if (arguments[1]) {\n\t    if (typeof arguments[1] === 'object') {\n\t      credentials = arguments[1];\n\t    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n\t      request.expiresIn = arguments[1];\n\t    } else if (typeof arguments[1] === 'function') {\n\t      cb = arguments[1];\n\t    }\n\t  }\n\t  if (arguments[2]) {\n\t    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n\t      request.expiresIn = arguments[2];\n\t    } else if (typeof arguments[2] === 'function') {\n\t      cb = arguments[2];\n\t    }\n\t  }\n\t  if (arguments[3] && typeof arguments[3] === 'function') {\n\t    cb = arguments[3];\n\t  }\n\t\n\t  if (typeof credentials === 'object') {\n\t    Object.keys(credentials).forEach(function (key) {\n\t      request[key] = credentials[key];\n\t    });\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'login'}, {body: request}, {queuable: false}, function(error, response) {\n\t    if (!error) {\n\t      if (response.result.jwt) {\n\t        self.setJwtToken(response.result.jwt);\n\t      }\n\t\n\t      cb && cb(null, response.result);\n\t    }\n\t    else {\n\t      cb && cb(error);\n\t      self.emitEvent('loginAttempt', {success: false, error: error.message});\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Create a kuzzle index\n\t *\n\t * @param {string} index\n\t * @param {object} [options]\n\t * @param {responseCallback} cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.createIndex = function (index, options, cb) {\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.createIndex: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.query({controller: 'admin', action: 'createIndex'}, {index: index}, options, typeof cb !== 'function' ? null : cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Send logout request to kuzzle with jwtToken.\n\t *\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.logout = function (cb) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      action: 'logout',\n\t      controller: 'auth',\n\t      requestId: uuid.v4(),\n\t      body: {}\n\t    };\n\t\n\t  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, typeof cb !== 'function' ? null : function(error) {\n\t    cb(error, self);\n\t  });\n\t\n\t  self.unsetJwtToken();\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Checks whether a given jwt token still represents a valid session in Kuzzle.\n\t *\n\t * @param  {string}   token     The jwt token to check\n\t * @param  {function} callback  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t */\n\tKuzzle.prototype.checkToken = function (token, callback) {\n\t  var\n\t    request = {\n\t      body: {\n\t        token: token\n\t      }\n\t    };\n\t\n\t  this.callbackRequired('Kuzzle.checkToken', callback);\n\t\n\t  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, response) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t\n\t    callback(null, response.result);\n\t  });\n\t};\n\t\n\t/**\n\t * Fetches the current user.\n\t *\n\t * @param  {function} callback  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t */\n\tKuzzle.prototype.whoAmI = function (callback) {\n\t  var self = this;\n\t\n\t  self.callbackRequired('Kuzzle.whoAmI', callback);\n\t\n\t  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, response) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t\n\t    callback(null, new KuzzleUser(self.security, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Gets the rights array of the currently logged user.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param  {function} cb The callback containing the normalized array of rights.\n\t */\n\tKuzzle.prototype.getMyRights = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.callbackRequired('Kuzzle.getMyRights', cb);\n\t\n\t  self.query({controller: 'auth', action:'getMyRights'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Update current user in Kuzzle.\n\t *\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {Kuzzle} this object\n\t */\n\tKuzzle.prototype.updateSelf = function (content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data.body = content;\n\t\n\t  self.query(queryArgs, data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n\t */\n\tfunction cleanQueue () {\n\t  var\n\t    self = this,\n\t    now = Date.now(),\n\t    lastDocumentIndex = -1;\n\t\n\t  if (self.queueTTL > 0) {\n\t    self.offlineQueue.forEach(function (query, index) {\n\t      if (query.ts < now - self.queueTTL) {\n\t        lastDocumentIndex = index;\n\t      }\n\t    });\n\t\n\t    if (lastDocumentIndex !== -1) {\n\t      self.offlineQueue\n\t        .splice(0, lastDocumentIndex + 1)\n\t        .forEach(function (droppedRequest) {\n\t          self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t        });\n\t    }\n\t  }\n\t\n\t  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n\t    self.offlineQueue\n\t      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n\t      .forEach(function (droppedRequest) {\n\t        self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t      });\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Clean history from requests made more than 10s ago\n\t */\n\tfunction cleanHistory (requestHistory) {\n\t  var\n\t    now = Date.now();\n\t\n\t  Object.keys(requestHistory).forEach(function (key) {\n\t    if (requestHistory[key] < now - 10000) {\n\t      delete requestHistory[key];\n\t    }\n\t  });\n\t\n\t  setTimeout(function () {\n\t    cleanHistory(requestHistory);\n\t  }, 1000);\n\t}\n\t\n\t/**\n\t * Emit a request to Kuzzle\n\t *\n\t * @param {object} request\n\t * @param {responseCallback} [cb]\n\t */\n\tfunction emitRequest (request, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (self.jwtToken !== undefined || cb) {\n\t    self.network.once(request.requestId, function (response) {\n\t      var error = null;\n\t\n\t      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n\t        self.jwtToken = undefined;\n\t        self.emitEvent('jwtTokenExpired', request, cb);\n\t      }\n\t\n\t      if (response.error) {\n\t        error = new Error(response.error.message);\n\t        Object.assign(error, response.error);\n\t        error.status = response.status;\n\t        self.emitEvent('queryError', error, request, cb);\n\t      }\n\t\n\t      if (cb) {\n\t        cb(error, response);\n\t      }\n\t    });\n\t  }\n\t\n\t  this.network.send(request);\n\t\n\t  // Track requests made to allow KuzzleRoom.subscribeToSelf to work\n\t  self.requestHistory[request.requestId] = Date.now();\n\t}\n\t\n\t/**\n\t * Play all queued requests, in order.\n\t */\n\tfunction dequeue () {\n\t  var\n\t    self = this,\n\t    additionalQueue,\n\t    uniqueQueue = {},\n\t    dequeuingProcess = function () {\n\t      if (self.offlineQueue.length > 0) {\n\t        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n\t        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\t\n\t        setTimeout(function () {\n\t          dequeuingProcess();\n\t        }, Math.max(0, self.replayInterval));\n\t      } else {\n\t        self.queuing = false;\n\t      }\n\t    };\n\t\n\t  if (self.offlineQueueLoader) {\n\t    if (typeof self.offlineQueueLoader !== 'function') {\n\t      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n\t    }\n\t\n\t    additionalQueue = self.offlineQueueLoader();\n\t    if (Array.isArray(additionalQueue)) {\n\t      self.offlineQueue = additionalQueue\n\t        .concat(self.offlineQueue)\n\t        .filter(function (request) {\n\t          // throws if the query object does not contain required attributes\n\t          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n\t            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n\t          }\n\t\n\t          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n\t        });\n\t    } else {\n\t      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n\t    }\n\t  }\n\t\n\t  dequeuingProcess();\n\t}\n\t\n\t/**\n\t * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n\t * successful login attempt\n\t */\n\tfunction renewAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.renew(subscription.callback);\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Remove all registered subscriptions. Triggered either by a logout query or by un-setting the token\n\t */\n\tfunction removeAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.unsubscribe();\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n\t * insertion.\n\t *\n\t * The ID returned by this function is required to remove this listener at a later time.\n\t *\n\t * @param {string} event - name of the global event to subscribe to (see the 'eventListeners' object property)\n\t * @param {function} listener - callback to invoke each time an event is fired\n\t * @returns {string} Unique listener ID\n\t */\n\tKuzzle.prototype.addListener = function(event, listener) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    listenerType = typeof listener,\n\t    listenerId;\n\t\n\t  this.isValid();\n\t\n\t  if (knownEvents.indexOf(event) === -1) {\n\t    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t  }\n\t\n\t  if (listenerType !== 'function') {\n\t    throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n\t  }\n\t\n\t  listenerId = uuid.v4();\n\t  this.eventListeners[event].listeners.push({id: listenerId, fn: listener});\n\t  return listenerId;\n\t};\n\t\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method returns all available statistics from Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getAllStatistics = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\t\n\t  this.query({controller:'server', action: 'getAllStats'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n\t *\n\t * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n\t  var\n\t    queryCB,\n\t    body;\n\t\n\t  if (!cb) {\n\t    if (arguments.length === 1) {\n\t      cb = arguments[0];\n\t      options = null;\n\t      timestamp = null;\n\t    } else {\n\t      cb = arguments[1];\n\t      if (typeof arguments[0] === 'object') {\n\t        options = arguments[0];\n\t        timestamp = null;\n\t      } else {\n\t        timestamp = arguments[0];\n\t        options = null;\n\t      }\n\t    }\n\t  }\n\t\n\t  queryCB = function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, timestamp ? res.result.hits : [res.result]);\n\t  };\n\t\n\t  this.callbackRequired('Kuzzle.getStatistics', cb);\n\t\n\t  body = timestamp ? {body: {startTime: timestamp}} : {};\n\t  this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n\t};\n\t\n\t/**\n\t * Create a new instance of a KuzzleDataCollection object.\n\t * If no index is specified, takes the default index.\n\t *\n\t * @param {string} collection - The name of the data collection you want to manipulate\n\t * @param {string} [index] - The name of the data index containing the data collection\n\t * @returns {KuzzleDataCollection} A KuzzleDataCollection instance\n\t */\n\tKuzzle.prototype.dataCollectionFactory = function(collection, index) {\n\t  this.isValid();\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Unable to create a new data collection object: no index specified');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (typeof index !== 'string' || typeof collection !== 'string') {\n\t    throw new Error('Invalid index or collection argument: string expected');\n\t  }\n\t\n\t  if (!this.collections[index]) {\n\t    this.collections[index] = {};\n\t  }\n\t\n\t  if (!this.collections[index][collection]) {\n\t    this.collections[index][collection] = new KuzzleDataCollection(this, collection, index);\n\t  }\n\t\n\t  return this.collections[index][collection];\n\t};\n\t\n\t/**\n\t * Empties the offline queue without replaying it.\n\t *\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.flushQueue = function () {\n\t  this.offlineQueue = [];\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns the list of known persisted data collections.\n\t *\n\t * @param {string} [index] - Index containing collections to be listed\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.listCollections = function () {\n\t  var\n\t    collectionType = 'all',\n\t    index,\n\t    options,\n\t    cb,\n\t    args = Array.prototype.slice.call(arguments),\n\t    query;\n\t\n\t  args.forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.listCollections: index required');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listCollections', cb);\n\t\n\t  if (options && options.type) {\n\t    collectionType = options.type;\n\t  }\n\t\n\t  query = {body: {type: collectionType}};\n\t\n\t  if (options && options.from) {\n\t    query.body.from = options.from;\n\t  }\n\t\n\t  if (options && options.size) {\n\t    query.body.size = options.size;\n\t  }\n\t\n\t  this.query({index: index, controller: 'collection', action: 'list'}, query, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.collections);\n\t  });\n\t};\n\t\n\t/**\n\t * Returns the list of existing indexes in Kuzzle\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.listIndexes = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listIndexes', cb);\n\t\n\t  this.query({controller: 'index', action: 'list'}, {}, options, function (err, res) {\n\t    cb(err, err ? undefined : res.result.indexes);\n\t  });\n\t};\n\t\n\t/**\n\t * Disconnects from Kuzzle and invalidate this instance.\n\t */\n\tKuzzle.prototype.disconnect = function () {\n\t  var collection;\n\t\n\t  this.state = 'disconnected';\n\t  this.network.close();\n\t  this.network = null;\n\t\n\t  for (collection in this.collections) {\n\t    if (this.collections.hasOwnProperty(collection)) {\n\t      delete this.collections[collection];\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the server informations\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getServerInfo = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\t\n\t  this.query({controller: 'server', action: 'info'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.serverInfo);\n\t  });\n\t};\n\t\n\t/**\n\t * Forces an index refresh\n\t *\n\t * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.refreshIndex = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.refreshIndex: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.query({ index: index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns de current autoRefresh status for the given index\n\t *\n\t * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optinal arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.getAutoRefresh = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.getAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n\t  this.query({ index: index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n\t};\n\t\n\t/**\n\t * (Un)Sets the autoRefresh flag on the given index\n\t *\n\t * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n\t * @param {boolean} autoRefresh - The autoRefresh value to set\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query result\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.setAutoRefresh = function () {\n\t  var\n\t    index,\n\t    autoRefresh,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'boolean':\n\t        autoRefresh = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.setAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (autoRefresh === undefined) {\n\t    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n\t  }\n\t\n\t  this.query({ index: index, controller: 'index', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return the current Kuzzle's UTC Epoch time, in milliseconds\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzle.prototype.now = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.now', cb);\n\t\n\t  this.query({controller: 'server', action: 'now'}, {}, options, function (err, res) {\n\t    cb(err, res && res.result.now);\n\t  });\n\t};\n\t\n\t/**\n\t * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n\t * Base method used to send read queries to Kuzzle\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} queryArgs - Query configuration\n\t * @param {object} query - The query data\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n\t  var\n\t    attr,\n\t    object = {\n\t      action: queryArgs.action,\n\t      controller: queryArgs.controller,\n\t      metadata: this.metadata\n\t    },\n\t    self = this;\n\t\n\t  this.isValid();\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options) {\n\t    if (options.queuable === false && self.state === 'offline') {\n\t      return self;\n\t    }\n\t\n\t    if (options.refresh) {\n\t      object.refresh = options.refresh;\n\t    }\n\t\n\t    if (options.from) {\n\t      object.from = options.from;\n\t    }\n\t\n\t    if (options.size) {\n\t      object.size = options.size;\n\t    }\n\t\n\t    if (options.metadata) {\n\t      Object.keys(options.metadata).forEach(function (meta) {\n\t        object.metadata[meta] = options.metadata[meta];\n\t      });\n\t    }\n\t  }\n\t\n\t  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n\t    throw new Error('Invalid query parameter: ' + query);\n\t  }\n\t\n\t  if (query.metadata) {\n\t    Object.keys(query.metadata).forEach(function (meta) {\n\t      object.metadata[meta] = query.metadata[meta];\n\t    });\n\t  }\n\t\n\t  for (attr in query) {\n\t    if (attr !== 'metadata' && query.hasOwnProperty(attr)) {\n\t      object[attr] = query[attr];\n\t    }\n\t  }\n\t\n\t  object = self.addHeaders(object, this.headers);\n\t\n\t  /*\n\t   * Do not add the token for the checkToken route, to avoid getting a token error when\n\t   * a developer simply wish to verify his token\n\t   */\n\t  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n\t    object.jwt = self.jwtToken;\n\t  }\n\t\n\t  if (queryArgs.collection) {\n\t    object.collection = queryArgs.collection;\n\t  }\n\t\n\t  if (queryArgs.index) {\n\t    object.index = queryArgs.index;\n\t  }\n\t\n\t  if (!object.requestId) {\n\t    object.requestId = uuid.v4();\n\t  }\n\t\n\t  if (self.state === 'connected' || (options && options.queuable === false)) {\n\t    if (self.state === 'connected') {\n\t      emitRequest.call(this, object, cb);\n\t    } else if (cb) {\n\t      cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n\t    }\n\t  } else if (self.queuing || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n\t    cleanQueue.call(this, object, cb);\n\t\n\t    if (!self.queueFilter || self.queueFilter(object)) {\n\t      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n\t      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n\t    }\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Removes all listeners, either from a specific event or from all events\n\t *\n\t * @param {string} event - One of the event described in the Event Handling section of this documentation\n\t * @returns {Kuzzle} this object\n\t */\n\tKuzzle.prototype.removeAllListeners = function (event) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    self = this;\n\t\n\t  if (event) {\n\t    if (knownEvents.indexOf(event) === -1) {\n\t      throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t    }\n\t\n\t    this.eventListeners[event].listeners = [];\n\t  } else {\n\t    knownEvents.forEach(function (eventName) {\n\t      self.eventListeners[eventName].listeners = [];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Removes a listener from an event.\n\t *\n\t * @param {string} event - One of the event described in the Event Handling section of this documentation\n\t * @param {string} listenerId - The ID returned by addListener\n\t * @returns {Kuzzle} this object\n\t */\n\tKuzzle.prototype.removeListener = function (event, listenerId) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    self = this;\n\t\n\t  if (knownEvents.indexOf(event) === -1) {\n\t    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t  }\n\t\n\t  this.eventListeners[event].listeners.forEach(function (listener, index) {\n\t    if (listener.id === listenerId) {\n\t      self.eventListeners[event].listeners.splice(index, 1);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replays the requests queued during offline mode.\n\t * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n\t */\n\tKuzzle.prototype.replayQueue = function () {\n\t  if (this.state !== 'offline' && !this.autoReplay) {\n\t    cleanQueue.call(this);\n\t    dequeue.call(this);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the default Kuzzle index\n\t *\n\t * @param index\n\t * @returns this\n\t */\n\tKuzzle.prototype.setDefaultIndex = function (index) {\n\t  if (typeof index !== 'string') {\n\t    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n\t  }\n\t\n\t  if (index.length === 0) {\n\t    throw new Error('Cannot set an empty index as the default index');\n\t  }\n\t\n\t  this.defaultIndex = index;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzle.prototype.setHeaders = function (content, replace) {\n\t  var self = this;\n\t\n\t  if (typeof content !== 'object' || Array.isArray(content)) {\n\t    throw new Error('Expected a content object, received a ' + typeof content);\n\t  }\n\t\n\t  if (replace) {\n\t    self.headers = content;\n\t  } else {\n\t    Object.keys(content).forEach(function (key) {\n\t      self.headers[key] = content[key];\n\t    });\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.startQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = true;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.stopQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = false;\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = Kuzzle;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tfunction KuzzleSecurityDocument(kuzzleSecurity, id, content) {\n\t\n\t  if (!id) {\n\t    throw new Error('A security document must have an id');\n\t  }\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    kuzzle: {\n\t      value: kuzzleSecurity.kuzzle\n\t    },\n\t    kuzzleSecurity: {\n\t      value: kuzzleSecurity\n\t    },\n\t    // read-only properties\n\t    // writable properties\n\t    id: {\n\t      value: id,\n\t      enumerable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (content) {\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'update'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {Object} data - New securityDocument content\n\t * @return {KuzzleSecurityDocument} this\n\t */\n\tKuzzleSecurityDocument.prototype.setContent = function (data) {\n\t  this.content = data;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a pojo\n\t *\n\t * @return {object} pojo representing this securityDocument\n\t */\n\tKuzzleSecurityDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Delete the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleSecurityDocument.prototype.delete = function (options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, res.result._id);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} content - Content to add to KuzzleSecurityDocument\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurityDocument} this\n\t */\n\tKuzzleSecurityDocument.prototype.update = function (content, options, cb) {\n\t  var\n\t    data = {},\n\t    self = this;\n\t\n\t  if (typeof content !== 'object') {\n\t    throw new Error('Parameter \"content\" must be a object');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = self.id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.setContent(response.result._source);\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleSecurityDocument;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tfunction WSNode(host, port, ssl) {\n\t  var self = this;\n\t  this.WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"ws\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t  this.host = host;\n\t  this.port = port;\n\t  this.ssl = ssl;\n\t  this.client = null;\n\t  this.wasConnected = false;\n\t  this.retrying = false;\n\t  this.lasturl = null;\n\t\n\t  /*\n\t   Listeners are stored using the following format:\n\t   roomId: {\n\t   fn: callback_function,\n\t   once: boolean\n\t   }\n\t   */\n\t  this.listeners = {\n\t    error: [],\n\t    connect: [],\n\t    disconnect: [],\n\t    reconnect: []\n\t  };\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   * @returns {Object} Socket\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    var\n\t      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n\t      options = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\t\n\t    if (url !== this.lasturl) {\n\t      self.wasConnected = false;\n\t      this.lasturl = url;\n\t    }\n\t\n\t    this.client = new this.WebSocket(url, options);\n\t\n\t    this.client.onopen = function () {\n\t      if (self.wasConnected) {\n\t        poke(self.listeners, 'reconnect');\n\t      }\n\t      else {\n\t        poke(self.listeners, 'connect');\n\t      }\n\t      self.wasConnected = true;\n\t    };\n\t\n\t    this.client.onclose = function (code, message) {\n\t      if (code === 1000) {\n\t        poke(self.listeners, 'disconnect');\n\t      }\n\t      else {\n\t        onClientError.call(self, autoReconnect, reconnectionDelay, message);\n\t      }\n\t    };\n\t\n\t    this.client.onerror = function (error) {\n\t      onClientError.call(self, autoReconnect, reconnectionDelay, error);\n\t    };\n\t\n\t    this.client.onmessage = function (payload) {\n\t      var data = JSON.parse(payload.data || payload);\n\t\n\t      if (data.room && self.listeners[data.room]) {\n\t        poke(self.listeners, data.room, data);\n\t      }\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    this.listeners.connect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    this.listeners.error.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    this.listeners.disconnect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    this.listeners.reconnect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room. Once 1 message is received, fires the\n\t   * callback and unregister it afterward.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.once = function (roomId, callback) {\n\t    if (!this.listeners[roomId]) {\n\t      this.listeners[roomId] = [];\n\t    }\n\t\n\t    this.listeners[roomId].push({\n\t      fn: callback,\n\t      keep: false\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.on = function (roomId, callback) {\n\t    if (!this.listeners[roomId]) {\n\t      this.listeners[roomId] = [];\n\t    }\n\t\n\t    this.listeners[roomId].push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Unregisters a callback from a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.off = function (roomId, callback) {\n\t    var index = -1;\n\t\n\t    if (this.listeners[roomId]) {\n\t      // Array.findIndex is not supported by internet explorer\n\t      this.listeners[roomId].some(function (listener, i) {\n\t        if (listener.fn === callback) {\n\t          index = i;\n\t          return true;\n\t        }\n\t\n\t        return false;\n\t      });\n\t\n\t      if (index !== -1) {\n\t        if (this.listeners[roomId].length === 1 && ['error', 'connect', 'disconnect', 'reconnect'].indexOf(roomId) === -1) {\n\t          delete this.listeners[roomId];\n\t        }\n\t        else {\n\t          this.listeners[roomId].splice(index, 1);\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    if (this.client && this.client.readyState === this.client.OPEN) {\n\t      this.client.send(JSON.stringify(payload));\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.listeners = {\n\t      error: [],\n\t      connect: [],\n\t      disconnect: [],\n\t      reconnect: []\n\t    };\n\t\n\t    this.wasConnected = false;\n\t    this.client.close();\n\t    this.client = null;\n\t  };\n\t}\n\t\n\t/**\n\t * Executes all registered listeners in the provided\n\t * \"listeners\" structure.\n\t *\n\t * Listeners are of the following format:\n\t * [\n\t *    { fn: callback, once: boolean },\n\t *    ...\n\t * ]\n\t *\n\t * @private\n\t * @param {Object} listeners\n\t * @param {string} roomId\n\t * @param {Object} [payload]\n\t */\n\tfunction poke (listeners, roomId, payload) {\n\t  var\n\t    i,\n\t    length = listeners[roomId].length;\n\t\n\t  for (i = 0; i < length; ++i) {\n\t    listeners[roomId][i].fn(payload);\n\t\n\t    if (!listeners[roomId][i].keep) {\n\t      if (listeners[roomId].length > 1) {\n\t        listeners[roomId].splice(i, 1);\n\t        --i;\n\t        --length;\n\t      }\n\t      else {\n\t        delete listeners[roomId];\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Called when the connection closes with an error state\n\t *\n\t * @param {boolean} autoReconnect\n\t * @param {number} reconnectionDelay\n\t * @param {string|Object} message\n\t */\n\tfunction onClientError(autoReconnect, reconnectionDelay, message) {\n\t  var self = this;\n\t\n\t  if (autoReconnect && !self.retrying) {\n\t    self.retrying = true;\n\t    setTimeout(function () {\n\t      self.retrying = false;\n\t      self.connect(autoReconnect, reconnectionDelay);\n\t    }, reconnectionDelay);\n\t  }\n\t\n\t  poke(self.listeners, 'error', message);\n\t}\n\t\n\tmodule.exports = WSNode;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\t/**\n\t * @param {KuzzleSecurity} kuzzleSecurity\n\t * @param {string} id\n\t * @param {Object} content\n\t * @constructor\n\t */\n\tfunction KuzzleUser(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteUser'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateUser'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save', 'saveRestricted'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tKuzzleUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleUser\n\t  }\n\t});\n\t\n\t/**\n\t * Set profiles in content\n\t * @param {array} profileIds - an array of profiles ids string\n\t *\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.setProfiles = function (profileIds) {\n\t  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n\t    throw new Error('Parameter \"profileIds\" must be an array of strings');\n\t  }\n\t\n\t  this.content.profileIds = profileIds;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a profile\n\t * @param {string} profileId - a profile ids string\n\t *\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.addProfile = function (profileId) {\n\t  if (typeof profileId !== 'string') {\n\t    throw new Error('Parameter \"profileId\" must be a string');\n\t  }\n\t\n\t  if (!this.content.profileIds) {\n\t    this.content.profileIds = [];\n\t  }\n\t\n\t  if (this.content.profileIds.indexOf(profileId) === -1) {\n\t    this.content.profileIds.push(profileId);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Saves this user into Kuzzle.\n\t *\n\t * If this is a new user, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this user in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Saves this user as restricted into Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.saveRestricted = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tKuzzleUser.prototype.serialize = function () {\n\t  return {_id: this.id, body: this.content};\n\t};\n\t\n\t/**\n\t * Return the associated profiles IDs\n\t *\n\t * @return {array} the associated profiles IDs\n\t */\n\tKuzzleUser.prototype.getProfiles = function () {\n\t  return this.content.profileIds;\n\t};\n\t\n\tmodule.exports = KuzzleUser;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  We feature\n\t// detect to determine the best RNG source, normalizing to a function that\n\t// returns 128-bits of randomness, since that's what's usually required\n\tvar _rng = __webpack_require__(17);\n\t\n\t// Maps for number <-> hex string conversion\n\tvar _byteToHex = [];\n\tvar _hexToByte = {};\n\tfor (var i = 0; i < 256; ++i) {\n\t  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t  _hexToByte[_byteToHex[i]] = i;\n\t}\n\t\n\tfunction buff_to_string(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = _byteToHex;\n\t  return  bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\t\n\t// random #'s we need to init node and clockseq\n\tvar _seedBytes = _rng();\n\t\n\t// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\tvar _nodeId = [\n\t  _seedBytes[0] | 0x01,\n\t  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n\t];\n\t\n\t// Per 4.2.2, randomize (14 bit) clockseq\n\tvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\t\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0, _lastNSecs = 0;\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || [];\n\t\n\t  options = options || {};\n\t\n\t  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\t\n\t  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\t\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\t\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\t\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\t\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\t\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t  }\n\t\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\t\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\t\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\t\n\t  // `time_mid`\n\t  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\t\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\t\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\t\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\t\n\t  // `node`\n\t  var node = options.node || _nodeId;\n\t  for (var n = 0; n < 6; ++n) {\n\t    b[i + n] = node[n];\n\t  }\n\t\n\t  return buf ? buf : buff_to_string(b);\n\t}\n\t\n\t// **`v4()` - Generate random UUID**\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v4(options, buf, offset) {\n\t  // Deprecated - 'format' argument, as supported in v1.2\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || _rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || buff_to_string(rnds);\n\t}\n\t\n\t// Export public API\n\tvar uuid = v4;\n\tuuid.v1 = v1;\n\tuuid.v4 = v4;\n\t\n\tmodule.exports = uuid;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSearchResult = __webpack_require__(10),\n\t  KuzzleDocument = __webpack_require__(7),\n\t  KuzzleDataMapping = __webpack_require__(6),\n\t  KuzzleRoom = __webpack_require__(9),\n\t  KuzzleSubscribeResult = __webpack_require__(11);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n\t * or like a room for pub/sub messages.\n\t *\n\t * @property {string} collection\n\t * @property {string} index\n\t * @property {Kuzzle} kuzzle\n\t * @property {Array.<string>} collection\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @param {string} collection - name of the data collection to handle\n\t * @param {string} index - Index containing the data collection\n\t * @constructor\n\t */\n\tfunction KuzzleDataCollection(kuzzle, collection, index) {\n\t  if (!index || !collection) {\n\t    throw new Error('The KuzzleDataCollection object constructor needs an index and a collection arguments');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    index: {\n\t      value: index,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (controller, action) {\n\t      return {\n\t        controller: controller,\n\t        action: action,\n\t        collection: this.collection,\n\t        index: this.index\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of documents matching the provided set of filters.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleDataCollection.prototype.count = function (filters, options, cb) {\n\t  var\n\t    query;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.count', cb);\n\t\n\t  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (error, result) {\n\t    cb(error, result && result.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new empty data collection, with no associated mapping.\n\t * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n\t * want to create and prepare data collections before storing documents in it.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.create = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *    - updateIfExist (boolean, default: false):\n\t *        If the same document already exists: throw an error if sets to false.\n\t *        Update the existing document otherwise\n\t *\n\t * @param {string} [id] - (optional) document identifier\n\t * @param {object} document - either an instance of a KuzzleDocument object, or a document\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.createDocument = function (id, document, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'create';\n\t\n\t  if (id && typeof id !== 'string') {\n\t    cb = options;\n\t    options = document;\n\t    document = id;\n\t    id = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (document instanceof KuzzleDocument) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  if (options) {\n\t    action = options.updateIfExist ? 'createOrReplace' : 'create';\n\t  }\n\t\n\t  if (id) {\n\t    data._id = id;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, self.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    var doc;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    doc = new KuzzleDocument(self, res.result._id, res.result._source);\n\t    doc.version = res.result._version;\n\t    cb(null, doc);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete persistent documents.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleDataCollection} this\n\t */\n\tKuzzleDataCollection.prototype.deleteDocument = function (arg, options, cb) {\n\t  var\n\t    action,\n\t    data = {};\n\t\n\t  if (typeof arg === 'string') {\n\t    data._id = arg;\n\t    action = 'delete';\n\t  } else {\n\t    data.body = arg;\n\t    action = 'deleteByQuery';\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      cb(err);\n\t    }\n\t    else {\n\t      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieve a single stored document using its unique document ID.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleDataCollection.prototype.fetchDocument = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleDataCollection.fetch', cb);\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new KuzzleDocument(self, res.result._id, res.result._source);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t};\n\t\n\t/**\n\t * Retrieves all documents stored in this data collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleDataCollection.prototype.fetchAllDocuments = function (options, cb) {\n\t  var\n\t    warnEmitted = false,\n\t    documents = [],\n\t    filters = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  // copying pagination options to the search filter\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t\n\t  if (!options.from) {\n\t    options.from = 0;\n\t  }\n\t\n\t  if (!options.size) {\n\t    options.size = 1000;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.fetchAllDocuments', cb);\n\t\n\t  this.search(filters, options, function getNextDocuments (error, searchResult) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    if (searchResult instanceof KuzzleSearchResult) {\n\t      if (searchResult.total > 10000 && !warnEmitted) {\n\t        warnEmitted = true;\n\t        console.warn('KuzzleDataCollection.fetchAllDocuments may return extremely large amounts of documents, which may cause performance issues. Unless you know what you are doing, consider using KuzzleDataCollection.search or KuzzleDataCollection.scroll instead'); // eslint-disable-line no-console\n\t      }\n\t\n\t      searchResult.documents.forEach(function(document) {\n\t        documents.push(document);\n\t      });\n\t      searchResult.next(getNextDocuments);\n\t    }\n\t    else {\n\t      cb(null, documents);\n\t    }\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Instantiates a KuzzleDataMapping object containing the current mapping of this collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated KuzzleDataMapping object\n\t */\n\tKuzzleDataCollection.prototype.getMapping = function (options, cb) {\n\t  var kuzzleMapping;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.getMapping', cb);\n\t\n\t  kuzzleMapping = new KuzzleDataMapping(this);\n\t  kuzzleMapping.refresh(options, cb);\n\t};\n\t\n\t/**\n\t * Publish a realtime message\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} document - either a KuzzleDocument instance or a JSON object\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.publishMessage = function (document, options, cb) {\n\t  var data = {};\n\t\n\t  if (document instanceof KuzzleDocument) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replace an existing document with a new one.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to replace\n\t * @param {object} content - JSON object representing the new document version\n\t * @param {object} [options] - additional arguments\n\t * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n\t * @return {object} this\n\t */\n\tKuzzleDataCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new KuzzleDocument(self, res.result._id, res.result._source);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Executes an advanced search on the data collection.\n\t *\n\t * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function.\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\t\n\tKuzzleDataCollection.prototype.search = function (filters, options, cb) {\n\t  var\n\t    query,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleDataCollection.search', cb);\n\t\n\t  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      result.result.aggregations ? result.result.aggregations : [],\n\t      {options: options, filters: filters}\n\t    ));\n\t  });\n\t};\n\t\n\t/**\n\t * A \"scroll\" option can be passed to search queries, creating persistent\n\t * paginated results.\n\t * This method can be used to manually get the next page of a search result,\n\t * instead of using KuzzleSearchResult.next()\n\t *\n\t * @param {string} scrollId\n\t * @param {object} [options]\n\t * @param {object} [filters]\n\t * @param {responseCallback} cb\n\t */\n\tKuzzleDataCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n\t  var\n\t    request = {body: {}},\n\t    self = this;\n\t\n\t  if (!scrollId) {\n\t    throw new Error('KuzzleDataCollection.scroll: scrollId required');\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = {};\n\t  }\n\t\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t\n\t  options.scrollId = scrollId;\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.scroll', cb);\n\t\n\t  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    if (result.result._scroll_id) {\n\t      options.scrollId = result.result._scroll_id;\n\t    }\n\t\n\t    cb(null, new KuzzleSearchResult(\n\t      self,\n\t      result.result.total,\n\t      documents,\n\t      result.result.aggregations ? result.result.aggregations : [],\n\t      {options: options, filters: filters}\n\t    ));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Subscribes to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @param {responseCallback} cb - called for each new notification\n\t * @returns {*} KuzzleSubscribeResult object\n\t */\n\tKuzzleDataCollection.prototype.subscribe = function (filters, options, cb) {\n\t  var\n\t    room,\n\t    subscribeResult;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.subscribe', cb);\n\t\n\t  subscribeResult = new KuzzleSubscribeResult();\n\t  room = new KuzzleRoom(this, options);\n\t\n\t  room.renew(filters, cb, subscribeResult.done.bind(subscribeResult));\n\t\n\t  return subscribeResult;\n\t};\n\t\n\t/**\n\t * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n\t * This method is a lot faster than removing all documents using a query.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.truncate = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Update parts of a document\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to update\n\t * @param {object} content - JSON object containing changes to perform on the document\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n\t * @return {object} this\n\t */\n\tKuzzleDataCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n\t  var\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    (new KuzzleDocument(self, res.result._id)).refresh(cb);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Instantiate a new KuzzleDocument object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - document id\n\t * @param {object} content - document content\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.documentFactory = function (id, content) {\n\t  return new KuzzleDocument(this, id, content);\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleRoom object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [options] - subscription configuration\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.roomFactory = function (options) {\n\t  return new KuzzleRoom(this, options);\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleDataMapping object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [mapping] - mapping to instantiate the KuzzleDataMapping object with\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.dataMappingFactory = function (mapping) {\n\t  return new KuzzleDataMapping(this, mapping);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDataCollection.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleDataCollection;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n\t *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n\t *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n\t *  the amount of data you stored in a collection and the complexity of your database.\n\t *\n\t *  The KuzzleDataMapping object allow to get the current mapping of a data collection and to modify it if needed.\n\t *\n\t * @param {object} kuzzleDataCollection - Instance of the inherited KuzzleDataCollection object\n\t * @param {object} [mapping] - mappings\n\t * @constructor\n\t */\n\tfunction KuzzleDataMapping(kuzzleDataCollection, mapping) {\n\t  Object.defineProperties(this, {\n\t    //read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    mapping: {\n\t      value: mapping || {},\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['set', 'setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Applies the new mapping to the data collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleDataMapping.prototype.apply = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n\t    if (err) {\n\t      return cb && cb(err);\n\t    }\n\t\n\t    self.refresh(options, cb);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with the mapping stored in Kuzzle\n\t *\n\t * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDataMapping.prototype.refresh = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    if (res.result[self.collection.index]) {\n\t      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n\t        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\t\n\t        // Mappings can be empty. The mapping property should never be \"undefined\"\n\t        if (self.mapping === undefined) {\n\t          self.mapping = {};\n\t        }\n\t      } else {\n\t        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n\t      }\n\t    } else {\n\t      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds or updates a field mapping.\n\t *\n\t * Changes made by this function wont be applied until you call the apply method\n\t *\n\t * @param {string} field - Name of the field from which the mapping is to be added or updated\n\t * @param {object} mapping - corresponding field mapping\n\t * @returns {KuzzleDataMapping}\n\t */\n\tKuzzleDataMapping.prototype.set = function (field, mapping) {\n\t  this.mapping[field] = mapping;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDataMapping.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleDataMapping;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle handles documents either as realtime messages or as stored documents.\n\t * KuzzleDocument is the object representation of one of these documents.\n\t *\n\t * Notes:\n\t *   - this constructor may be called either with a documentId, a content, neither or both.\n\t *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n\t *\n\t *\n\t * @param {object} kuzzleDataCollection - an instanciated KuzzleDataCollection object\n\t * @param {string} [documentId] - ID of an existing document\n\t * @param {object} [content] - Initializes this document with the provided content\n\t * @constructor\n\t */\n\tfunction KuzzleDocument(kuzzleDataCollection, documentId, content) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection.collection,\n\t      enumerable: true\n\t    },\n\t    dataCollection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    id: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    version: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  // handling provided arguments\n\t  if (!content && documentId && typeof documentId === 'object') {\n\t    content = documentId;\n\t    documentId = null;\n\t  }\n\t\n\t  if (content) {\n\t    if (content._version) {\n\t      this.version = content._version;\n\t      delete content._version;\n\t    }\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  if (documentId) {\n\t    Object.defineProperty(this, 'id', {\n\t      value: documentId,\n\t      enumerable: true\n\t    });\n\t  }\n\t\n\t  // promisifying\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'refresh', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this document\n\t */\n\tKuzzleDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data._version = this.version;\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Overrides the toString() method in order to return a serialized version of the document\n\t *\n\t * @return {string} serialized version of this object\n\t */\n\tKuzzleDocument.prototype.toString = function () {\n\t  return JSON.stringify(this.serialize());\n\t};\n\t\n\t/**\n\t * Deletes this document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.delete = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('KuzzleDocument.delete: cannot delete a document without a document ID');\n\t  }\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n\t    cb(err, err ? undefined : self.id);\n\t  });\n\t};\n\t\n\t/**\n\t * Replaces the current content with the last version of this document stored in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.refresh = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('KuzzleDocument.refresh: cannot retrieve a document if no ID has been provided');\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDocument.refresh', cb);\n\t\n\t  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n\t    var newDocument;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    newDocument = new KuzzleDocument(self.dataCollection, self.id, res.result._source);\n\t    newDocument.version = res.result._version;\n\t\n\t    cb(null, newDocument);\n\t  });\n\t};\n\t\n\t/**\n\t * Saves this document into Kuzzle.\n\t *\n\t * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n\t * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n\t    if (error) {\n\t      return cb && cb(error);\n\t    }\n\t\n\t    self.id = res.result._id;\n\t    self.version = res.result._version;\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Sends the content of this document as a realtime message.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.publish = function (options) {\n\t  var data = this.serialize();\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {object} data - New content\n\t * @param {boolean} replace - if true: replace this document content with the provided data\n\t */\n\tKuzzleDocument.prototype.setContent = function (data, replace) {\n\t  var self = this;\n\t\n\t  if (replace) {\n\t    this.content = data;\n\t  }\n\t  else {\n\t    Object.keys(data).forEach(function (key) {\n\t      self.content[key] = data[key];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Listens to events concerning this document. Has no effect if the document does not have an ID\n\t * (i.e. if the document has not yet been created as a persisted document).\n\t *\n\t * @param {object} [options] - subscription options\n\t * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n\t */\n\tKuzzleDocument.prototype.subscribe = function (options, cb) {\n\t  var filters;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDocument.subscribe', cb);\n\t\n\t  if (!this.id) {\n\t    throw new Error('KuzzleDocument.subscribe: cannot subscribe to a document if no ID has been provided');\n\t  }\n\t\n\t  filters = { ids: { values: [this.id] } };\n\t\n\t  return this.dataCollection.subscribe(filters, options, cb);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDocument.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t\n\tmodule.exports = KuzzleDocument;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t * Kuzzle's memory storage is a separate data store from the database layer.\n\t * It is internaly based on Redis. You can access most of Redis functions (all\n\t * lowercased), excepting:\n\t *   * all cluster based functions\n\t *   * all script based functions\n\t *   * all cursors functions\n\t *\n\t * For instance:\n\t *     kuzzle.memoryStorage\n\t *      .set('myKey', 'myValue')\n\t *      .get('myKey', function (err, response) {\n\t *        console.log(response.result);\n\t *\n\t *        // { _id: 'foo', body: { value: 'myValue' }}\n\t *      });\n\t *\n\t *\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @constructor\n\t */\n\tfunction KuzzleMemoryStorage(kuzzle) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  this.setHeaders = kuzzle.setHeaders.bind(this);\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * constructs the memoryStorage functions.\n\t */\n\t(function() {\n\t\n\t  var\n\t    keyVal = ['id', 'value'],\n\t    idOrKeys = ['id', 'keys'],\n\t    commands = {\n\t      append: keyVal,\n\t      bgrewriteaof: [],\n\t      bgsave: [],\n\t      bitcount: ['id', 'start', 'end'],\n\t      bitop: ['operation', 'destkey', idOrKeys],\n\t      bitpos: ['id', 'bit', { __opts__: ['start', 'end']}],\n\t      blpop: [idOrKeys, 'timeout'],\n\t      brpoplpush: ['source', 'destination'],\n\t      dbsize: [],\n\t      decrby: keyVal,\n\t      del: [idOrKeys],\n\t      discard: [],\n\t      exec: [],\n\t      exists: [idOrKeys],\n\t      expire: ['id', 'seconds'],\n\t      expireat: ['id', 'timestamp'],\n\t      flushdb: [],\n\t      // @todo: implement geolocation methods once available in Redis stable release\n\t      getbit: ['id', 'offset'],\n\t      getrange: ['id', 'start', 'end'],\n\t      hdel: ['id', ['field', 'fields']],\n\t      hexists: ['id', 'field'],\n\t      hincrby: ['id', 'field', 'value'],\n\t      hmset: ['id', 'values'],\n\t      hset: ['id', 'field', 'value'],\n\t      info: ['section'],\n\t      keys: [ 'pattern' ],\n\t      lastsave: [],\n\t      lindex: ['id', 'idx'],\n\t      linsert: ['id', 'position', 'pivot', 'value'],\n\t      lpush: ['id', ['value', 'values']],\n\t      lrange: ['id', 'start', 'stop'],\n\t      lrem: ['id', 'count', 'value'],\n\t      lset: ['id', 'idx', 'value'],\n\t      ltrim: ['id', 'start', 'stop'],\n\t      mset: ['values'],\n\t      multi: [],\n\t      object: ['subcommand', 'args'],\n\t      pexpire: ['id', 'milliseconds'],\n\t      pexpireat: ['id', 'timestamp'],\n\t      pfadd: ['id', ['element', 'elements']],\n\t      pfmerge: ['destkey', ['sourcekey', 'sourcekeys']],\n\t      ping: [],\n\t      psetex: ['id', 'milliseconds', 'value'],\n\t      publish: ['channel', 'message'],\n\t      randomkey: [],\n\t      rename: ['id', 'newkey'],\n\t      renamenx: ['id', 'newkey'],\n\t      restore: ['id', 'ttl', 'content'],\n\t      rpoplpush: ['source', 'destination'],\n\t      sadd: ['id', ['member', 'members']],\n\t      save: [],\n\t      set: ['id', 'value', {__opts__:['ex', 'px', 'nx', 'xx']}],\n\t      sdiffstore: ['destination', idOrKeys],\n\t      setbit: ['id', 'offset', 'value'],\n\t      setex: ['id', 'seconds', 'value'],\n\t      setrange: ['id', 'offset', 'value'],\n\t      sinterstore: ['destination', idOrKeys],\n\t      sismember: ['id', 'member'],\n\t      smove: ['id', 'destination', 'member'],\n\t      sort: ['id', {__opts__:['by', 'offset', 'count', 'get', 'direction', 'alpha', 'store']}],\n\t      spop: ['id', 'count'],\n\t      srem: ['id', ['member', 'members']],\n\t      sunionstore: ['destination', idOrKeys],\n\t      unwatch: [],\n\t      wait: ['numslaves', 'timeout'],\n\t      zadd: ['id', {__opts__: ['nx', 'xx', 'ch', 'incr', 'score', 'member', 'members']}],\n\t      zcount: ['id', 'min', 'max'],\n\t      zincrby: ['id', 'value', 'member'],\n\t      zinterstore: ['destination', idOrKeys, {__opts__: ['weight', 'weights', 'aggregate']}],\n\t      zlexcount: ['id', 'min', 'max'],\n\t      zrange: ['id', 'start', 'stop', {__opts__: ['withscores']}],\n\t      zrangebylex: ['id', 'min', 'max', {__opts__: ['offset', 'count']}],\n\t      zrangebyscore: ['id', 'min', 'max', {__opts__: ['withscores', 'offset', 'count']}],\n\t      zrem: ['id', 'member'],\n\t      zremrangebylex: ['id', 'min', 'max'],\n\t      zremrangebyscore: ['id', 'min', 'max'],\n\t      zrevrangebylex: ['id', 'max', 'min', {__opts__: ['offset', 'count']}],\n\t      zrevrangebyscore: ['id', 'max', 'min', {__opts__: ['withscores', 'offset', 'count']}],\n\t      zrevrank: ['id', 'member']\n\t    };\n\t\n\t  // unique argument key\n\t  commands.decr = commands.get = commands.dump = commands.hgetall = commands.hkeys = commands.hlen = commands.hstrlen = commands.hvals = commands.incr = commands.llen = commands.lpop = commands.persist = commands.pttl = commands.rpop = commands.scard = commands.smembers = commands.strlen = commands.ttl = commands.type = commands.zcard = ['id'];\n\t\n\t  // key value\n\t  commands.getset = commands.lpushx = keyVal;\n\t\n\t  // key key...\n\t  commands.del = commands.exists = commands.mget = commands.pfcount = commands.sdiff = commands.sinter = commands.sunion = commands.watch = [idOrKeys];\n\t\n\t  commands.incrby = commands.incrbyfloat = commands.decrby;\n\t  commands.brpop = commands.blpop;\n\t  commands.hget = commands.hexists;\n\t  commands.hmget = commands.hdel;\n\t  commands.hsetnx = commands.hset;\n\t  commands.msetnx = commands.mset;\n\t  commands.rpush = commands.lpush;\n\t  commands.hincrbyfloat = commands.hincrby;\n\t  commands.srandmember = commands.spop;\n\t  commands.zrevrange = commands.zrange;\n\t  commands.zscore = commands.zrevrank;\n\t\n\t  Object.keys(commands).forEach(function (command) {\n\t    KuzzleMemoryStorage.prototype[command] = function () {\n\t      var\n\t        args = Array.prototype.slice.call(arguments),\n\t        options = null,\n\t        cb,\n\t        query = {\n\t          controller: 'ms',\n\t          action: command\n\t        },\n\t        data = {};\n\t\n\t      if (typeof args[args.length - 1] === 'function') {\n\t        cb = args.pop();\n\t      }\n\t\n\t      if (args.length && typeof args[args.length - 1] === 'object' && Object.keys(args[args.length - 1]).length === 1 && args[args.length - 1].queuable !== undefined) {\n\t        options = args.pop();\n\t      }\n\t\n\t      commands[command].forEach(function (v, i) {\n\t        if (args[i] === undefined) {\n\t          return;\n\t        }\n\t\n\t        if (Array.isArray(v)) {\n\t          v = Array.isArray(args[i]) ? v[1] : v[0];\n\t        }\n\t\n\t        if (v === 'id') {\n\t          data._id = args[i];\n\t        }\n\t        else {\n\t          if (!data.body) {\n\t            data.body = {};\n\t          }\n\t\n\t          if (typeof v === 'object' && v.__opts__ !== undefined) {\n\t            v.__opts__.forEach(function (arg) {\n\t              if (args[i][arg] !== undefined) {\n\t                data.body[arg] = args[i][arg];\n\t              }\n\t            });\n\t          }\n\t          else {\n\t            data.body[v] = args[i];\n\t          }\n\t        }\n\t      });\n\t\n\t      this.kuzzle.query(query, data, options, cb);\n\t\n\t      return this;\n\t\n\t    };\n\t  });\n\t\n\t})();\n\t\n\tmodule.exports = KuzzleMemoryStorage;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuid = __webpack_require__(4);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n\t *\n\t * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n\t *\n\t * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n\t * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n\t * document change (because it is created, updated or deleted), then youll receive a notification about it.\n\t *\n\t * @param {object} kuzzleDataCollection - an instantiated and valid kuzzle object\n\t * @param {object} [options] - subscription optional configuration\n\t * @constructor\n\t */\n\tfunction KuzzleRoom(kuzzleDataCollection, options) {\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    callback: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    channel: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    id: {\n\t      value: uuid.v4()\n\t    },\n\t    lastRenewal: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    notifier: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    onDoneCB: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    queue: {\n\t      value: [],\n\t      writable: true\n\t    },\n\t    // Delay before allowing a subscription renewal\n\t    renewalDelay: {\n\t      value: 500\n\t    },\n\t    scope: {\n\t      value: options && options.scope ? options.scope : 'all'\n\t    },\n\t    state: {\n\t      value: options && options.state ? options.state : 'done'\n\t    },\n\t    subscribing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    users: {\n\t      value: options && options.users ? options.users : 'none'\n\t    },\n\t    // read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    filters: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    metadata: {\n\t      value: (options && options.metadata) ? options.metadata : {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    roomId: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    subscribeToSelf: {\n\t      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['count'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of other subscriptions on that room.\n\t *\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleRoom.prototype.count = function (cb) {\n\t  var data;\n\t\n\t  this.kuzzle.callbackRequired('KuzzleRoom.count', cb);\n\t\n\t  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\t\n\t  if (!isReady.call(this)) {\n\t    this.queue.push({action: 'count', args: [cb]});\n\t    return;\n\t  }\n\t\n\t  if (!this.roomId) {\n\t    throw new Error('KuzzleRoom.count: cannot count subscriptions on an inactive room');\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n\t    cb(err, res && res.result.count);\n\t  });\n\t};\n\t\n\t/**\n\t * Renew the subscription using new filters\n\t *\n\t * @param {object} [filters] - Filters in Kuzzle DSL format\n\t * @param {responseCallback} notificationCB - called for each new notification\n\t * @param {responseCallback} [cb] - handles the query response\n\t */\n\tKuzzleRoom.prototype.renew = function (filters, notificationCB, cb) {\n\t  var\n\t    now = Date.now(),\n\t    subscribeQuery = {\n\t      scope: this.scope,\n\t      state: this.state,\n\t      users: this.users\n\t    },\n\t    self = this;\n\t\n\t  if (typeof filters === 'function') {\n\t    cb = notificationCB;\n\t    notificationCB = filters;\n\t    filters = null;\n\t  }\n\t\n\t  if (!cb) {\n\t    cb = self.onDoneCB;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleRoom.renew', notificationCB);\n\t\n\t  /*\n\t    Skip subscription renewal if another one was performed a moment before\n\t   */\n\t  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n\t    return cb && cb(new Error('Subscription already renewed less than ' + self.renewalDelay + 'ms ago'));\n\t  }\n\t\n\t  if (filters) {\n\t    self.filters = filters;\n\t  }\n\t\n\t  /*\n\t   if not yet connected, register itself to the subscriptions list and wait for the\n\t   main Kuzzle object to renew once online\n\t    */\n\t  if (self.kuzzle.state !== 'connected') {\n\t    self.callback = notificationCB;\n\t    self.onDoneCB = cb;\n\t    self.kuzzle.subscriptions.pending[self.id] = self;\n\t    return;\n\t  }\n\t\n\t  if (self.subscribing) {\n\t    self.queue.push({action: 'renew', args: [filters, notificationCB, cb]});\n\t    return;\n\t  }\n\t\n\t  self.unsubscribe();\n\t  self.roomId = null;\n\t  self.subscribing = true;\n\t  self.callback = notificationCB;\n\t  self.onDoneCB = cb;\n\t  self.kuzzle.subscriptions.pending[self.id] = self;\n\t\n\t  subscribeQuery.body = self.filters;\n\t  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, this.headers);\n\t\n\t  self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'subscribe'), subscribeQuery, {metadata: self.metadata}, function (error, response) {\n\t    delete self.kuzzle.subscriptions.pending[self.id];\n\t    self.subscribing = false;\n\t\n\t    if (error) {\n\t      self.queue = [];\n\t      return cb && cb(new Error('Error during Kuzzle subscription: ' + error.message));\n\t    }\n\t\n\t    self.lastRenewal = now;\n\t    self.roomId = response.result.roomId;\n\t    self.channel = response.result.channel;\n\t\n\t    if (!self.kuzzle.subscriptions[self.roomId]) {\n\t      self.kuzzle.subscriptions[self.roomId] = {};\n\t    }\n\t\n\t    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\t\n\t    self.notifier = notificationCallback.bind(self);\n\t    self.kuzzle.network.on(self.channel, self.notifier);\n\t\n\t    dequeue.call(self);\n\t    cb && cb(null, self);\n\t  });\n\t};\n\t\n\t/**\n\t * Unsubscribes from Kuzzle.\n\t *\n\t * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n\t * pending subscriptions reaches 0, and only if there is still no listener on that room.\n\t * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n\t *\n\t * @return {*} this\n\t */\n\tKuzzleRoom.prototype.unsubscribe = function () {\n\t  var\n\t    self = this,\n\t    room = self.roomId,\n\t    interval;\n\t\n\t  if (!isReady.call(this)) {\n\t    self.queue.push({action: 'unsubscribe', args: []});\n\t    return self;\n\t  }\n\t\n\t  if (room) {\n\t    self.kuzzle.network.off(self.channel, this.notifier);\n\t\n\t    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n\t      delete self.kuzzle.subscriptions[room];\n\t\n\t      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t        self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n\t      } else {\n\t        interval = setInterval(function () {\n\t          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t            if (!self.kuzzle.subscriptions[room]) {\n\t              self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n\t            }\n\t            clearInterval(interval);\n\t          }\n\t        }, 100);\n\t      }\n\t    } else {\n\t      delete self.kuzzle.subscriptions[room][self.id];\n\t    }\n\t\n\t    self.roomId = null;\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleRoom.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Callback called by the network handler when a message is sent to the subscribed room ID\n\t * Calls the registered callback if the notification passes the subscription filters\n\t *\n\t * @param {object} data - data\n\t * @returns {*}\n\t */\n\tfunction notificationCallback (data) {\n\t  if (data.error) {\n\t    return this.callback(data.error);\n\t  }\n\t\n\t  if (data.action === 'jwtTokenExpired') {\n\t    this.kuzzle.jwtToken = undefined;\n\t    return this.kuzzle.emitEvent('jwtTokenExpired');\n\t  }\n\t\n\t  if (this.kuzzle.requestHistory[data.requestId]) {\n\t    if (this.subscribeToSelf) {\n\t      this.callback(null, data);\n\t    }\n\t    delete this.kuzzle.requestHistory[data.requestId];\n\t  } else {\n\t    this.callback(null, data);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Dequeue actions performed while subscription was being renewed\n\t */\n\tfunction dequeue () {\n\t  var element;\n\t\n\t  while (this.queue.length > 0) {\n\t    element = this.queue.shift();\n\t\n\t    this[element.action].apply(this, element.args);\n\t  }\n\t}\n\t\n\tfunction isReady() {\n\t  return this.kuzzle.state === 'connected' && !this.subscribing;\n\t}\n\t\n\tmodule.exports = KuzzleRoom;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t *\n\t * @param {KuzzleDataCollection} dataCollection\n\t * @param {int} total\n\t * @param {KuzzleDocument[]} documents\n\t * @param {object} [aggregations]\n\t * @param {object} [searchArgs]\n\t * @param {KuzzleSearchResult} [previous]\n\t * @constructor\n\t */\n\tfunction KuzzleSearchResult (dataCollection, total, documents, aggregations, searchArgs, previous) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    dataCollection: {\n\t      value: dataCollection,\n\t    },\n\t    total: {\n\t      value: total,\n\t      enumerable: true\n\t    },\n\t    documents: {\n\t      value: documents,\n\t      enumerable: true\n\t    },\n\t    aggregations: {\n\t      value: aggregations || {},\n\t      enumerable: true\n\t    },\n\t    searchArgs: {\n\t      value: searchArgs || {},\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    fetchedDocument: {\n\t      value: documents.length,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    _previous: {\n\t      value: previous || null,\n\t      writable: true\n\t    },\n\t    _next: {\n\t      value: null,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this._previous instanceof KuzzleSearchResult) {\n\t    this._previous._next = this;\n\t    this.fetchedDocument += this._previous.fetchedDocument;\n\t  }\n\t\n\t  // promisifying\n\t  if (this.dataCollection.kuzzle.bluebird) {\n\t    return this.dataCollection.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['previous', 'next'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * @param cb\n\t * @returns {*}\n\t */\n\tKuzzleSearchResult.prototype.previous = function (cb) {\n\t  cb(null, this._previous);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @param {function} cb\n\t */\n\tKuzzleSearchResult.prototype.next = function (cb) {\n\t  var\n\t    filters,\n\t    options = Object.assign({}, this.searchArgs.options),\n\t    self = this;\n\t\n\t  if (!this._next) {\n\t    // retrieve next results with scroll if original search use it\n\t    if (options.scrollId) {\n\t      if (this.fetchedDocument >= this.total) {\n\t        cb(null, null);\n\t        return;\n\t      }\n\t\n\t      this.dataCollection.scroll(\n\t        options.scrollId,\n\t        options,\n\t        this.searchArgs.filters || {},\n\t        function(error, newSearchResults) {\n\t          handleNextSearchResults(error, self, newSearchResults, cb);\n\t        }\n\t      );\n\t\n\t      return;\n\t    }\n\t    // retrieve next results with from/size if original search use it\n\t    else if (options.from !== undefined && options.size !== undefined) {\n\t      filters = Object.assign({}, this.searchArgs.filters);\n\t\n\t      // check if we need to do next request to fetch all matching documents\n\t      options.from += options.size;\n\t\n\t      if (options.from >= this.total) {\n\t        cb(null, null);\n\t\n\t        return;\n\t      }\n\t\n\t      this.dataCollection.search(\n\t        filters,\n\t        options,\n\t        function(error, newSearchResults) {\n\t          handleNextSearchResults(error, self, newSearchResults, cb);\n\t        }\n\t      );\n\t\n\t      return;\n\t    }\n\t  }\n\t\n\t  if (this._next instanceof KuzzleSearchResult) {\n\t    cb(null, this._next);\n\t\n\t    return;\n\t  }\n\t\n\t  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n\t};\n\t\n\t/**\n\t * @param {Error} error\n\t * @param {KuzzleSearchResult} currentSearchResults\n\t * @param {KuzzleSearchResult} newSearchResults\n\t * @param {Function} cb\n\t */\n\tfunction handleNextSearchResults (error, currentSearchResults, newSearchResults, cb) {\n\t  if (error) {\n\t    cb(error);\n\t    return;\n\t  }\n\t\n\t  newSearchResults.fetchedDocument += currentSearchResults.fetchedDocument;\n\t\n\t  newSearchResults._previous = currentSearchResults;\n\t  currentSearchResults._next = newSearchResults;\n\t\n\t\n\t  cb(null, newSearchResults);\n\t}\n\t\n\tmodule.exports = KuzzleSearchResult;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Sugar-code handling the result of a KuzzleRoom.renew call\n\t * @constructor\n\t */\n\tfunction KuzzleSubscribeResult() {\n\t  this.cbs = [];\n\t  this.error = null;\n\t  this.room = null;\n\t}\n\t\n\t/**\n\t * Registers a callback to be called with a subscription result\n\t * @param {Function} cb\n\t */\n\tKuzzleSubscribeResult.prototype.onDone = function (cb) {\n\t  if (this.error || this.room) {\n\t    cb(this.error, this.room);\n\t  }\n\t  else {\n\t    this.cbs.push(cb);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Calls all registered callbacks\n\t *\n\t * @param {Object} error object\n\t * @param {KuzzleRoom} room\n\t */\n\tKuzzleSubscribeResult.prototype.done = function (error, room) {\n\t  this.error = error;\n\t  this.room = room;\n\t\n\t  this.cbs.forEach(function (cb) {\n\t    cb(error, room);\n\t  });\n\t};\n\t\n\tmodule.exports = KuzzleSubscribeResult;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *\n\t * @param host\n\t * @param wsPort\n\t * @param ioPort\n\t * @param sslConnection\n\t * @returns {Object} tnstantiated WebSocket/Socket.IO object\n\t */\n\t\n\tfunction network(host, wsPort, ioPort, sslConnection) {\n\t  // Web browser / NodeJS websocket handling\n\t  if (typeof window !== 'undefined') {\n\t    // use native websockets if the browser supports it\n\t    if (typeof WebSocket !== 'undefined') {\n\t      return new (__webpack_require__(2))(host, wsPort, sslConnection);\n\t    }\n\t    // otherwise fallback to socket.io, if available\n\t    else if (window.io) {\n\t      return new (__webpack_require__(13))(host, ioPort, sslConnection);\n\t    }\n\t\n\t    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n\t  }\n\t\n\t  return new (__webpack_require__(2))(host, wsPort, sslConnection);\n\t}\n\t\n\tmodule.exports = network;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tfunction SocketIO(host, port, ssl) {\n\t  this.host = host;\n\t  this.port = port;\n\t  this.ssl = ssl;\n\t  this.socket = null;\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n\t      reconnection: autoReconnect,\n\t      reconnectionDelay: reconnectionDelay,\n\t      forceNew: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    this.socket.on('connect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    this.socket.on('connect_error', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    this.socket.on('disconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    this.socket.on('reconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room. Once 1 message is received, fires the\n\t   * callback and unregister it afterward.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.once = function (roomId, callback) {\n\t    this.socket.once(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.on = function (roomId, callback) {\n\t    this.socket.on(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Unregisters a callback from a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.off = function (roomId, callback) {\n\t    this.socket.off(roomId, callback);\n\t  };\n\t\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    this.socket.emit('kuzzle', payload);\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.socket.close();\n\t    this.socket = null;\n\t  };\n\t}\n\t\n\tmodule.exports = SocketIO;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\tfunction KuzzleProfile(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteProfile'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateProfile'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['hydrate', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tKuzzleProfile.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleProfile\n\t  }\n\t});\n\t\n\t/**\n\t * Persist to the persistent layer the current profile\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.save = function (options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!this.content.policies) {\n\t    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.serialize();\n\t\n\t  self.kuzzle.query(self.kuzzleSecurity.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Add a policy in the policies list\n\t * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n\t *\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.addPolicy = function (policy) {\n\t\n\t  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n\t  }\n\t\n\t  if (!this.content.policies) {\n\t    this.content.policies = [];\n\t  }\n\t\n\t  this.content.policies.push(policy);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set policies list\n\t * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.setPolicies = function (policies) {\n\t\n\t  if (!Array.isArray(policies)) {\n\t    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t  }\n\t\n\t  policies.map(function (policy) {\n\t    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t    }\n\t  });\n\t\n\t  this.content.policies = policies;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this securityDocument\n\t */\n\tKuzzleProfile.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Returns the list of policies associated to this profile.\n\t * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @return {object} an array of policies\n\t */\n\tKuzzleProfile.prototype.getPolicies = function () {\n\t  return this.content.policies;\n\t};\n\t\n\tmodule.exports = KuzzleProfile;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\tfunction KuzzleRole(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteRole'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateRole'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tKuzzleRole.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleRole\n\t  }\n\t});\n\t\n\t/**\n\t * Saves this role into Kuzzle.\n\t *\n\t * If this is a new role, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleRole} this object\n\t */\n\tKuzzleRole.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n\t    cb(error, error ? undefined : self);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleRole;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleRole = __webpack_require__(15),\n\t  KuzzleProfile = __webpack_require__(14),\n\t  KuzzleUser = __webpack_require__(3);\n\t\n\t/**\n\t * Kuzzle security constructor\n\t *\n\t * @param kuzzle\n\t * @returns {KuzzleSecurity}\n\t * @constructor\n\t */\n\tfunction KuzzleSecurity(kuzzle) {\n\t\n\t  Object.defineProperty(this, 'kuzzle', {\n\t    value: kuzzle\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (action) {\n\t      return {\n\t        controller: 'security',\n\t        action: action\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['roleFactory', 'profileFactory', 'userFactory', 'isActionAllowed'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Retrieve a single Role using its unique role ID.\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getRole = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id) {\n\t    throw new Error('Id parameter is mandatory for getRole function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getRole', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new KuzzleRole(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on roles according to a filter\n\t *\n\t * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t *\n\t */\n\tKuzzleSecurity.prototype.searchRoles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchRoles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = result.result.hits.map(function (doc) {\n\t      return new KuzzleRole(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, roles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new role in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same role already exists: throw an error if sets to false.\n\t *        Replace the existing role otherwise\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createRole: cannot create a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleRole(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a role in Kuzzle.\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.updateRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'updateRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateRole: cannot update a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err) {\n\t    cb(err, err ? undefined : new KuzzleRole(self, id, content));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete role.\n\t *\n\t * There is a small delay between role deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Role id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.deleteRole = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleRole object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - role id\n\t * @param {object} content - role content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.roleFactory = function(id, content) {\n\t  return new KuzzleRole(this, id, content);\n\t};\n\t\n\t\n\t/**\n\t * Get a specific profile from kuzzle\n\t *\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getProfile = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for getProfile function');\n\t  }\n\t\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getProfile', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n\t    cb(error, error ? undefined : new KuzzleProfile(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on profiles according to a filter\n\t *\n\t *\n\t * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.searchProfiles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchProfiles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new KuzzleProfile(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: response.result.total, profiles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new profile in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same profile already exists: throw an error if sets to false.\n\t *        Replace the existing profile otherwise\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {object} content - attribute `roles` in `content` must only contains an array of role id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createProfile = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createProfile: cannot create a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleProfile(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update a profile in Kuzzle.\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {object} content - a plain javascript object representing the profile's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.updateProfile = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateProfile: cannot update a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    var updatedContent = {};\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    Object.keys(res.result._source).forEach(function (property) {\n\t      updatedContent[property] = res.result._source[property];\n\t    });\n\t\n\t    cb(null, new KuzzleProfile(self, res.result._id, updatedContent));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete profile.\n\t *\n\t * There is a small delay between profile deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.deleteProfile = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleProfile object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - profile id\n\t * @param {object} content - profile content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.profileFactory = function(id, content) {\n\t  return new KuzzleProfile(this, id, content);\n\t};\n\t\n\t/**\n\t * Get a specific user from kuzzle using its unique ID\n\t *\n\t * @param {string} id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getUser = function (id, options, cb) {\n\t  var\n\t    data = {_id: id},\n\t    self = this;\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for getUser function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getUser', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on user according to a filter\n\t *\n\t * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - same filters as documents filters\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.searchUsers = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchUsers', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new KuzzleUser(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: response.result.total, users: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new user in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same user already exists: throw an error if sets to false.\n\t *        Replace the existing user otherwise\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content},\n\t    action = 'createUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createUser: cannot create a user without a user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceUser' : 'createUser';\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new restricted user in Kuzzle.\n\t *\n\t * This function will create a new user. It is not usable to update an existing user.\n\t * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profile` in `content` must only contains the profile id\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {_id: id, body: content};\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createRestrictedUser: cannot create a user without a user ID');\n\t  }\n\t\n\t  if (content.profileIds) {\n\t    throw new Error('KuzzleSecurity.createRestrictedUser: cannot provide profileIds');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n\t  });\n\t};\n\t\n\t\n\t/**\n\t * Update an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.updateUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateUser: cannot update an user without an user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete user.\n\t *\n\t * There is a small delay between user deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {KuzzleSecurity} this object\n\t */\n\tKuzzleSecurity.prototype.deleteUser = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result._id);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleUser object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - user id\n\t * @param {object} content - user content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.userFactory = function(id, content) {\n\t  return new KuzzleUser(this, id, content);\n\t};\n\t\n\t/**\n\t * Tells whether an action is allowed, denied or conditional based on the rights\n\t * rights provided as the first argument. An action is defined as a couple of\n\t * action and controller (mandatory), plus an index and a collection(optional).\n\t *\n\t * @param {object} rights - The rights rights associated to a user\n\t *                            (see getMyrights and getUserrights).\n\t * @param {string} controller - The controller to check the action onto.\n\t * @param {string} action - The action to perform.\n\t * @param {string} index - (optional) The name of index to perform the action onto.\n\t * @param {string} collection - (optional) The name of the collection to perform the action onto.\n\t *\n\t * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n\t *                   correspond to rights containing closures.\n\t *                   See also http://kuzzle.io/guide/#roles-definition\n\t */\n\tKuzzleSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n\t  var filteredRights;\n\t\n\t  if (!rights || typeof rights !== 'object') {\n\t    throw new Error('rights parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!controller || typeof controller !== 'string') {\n\t    throw new Error('controller parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!action || typeof action !== 'string') {\n\t    throw new Error('action parameter is mandatory for isActionAllowed function');\n\t  }\n\t\n\t  // We filter in all the rights that match the request (including wildcards).\n\t  filteredRights = rights\n\t    .filter(function (right) {\n\t      return right.controller === controller || right.controller === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.action === action || right.action === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.index === index || right.index === '*';\n\t    })\n\t    .filter(function (right) {\n\t      return right.collection === collection || right.collection === '*';\n\t    });\n\t\n\t  // Then, if at least one right allows the action, we return 'allowed'\n\t  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n\t    return 'allowed';\n\t  }\n\t  // If no right allows the action, we check for conditionals.\n\t  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n\t    return 'conditional';\n\t  }\n\t  // Otherwise we return 'denied'.\n\t  return 'denied';\n\t};\n\t\n\t\n\t/**\n\t * Gets the rights array of a given user.\n\t *\n\t * @param {string} userId The id of the user.\n\t * @param {object|responseCallback} [options] - (optional) arguments\n\t * @param {function} cb The callback containing the normalized array of rights.\n\t */\n\tKuzzleSecurity.prototype.getUserRights = function (userId, options, cb) {\n\t  var\n\t    data = {_id: userId},\n\t    self = this;\n\t\n\t  if (!userId || typeof userId !== 'string') {\n\t    throw new Error('userId parameter is mandatory for getUserRights function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n\t    cb(err, err ? undefined : res.result.hits);\n\t  });\n\t};\n\t\n\tmodule.exports = KuzzleSecurity;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar rng;\n\t\n\tvar crypto = (window).crypto || (window).msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  // Moderately fast, high quality\n\t  var _rnds8 = new Uint8Array(16);\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(_rnds8);\n\t    return _rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var  _rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return _rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\t\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// kuzzle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e8d22660bfe8c421070c","var\n  uuid = require('uuid'),\n  KuzzleDataCollection = require('./kuzzleDataCollection'),\n  KuzzleSecurity = require('./security/kuzzleSecurity'),\n  KuzzleMemoryStorage = require('./kuzzleMemoryStorage'),\n  KuzzleUser = require('./security/kuzzleUser'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n * @constructor\n */\nfunction Kuzzle (host, options, cb) {\n  var self = this;\n\n  if (!(this instanceof Kuzzle)) {\n    return new Kuzzle(host, options, cb);\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!host || host === '') {\n    throw new Error('host argument missing');\n  }\n\n  Object.defineProperties(this, {\n    // 'private' properties\n    collections: {\n      value: {},\n      writable: true\n    },\n    connectCB: {\n      value: cb\n    },\n    eventListeners: {\n      value: {\n        connected: {lastEmitted: null, listeners: []},\n        error: {lastEmitted: null, listeners: []},\n        disconnected: {lastEmitted: null, listeners: []},\n        reconnected: {lastEmitted: null, listeners: []},\n        jwtTokenExpired: {lastEmitted: null, listeners: []},\n        loginAttempt: {lastEmitted: null, listeners: []},\n        offlineQueuePush: {listeners: []},\n        offlineQueuePop: {listeners: []},\n        queryError: {listeners: []}\n      }\n    },\n    eventTimeout: {\n      value: 200\n    },\n    queuing: {\n      value: false,\n      writable: true\n    },\n    requestHistory: {\n      value: {},\n      writable: true\n    },\n    state: {\n      value: 'initializing',\n      writable: true\n    },\n    subscriptions: {\n      /*\n       Contains the centralized subscription list in the following format:\n          pending: <number of pending subscriptions>\n          'roomId': {\n            kuzzleRoomID_1: kuzzleRoomInstance_1,\n            kuzzleRoomID_2: kuzzleRoomInstance_2,\n            kuzzleRoomID_...: kuzzleRoomInstance_...\n          }\n\n       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n       This structure also allows renewing subscriptions after a connection loss\n       */\n      value: {\n        pending: {}\n      },\n      writable: true\n    },\n    // read-only properties\n    autoReconnect: {\n      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n      enumerable: true\n    },\n    defaultIndex: {\n      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n      writable: true,\n      enumerable: true\n    },\n    reconnectionDelay: {\n      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n      enumerable: true\n    },\n    host: {\n      value: host,\n      writable: true,\n      enumerable: true\n    },\n    wsPort: {\n      value: (options && typeof options.wsPort === 'number') ? options.wsPort : 7513,\n      enumerable: true,\n      writable: true\n    },\n    ioPort: {\n      value: (options && typeof options.ioPort === 'number') ? options.ioPort : 7512,\n      enumerable: true,\n      writable: true\n    },\n    sslConnection: {\n      value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n      enumerable: true\n    },\n    autoQueue: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoReplay: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoResubscribe: {\n      value: true,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    metadata: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    /*\n      Offline queue use the following format:\n            [\n              {\n                ts: <query timestamp>,\n                query: 'query',\n                cb: callbackFunction\n              }\n            ]\n     */\n    offlineQueue: {\n      value: [],\n      enumerable: true,\n      writable: true\n    },\n    queueFilter: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    queueMaxSize: {\n      value: 500,\n      enumerable: true,\n      writable: true\n    },\n    queueTTL: {\n      value: 120000,\n      enumerable: true,\n      writable: true\n    },\n    replayInterval: {\n      value: 10,\n      enumerable: true,\n      writable: true\n    },\n    jwtToken: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    offlineQueueLoader: {\n      value: null,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (options) {\n    Object.keys(options).forEach(function (opt) {\n      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n        self[opt] = options[opt];\n      }\n    });\n\n    if (options.offlineMode === 'auto' && this.autoReconnect) {\n      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n    }\n  }\n\n  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n  Object.defineProperty(this, 'isValid', {\n    value: function () {\n      if (self.state === 'disconnected') {\n        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n      }\n    }\n  });\n\n  // Helper function copying headers to the query data\n  Object.defineProperty(this, 'addHeaders', {\n    value: function (query, headers) {\n      Object.keys(headers).forEach(function (header) {\n        if (!query[header]) {\n          query[header] = headers[header];\n        }\n      });\n\n      return query;\n    }\n  });\n\n  /**\n   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n   * and is called by these methods\n   */\n  Object.defineProperty(this, 'callbackRequired', {\n    value: function (errorMessagePrefix, callback) {\n      if (!callback || typeof callback !== 'function') {\n        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n      }\n    }\n  });\n\n  /**\n   * Create an attribute security that embed all methods to manage Role, Profile and User\n   */\n  Object.defineProperty(this, 'security', {\n    value: new KuzzleSecurity(this),\n    enumerable: true\n  });\n\n  /**\n   * Emit an event to all registered listeners\n   * An event cannot be emitted multiple times before a timeout has been reached.\n   */\n  Object.defineProperty(this, 'emitEvent', {\n    value: function emitEvent(event) {\n      var\n        now = Date.now(),\n        args = Array.prototype.slice.call(arguments, 1),\n        eventProperties = this.eventListeners[event];\n\n      if (eventProperties.lastEmitted && eventProperties.lastEmitted >= now - this.eventTimeout) {\n        return false;\n      }\n\n      eventProperties.listeners.forEach(function (listener) {\n        process.nextTick(function () {\n          listener.fn.apply(undefined, args);\n        });\n      });\n\n      // Events without the 'lastEmitted' property can be emitted without minimum time between emissions\n      if (eventProperties.lastEmitted !== undefined) {\n        eventProperties.lastEmitted = now;\n      }\n    }\n  });\n\n  Object.defineProperty(this, 'memoryStorage', {\n    value: new KuzzleMemoryStorage(this),\n    enumerable: true\n  });\n\n\n  if (!options || !options.connect || options.connect === 'auto') {\n    this.connect();\n  } else {\n    this.state = 'ready';\n  }\n\n  cleanHistory(this.requestHistory);\n\n  if (this.bluebird) {\n    return this.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n          'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n          'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n        ];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Connects to a Kuzzle instance using the provided host name.\n * @returns {Object} this\n */\nKuzzle.prototype.connect = function () {\n  var self = this;\n\n  if (self.network) {\n    self.disconnect();\n  }\n\n  self.network = networkWrapper(self.host, self.wsPort, self.ioPort, self.sslConnection);\n\n  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n    return self;\n  }\n\n  self.state = 'connecting';\n  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\n  self.network.onConnect(function () {\n    self.state = 'connected';\n    renewAllSubscriptions.call(self);\n    dequeue.call(self);\n    self.emitEvent('connected');\n\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n  });\n\n  self.network.onConnectError(function (error) {\n    var connectionError = new Error('Unable to connect to kuzzle proxy server at \"' + self.host + '\"');\n\n    connectionError.internal = error;\n    self.state = 'error';\n    self.emitEvent('error', connectionError);\n\n    if (self.connectCB) {\n      self.connectCB(connectionError);\n    }\n  });\n\n  self.network.onDisconnect(function () {\n    self.state = 'offline';\n\n    if (!self.autoReconnect) {\n      self.disconnect();\n    }\n\n    if (self.autoQueue) {\n      self.queuing = true;\n    }\n\n    self.emitEvent('disconnected');\n  });\n\n  self.network.onReconnect(function () {\n    var reconnect = function () {\n      // renew subscriptions\n      if (self.autoResubscribe) {\n        renewAllSubscriptions.call(self);\n      }\n\n      // replay queued requests\n      if (self.autoReplay) {\n        cleanQueue.call(self);\n        dequeue.call(self);\n      }\n\n      // alert listeners\n      self.emitEvent('reconnected');\n    };\n\n    self.state = 'connected';\n\n    if (self.jwtToken) {\n      self.checkToken(self.jwtToken, function (err, res) {\n        // shouldn't obtain an error but let's invalidate the token anyway\n        if (err || !res.valid) {\n          self.jwtToken = undefined;\n          self.emitEvent('jwtTokenExpired');\n        }\n\n        reconnect();\n      });\n    } else {\n      reconnect();\n    }\n  });\n\n  return this;\n};\n\n/**\n * Set the jwtToken used to query kuzzle\n * @param token\n * @returns {Kuzzle}\n */\nKuzzle.prototype.setJwtToken = function(token) {\n  if (typeof token === 'string') {\n    this.jwtToken = token;\n  } else if (typeof token === 'object') {\n    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n      this.jwtToken = token.result.jwt;\n    } else {\n      this.emitEvent('loginAttempt', {\n        success: false,\n        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n      });\n\n      return this;\n    }\n  } else {\n    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n    return this;\n  }\n\n  renewAllSubscriptions.call(this);\n  this.emitEvent('loginAttempt', {success: true});\n  return this;\n};\n\n/**\n * Unset the jwtToken used to query kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.unsetJwtToken = function() {\n  this.jwtToken = undefined;\n\n  removeAllSubscriptions.call(this);\n\n  return this;\n};\n\n/**\n * Get the jwtToken used by kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.getJwtToken = function() {\n  return this.jwtToken;\n};\n\n/**\n * Send login request to kuzzle with credentials\n * If login success, store the jwtToken into kuzzle object\n *\n * @param strategy\n * @param credentials\n * @param expiresIn\n * @param cb\n */\nKuzzle.prototype.login = function (strategy) {\n  var\n    self = this,\n    request = {\n      strategy: strategy\n    },\n    credentials,\n    cb = null;\n\n  // Handle arguments (credentials, expiresIn, cb)\n  if (arguments[1]) {\n    if (typeof arguments[1] === 'object') {\n      credentials = arguments[1];\n    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n      request.expiresIn = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n    }\n  }\n  if (arguments[2]) {\n    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n      request.expiresIn = arguments[2];\n    } else if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n    }\n  }\n  if (arguments[3] && typeof arguments[3] === 'function') {\n    cb = arguments[3];\n  }\n\n  if (typeof credentials === 'object') {\n    Object.keys(credentials).forEach(function (key) {\n      request[key] = credentials[key];\n    });\n  }\n\n  this.query({controller: 'auth', action: 'login'}, {body: request}, {queuable: false}, function(error, response) {\n    if (!error) {\n      if (response.result.jwt) {\n        self.setJwtToken(response.result.jwt);\n      }\n\n      cb && cb(null, response.result);\n    }\n    else {\n      cb && cb(error);\n      self.emitEvent('loginAttempt', {success: false, error: error.message});\n    }\n  });\n};\n\n/**\n * Create a kuzzle index\n *\n * @param {string} index\n * @param {object} [options]\n * @param {responseCallback} cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.createIndex = function (index, options, cb) {\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.createIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.query({controller: 'admin', action: 'createIndex'}, {index: index}, options, typeof cb !== 'function' ? null : cb);\n\n  return this;\n};\n\n/**\n * Send logout request to kuzzle with jwtToken.\n *\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.logout = function (cb) {\n  var\n    self = this,\n    request = {\n      action: 'logout',\n      controller: 'auth',\n      requestId: uuid.v4(),\n      body: {}\n    };\n\n  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, typeof cb !== 'function' ? null : function(error) {\n    cb(error, self);\n  });\n\n  self.unsetJwtToken();\n\n  return self;\n};\n\n/**\n * Checks whether a given jwt token still represents a valid session in Kuzzle.\n *\n * @param  {string}   token     The jwt token to check\n * @param  {function} callback  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.checkToken = function (token, callback) {\n  var\n    request = {\n      body: {\n        token: token\n      }\n    };\n\n  this.callbackRequired('Kuzzle.checkToken', callback);\n\n  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, response) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, response.result);\n  });\n};\n\n/**\n * Fetches the current user.\n *\n * @param  {function} callback  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n */\nKuzzle.prototype.whoAmI = function (callback) {\n  var self = this;\n\n  self.callbackRequired('Kuzzle.whoAmI', callback);\n\n  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, response) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new KuzzleUser(self.security, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Gets the rights array of the currently logged user.\n *\n * @param {object} [options] - Optional parameters\n * @param  {function} cb The callback containing the normalized array of rights.\n */\nKuzzle.prototype.getMyRights = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.callbackRequired('Kuzzle.getMyRights', cb);\n\n  self.query({controller: 'auth', action:'getMyRights'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.hits);\n  });\n};\n\n/**\n * Update current user in Kuzzle.\n *\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.updateSelf = function (content, options, cb) {\n  var\n    self = this,\n    data = {},\n    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data.body = content;\n\n  self.query(queryArgs, data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result);\n  });\n\n  return this;\n};\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n */\nfunction cleanQueue () {\n  var\n    self = this,\n    now = Date.now(),\n    lastDocumentIndex = -1;\n\n  if (self.queueTTL > 0) {\n    self.offlineQueue.forEach(function (query, index) {\n      if (query.ts < now - self.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      self.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(function (droppedRequest) {\n          self.emitEvent('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n    self.offlineQueue\n      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n      .forEach(function (droppedRequest) {\n        self.emitEvent('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n\n/**\n * Clean history from requests made more than 10s ago\n */\nfunction cleanHistory (requestHistory) {\n  var\n    now = Date.now();\n\n  Object.keys(requestHistory).forEach(function (key) {\n    if (requestHistory[key] < now - 10000) {\n      delete requestHistory[key];\n    }\n  });\n\n  setTimeout(function () {\n    cleanHistory(requestHistory);\n  }, 1000);\n}\n\n/**\n * Emit a request to Kuzzle\n *\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (request, cb) {\n  var\n    self = this;\n\n  if (self.jwtToken !== undefined || cb) {\n    self.network.once(request.requestId, function (response) {\n      var error = null;\n\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        self.jwtToken = undefined;\n        self.emitEvent('jwtTokenExpired', request, cb);\n      }\n\n      if (response.error) {\n        error = new Error(response.error.message);\n        Object.assign(error, response.error);\n        error.status = response.status;\n        self.emitEvent('queryError', error, request, cb);\n      }\n\n      if (cb) {\n        cb(error, response);\n      }\n    });\n  }\n\n  this.network.send(request);\n\n  // Track requests made to allow KuzzleRoom.subscribeToSelf to work\n  self.requestHistory[request.requestId] = Date.now();\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue () {\n  var\n    self = this,\n    additionalQueue,\n    uniqueQueue = {},\n    dequeuingProcess = function () {\n      if (self.offlineQueue.length > 0) {\n        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\n        setTimeout(function () {\n          dequeuingProcess();\n        }, Math.max(0, self.replayInterval));\n      } else {\n        self.queuing = false;\n      }\n    };\n\n  if (self.offlineQueueLoader) {\n    if (typeof self.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n    }\n\n    additionalQueue = self.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      self.offlineQueue = additionalQueue\n        .concat(self.offlineQueue)\n        .filter(function (request) {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\n/**\n * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n * successful login attempt\n */\nfunction renewAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.renew(subscription.callback);\n    });\n  });\n}\n\n/**\n * Remove all registered subscriptions. Triggered either by a logout query or by un-setting the token\n */\nfunction removeAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.unsubscribe();\n    });\n  });\n}\n\n/**\n * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n * insertion.\n *\n * The ID returned by this function is required to remove this listener at a later time.\n *\n * @param {string} event - name of the global event to subscribe to (see the 'eventListeners' object property)\n * @param {function} listener - callback to invoke each time an event is fired\n * @returns {string} Unique listener ID\n */\nKuzzle.prototype.addListener = function(event, listener) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    listenerType = typeof listener,\n    listenerId;\n\n  this.isValid();\n\n  if (knownEvents.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n  }\n\n  if (listenerType !== 'function') {\n    throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n  }\n\n  listenerId = uuid.v4();\n  this.eventListeners[event].listeners.push({id: listenerId, fn: listener});\n  return listenerId;\n};\n\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method returns all available statistics from Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAllStatistics = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n  this.query({controller:'server', action: 'getAllStats'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.hits);\n  });\n};\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n *\n * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n  var\n    queryCB,\n    body;\n\n  if (!cb) {\n    if (arguments.length === 1) {\n      cb = arguments[0];\n      options = null;\n      timestamp = null;\n    } else {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'object') {\n        options = arguments[0];\n        timestamp = null;\n      } else {\n        timestamp = arguments[0];\n        options = null;\n      }\n    }\n  }\n\n  queryCB = function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, timestamp ? res.result.hits : [res.result]);\n  };\n\n  this.callbackRequired('Kuzzle.getStatistics', cb);\n\n  body = timestamp ? {body: {startTime: timestamp}} : {};\n  this.query({controller: 'server', action: timestamp ? 'getStats' : 'getLastStats'}, body, options, queryCB);\n};\n\n/**\n * Create a new instance of a KuzzleDataCollection object.\n * If no index is specified, takes the default index.\n *\n * @param {string} collection - The name of the data collection you want to manipulate\n * @param {string} [index] - The name of the data index containing the data collection\n * @returns {KuzzleDataCollection} A KuzzleDataCollection instance\n */\nKuzzle.prototype.dataCollectionFactory = function(collection, index) {\n  this.isValid();\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Unable to create a new data collection object: no index specified');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  if (typeof index !== 'string' || typeof collection !== 'string') {\n    throw new Error('Invalid index or collection argument: string expected');\n  }\n\n  if (!this.collections[index]) {\n    this.collections[index] = {};\n  }\n\n  if (!this.collections[index][collection]) {\n    this.collections[index][collection] = new KuzzleDataCollection(this, collection, index);\n  }\n\n  return this.collections[index][collection];\n};\n\n/**\n * Empties the offline queue without replaying it.\n *\n * @returns {Kuzzle}\n */\nKuzzle.prototype.flushQueue = function () {\n  this.offlineQueue = [];\n  return this;\n};\n\n/**\n * Returns the list of known persisted data collections.\n *\n * @param {string} [index] - Index containing collections to be listed\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listCollections = function () {\n  var\n    collectionType = 'all',\n    index,\n    options,\n    cb,\n    args = Array.prototype.slice.call(arguments),\n    query;\n\n  args.forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.listCollections: index required');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.listCollections', cb);\n\n  if (options && options.type) {\n    collectionType = options.type;\n  }\n\n  query = {body: {type: collectionType}};\n\n  if (options && options.from) {\n    query.body.from = options.from;\n  }\n\n  if (options && options.size) {\n    query.body.size = options.size;\n  }\n\n  this.query({index: index, controller: 'collection', action: 'list'}, query, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.collections);\n  });\n};\n\n/**\n * Returns the list of existing indexes in Kuzzle\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.listIndexes = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.listIndexes', cb);\n\n  this.query({controller: 'index', action: 'list'}, {}, options, function (err, res) {\n    cb(err, err ? undefined : res.result.indexes);\n  });\n};\n\n/**\n * Disconnects from Kuzzle and invalidate this instance.\n */\nKuzzle.prototype.disconnect = function () {\n  var collection;\n\n  this.state = 'disconnected';\n  this.network.close();\n  this.network = null;\n\n  for (collection in this.collections) {\n    if (this.collections.hasOwnProperty(collection)) {\n      delete this.collections[collection];\n    }\n  }\n};\n\n/**\n * Returns the server informations\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getServerInfo = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n  this.query({controller: 'server', action: 'info'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.serverInfo);\n  });\n};\n\n/**\n * Forces an index refresh\n *\n * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {Kuzzle}\n */\nKuzzle.prototype.refreshIndex = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.refreshIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.query({ index: index, controller: 'index', action: 'refresh'}, {}, options, cb);\n\n  return this;\n};\n\n/**\n * Returns de current autoRefresh status for the given index\n *\n * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optinal arguments\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.getAutoRefresh = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.getAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n  this.query({ index: index, controller: 'index', action: 'getAutoRefresh'}, {}, options, cb);\n};\n\n/**\n * (Un)Sets the autoRefresh flag on the given index\n *\n * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n * @param {boolean} autoRefresh - The autoRefresh value to set\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query result\n * @returns {object} this\n */\nKuzzle.prototype.setAutoRefresh = function () {\n  var\n    index,\n    autoRefresh,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'boolean':\n        autoRefresh = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.setAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (autoRefresh === undefined) {\n    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n  }\n\n  this.query({ index: index, controller: 'index', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\n  return this;\n};\n\n/**\n * Return the current Kuzzle's UTC Epoch time, in milliseconds\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzle.prototype.now = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.now', cb);\n\n  this.query({controller: 'server', action: 'now'}, {}, options, function (err, res) {\n    cb(err, res && res.result.now);\n  });\n};\n\n/**\n * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n * Base method used to send read queries to Kuzzle\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} queryArgs - Query configuration\n * @param {object} query - The query data\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n  var\n    attr,\n    object = {\n      action: queryArgs.action,\n      controller: queryArgs.controller,\n      metadata: this.metadata\n    },\n    self = this;\n\n  this.isValid();\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options) {\n    if (options.queuable === false && self.state === 'offline') {\n      return self;\n    }\n\n    if (options.refresh) {\n      object.refresh = options.refresh;\n    }\n\n    if (options.from) {\n      object.from = options.from;\n    }\n\n    if (options.size) {\n      object.size = options.size;\n    }\n\n    if (options.metadata) {\n      Object.keys(options.metadata).forEach(function (meta) {\n        object.metadata[meta] = options.metadata[meta];\n      });\n    }\n  }\n\n  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n    throw new Error('Invalid query parameter: ' + query);\n  }\n\n  if (query.metadata) {\n    Object.keys(query.metadata).forEach(function (meta) {\n      object.metadata[meta] = query.metadata[meta];\n    });\n  }\n\n  for (attr in query) {\n    if (attr !== 'metadata' && query.hasOwnProperty(attr)) {\n      object[attr] = query[attr];\n    }\n  }\n\n  object = self.addHeaders(object, this.headers);\n\n  /*\n   * Do not add the token for the checkToken route, to avoid getting a token error when\n   * a developer simply wish to verify his token\n   */\n  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n    object.jwt = self.jwtToken;\n  }\n\n  if (queryArgs.collection) {\n    object.collection = queryArgs.collection;\n  }\n\n  if (queryArgs.index) {\n    object.index = queryArgs.index;\n  }\n\n  if (!object.requestId) {\n    object.requestId = uuid.v4();\n  }\n\n  if (self.state === 'connected' || (options && options.queuable === false)) {\n    if (self.state === 'connected') {\n      emitRequest.call(this, object, cb);\n    } else if (cb) {\n      cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n    }\n  } else if (self.queuing || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n    cleanQueue.call(this, object, cb);\n\n    if (!self.queueFilter || self.queueFilter(object)) {\n      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n    }\n  }\n\n  return self;\n};\n\n/**\n * Removes all listeners, either from a specific event or from all events\n *\n * @param {string} event - One of the event described in the Event Handling section of this documentation\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.removeAllListeners = function (event) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    self = this;\n\n  if (event) {\n    if (knownEvents.indexOf(event) === -1) {\n      throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n    }\n\n    this.eventListeners[event].listeners = [];\n  } else {\n    knownEvents.forEach(function (eventName) {\n      self.eventListeners[eventName].listeners = [];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Removes a listener from an event.\n *\n * @param {string} event - One of the event described in the Event Handling section of this documentation\n * @param {string} listenerId - The ID returned by addListener\n * @returns {Kuzzle} this object\n */\nKuzzle.prototype.removeListener = function (event, listenerId) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    self = this;\n\n  if (knownEvents.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n  }\n\n  this.eventListeners[event].listeners.forEach(function (listener, index) {\n    if (listener.id === listenerId) {\n      self.eventListeners[event].listeners.splice(index, 1);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Replays the requests queued during offline mode.\n * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n */\nKuzzle.prototype.replayQueue = function () {\n  if (this.state !== 'offline' && !this.autoReplay) {\n    cleanQueue.call(this);\n    dequeue.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Sets the default Kuzzle index\n *\n * @param index\n * @returns this\n */\nKuzzle.prototype.setDefaultIndex = function (index) {\n  if (typeof index !== 'string') {\n    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n  }\n\n  if (index.length === 0) {\n    throw new Error('Cannot set an empty index as the default index');\n  }\n\n  this.defaultIndex = index;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzle.prototype.setHeaders = function (content, replace) {\n  var self = this;\n\n  if (typeof content !== 'object' || Array.isArray(content)) {\n    throw new Error('Expected a content object, received a ' + typeof content);\n  }\n\n  if (replace) {\n    self.headers = content;\n  } else {\n    Object.keys(content).forEach(function (key) {\n      self.headers[key] = content[key];\n    });\n  }\n\n  return self;\n};\n\n/**\n * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.startQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = true;\n  }\n  return this;\n};\n\n/**\n * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.stopQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = false;\n  }\n\n  return this;\n};\n\nmodule.exports = Kuzzle;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzle.js\n// module id = 0\n// module chunks = 0","function KuzzleSecurityDocument(kuzzleSecurity, id, content) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: kuzzleSecurity.kuzzle\n    },\n    kuzzleSecurity: {\n      value: kuzzleSecurity\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {KuzzleSecurityDocument} this\n */\nKuzzleSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nKuzzleSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurityDocument} this\n */\nKuzzleSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = KuzzleSecurityDocument;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleSecurityDocument.js\n// module id = 1\n// module chunks = 0","function WSNode(host, port, ssl) {\n  var self = this;\n  this.WebSocket = typeof WebSocket !== 'undefined' ? WebSocket : require('ws');\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.client = null;\n  this.wasConnected = false;\n  this.retrying = false;\n  this.lasturl = null;\n\n  /*\n   Listeners are stored using the following format:\n   roomId: {\n   fn: callback_function,\n   once: boolean\n   }\n   */\n  this.listeners = {\n    error: [],\n    connect: [],\n    disconnect: [],\n    reconnect: []\n  };\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   * @returns {Object} Socket\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    var\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      options = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    if (url !== this.lasturl) {\n      self.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new this.WebSocket(url, options);\n\n    this.client.onopen = function () {\n      if (self.wasConnected) {\n        poke(self.listeners, 'reconnect');\n      }\n      else {\n        poke(self.listeners, 'connect');\n      }\n      self.wasConnected = true;\n    };\n\n    this.client.onclose = function (code, message) {\n      if (code === 1000) {\n        poke(self.listeners, 'disconnect');\n      }\n      else {\n        onClientError.call(self, autoReconnect, reconnectionDelay, message);\n      }\n    };\n\n    this.client.onerror = function (error) {\n      onClientError.call(self, autoReconnect, reconnectionDelay, error);\n    };\n\n    this.client.onmessage = function (payload) {\n      var data = JSON.parse(payload.data || payload);\n\n      if (data.room && self.listeners[data.room]) {\n        poke(self.listeners, data.room, data);\n      }\n    };\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.listeners.connect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.listeners.error.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.listeners.disconnect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.listeners.reconnect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    if (!this.listeners[roomId]) {\n      this.listeners[roomId] = [];\n    }\n\n    this.listeners[roomId].push({\n      fn: callback,\n      keep: false\n    });\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    if (!this.listeners[roomId]) {\n      this.listeners[roomId] = [];\n    }\n\n    this.listeners[roomId].push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    var index = -1;\n\n    if (this.listeners[roomId]) {\n      // Array.findIndex is not supported by internet explorer\n      this.listeners[roomId].some(function (listener, i) {\n        if (listener.fn === callback) {\n          index = i;\n          return true;\n        }\n\n        return false;\n      });\n\n      if (index !== -1) {\n        if (this.listeners[roomId].length === 1 && ['error', 'connect', 'disconnect', 'reconnect'].indexOf(roomId) === -1) {\n          delete this.listeners[roomId];\n        }\n        else {\n          this.listeners[roomId].splice(index, 1);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.listeners = {\n      error: [],\n      connect: [],\n      disconnect: [],\n      reconnect: []\n    };\n\n    this.wasConnected = false;\n    this.client.close();\n    this.client = null;\n  };\n}\n\n/**\n * Executes all registered listeners in the provided\n * \"listeners\" structure.\n *\n * Listeners are of the following format:\n * [\n *    { fn: callback, once: boolean },\n *    ...\n * ]\n *\n * @private\n * @param {Object} listeners\n * @param {string} roomId\n * @param {Object} [payload]\n */\nfunction poke (listeners, roomId, payload) {\n  var\n    i,\n    length = listeners[roomId].length;\n\n  for (i = 0; i < length; ++i) {\n    listeners[roomId][i].fn(payload);\n\n    if (!listeners[roomId][i].keep) {\n      if (listeners[roomId].length > 1) {\n        listeners[roomId].splice(i, 1);\n        --i;\n        --length;\n      }\n      else {\n        delete listeners[roomId];\n      }\n    }\n  }\n}\n\n/**\n * Called when the connection closes with an error state\n *\n * @param {boolean} autoReconnect\n * @param {number} reconnectionDelay\n * @param {string|Object} message\n */\nfunction onClientError(autoReconnect, reconnectionDelay, message) {\n  var self = this;\n\n  if (autoReconnect && !self.retrying) {\n    self.retrying = true;\n    setTimeout(function () {\n      self.retrying = false;\n      self.connect(autoReconnect, reconnectionDelay);\n    }, reconnectionDelay);\n  }\n\n  poke(self.listeners, 'error', message);\n}\n\nmodule.exports = WSNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/wrappers/websocket.js\n// module id = 2\n// module chunks = 0","var\n  KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\n/**\n * @param {KuzzleSecurity} kuzzleSecurity\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction KuzzleUser(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save', 'saveRestricted'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nKuzzleUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleUser\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Saves this user into Kuzzle.\n *\n * If this is a new user, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this user in Kuzzle by the current content\n * of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nKuzzleUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array} the associated profiles IDs\n */\nKuzzleUser.prototype.getProfiles = function () {\n  return this.content.profileIds;\n};\n\nmodule.exports = KuzzleUser;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleUser.js\n// module id = 3\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./lib/rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; ++i) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\nfunction buff_to_string(buf, offset) {\n  var i = offset || 0;\n  var bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : buff_to_string(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || buff_to_string(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/uuid/uuid.js\n// module id = 4\n// module chunks = 0","var\n  KuzzleSearchResult = require('./kuzzleSearchResult'),\n  KuzzleDocument = require('./kuzzleDocument'),\n  KuzzleDataMapping = require('./kuzzleDataMapping'),\n  KuzzleRoom = require('./kuzzleRoom'),\n  KuzzleSubscribeResult = require('./kuzzleSubscribeResult');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n *\n * @property {string} collection\n * @property {string} index\n * @property {Kuzzle} kuzzle\n * @property {Array.<string>} collection\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} collection - name of the data collection to handle\n * @param {string} index - Index containing the data collection\n * @constructor\n */\nfunction KuzzleDataCollection(kuzzle, collection, index) {\n  if (!index || !collection) {\n    throw new Error('The KuzzleDataCollection object constructor needs an index and a collection arguments');\n  }\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleDataCollection.prototype.count = function (filters, options, cb) {\n  var\n    query;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.count', cb);\n\n  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', 'count'), query, options, function (error, result) {\n    cb(error, result && result.result.count);\n  });\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.create = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('collection', 'create'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *    - updateIfExist (boolean, default: false):\n *        If the same document already exists: throw an error if sets to false.\n *        Update the existing document otherwise\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a KuzzleDocument object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof KuzzleDocument) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options) {\n    action = options.updateIfExist ? 'createOrReplace' : 'create';\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  data = self.kuzzle.addHeaders(data, self.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    var doc;\n\n    if (err) {\n      return cb(err);\n    }\n\n    doc = new KuzzleDocument(self, res.result._id, res.result._source);\n    doc.version = res.result._version;\n    cb(null, doc);\n  });\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleDataCollection} this\n */\nKuzzleDataCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = arg;\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('document', action), data, options, cb && function (err, res) {\n    if (err) {\n      cb(err);\n    }\n    else {\n      cb(null, (action === 'delete' ? [res.result._id] : res.result.ids));\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleDataCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleDataCollection.fetch', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new KuzzleDocument(self, res.result._id, res.result._source);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n};\n\n/**\n * Retrieves all documents stored in this data collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleDataCollection.prototype.fetchAllDocuments = function (options, cb) {\n  var\n    warnEmitted = false,\n    documents = [],\n    filters = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  // copying pagination options to the search filter\n  if (!options) {\n    options = {};\n  }\n\n  if (!options.from) {\n    options.from = 0;\n  }\n\n  if (!options.size) {\n    options.size = 1000;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.fetchAllDocuments', cb);\n\n  this.search(filters, options, function getNextDocuments (error, searchResult) {\n    if (error) {\n      return cb(error);\n    }\n\n    if (searchResult instanceof KuzzleSearchResult) {\n      if (searchResult.total > 10000 && !warnEmitted) {\n        warnEmitted = true;\n        console.warn('KuzzleDataCollection.fetchAllDocuments may return extremely large amounts of documents, which may cause performance issues. Unless you know what you are doing, consider using KuzzleDataCollection.search or KuzzleDataCollection.scroll instead'); // eslint-disable-line no-console\n      }\n\n      searchResult.documents.forEach(function(document) {\n        documents.push(document);\n      });\n      searchResult.next(getNextDocuments);\n    }\n    else {\n      cb(null, documents);\n    }\n  });\n};\n\n\n/**\n * Instantiates a KuzzleDataMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated KuzzleDataMapping object\n */\nKuzzleDataCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.getMapping', cb);\n\n  kuzzleMapping = new KuzzleDataMapping(this);\n  kuzzleMapping.refresh(options, cb);\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a KuzzleDocument instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof KuzzleDocument) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('realtime', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n * @return {object} this\n */\nKuzzleDataCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'createOrReplace'), data, options, cb && function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new KuzzleDocument(self, res.result._id, res.result._source);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\n\nKuzzleDataCollection.prototype.search = function (filters, options, cb) {\n  var\n    query,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  self.kuzzle.callbackRequired('KuzzleDataCollection.search', cb);\n\n  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'search'), query, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      result.result.aggregations ? result.result.aggregations : [],\n      {options: options, filters: filters}\n    ));\n  });\n};\n\n/**\n * A \"scroll\" option can be passed to search queries, creating persistent\n * paginated results.\n * This method can be used to manually get the next page of a search result,\n * instead of using KuzzleSearchResult.next()\n *\n * @param {string} scrollId\n * @param {object} [options]\n * @param {object} [filters]\n * @param {responseCallback} cb\n */\nKuzzleDataCollection.prototype.scroll = function (scrollId, options, filters, cb) {\n  var\n    request = {body: {}},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('KuzzleDataCollection.scroll: scrollId required');\n  }\n\n  if (!cb) {\n    cb = filters;\n    filters = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  options.scrollId = scrollId;\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.scroll', cb);\n\n  this.kuzzle.query({controller: 'document', action: 'scroll'}, request, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    if (result.result._scroll_id) {\n      options.scrollId = result.result._scroll_id;\n    }\n\n    cb(null, new KuzzleSearchResult(\n      self,\n      result.result.total,\n      documents,\n      result.result.aggregations ? result.result.aggregations : [],\n      {options: options, filters: filters}\n    ));\n  });\n\n  return this;\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} cb - called for each new notification\n * @returns {*} KuzzleSubscribeResult object\n */\nKuzzleDataCollection.prototype.subscribe = function (filters, options, cb) {\n  var\n    room,\n    subscribeResult;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.subscribe', cb);\n\n  subscribeResult = new KuzzleSubscribeResult();\n  room = new KuzzleRoom(this, options);\n\n  room.renew(filters, cb, subscribeResult.done.bind(subscribeResult));\n\n  return subscribeResult;\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('collection', 'truncate'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n * @return {object} this\n */\nKuzzleDataCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var\n    data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('document', 'update'), data, options, cb && function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    (new KuzzleDocument(self, res.result._id)).refresh(cb);\n  });\n\n  return self;\n};\n\n\n/**\n * Instantiate a new KuzzleDocument object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nKuzzleDataCollection.prototype.documentFactory = function (id, content) {\n  return new KuzzleDocument(this, id, content);\n};\n\n/**\n * Instantiate a new KuzzleRoom object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [options] - subscription configuration\n * @constructor\n */\nKuzzleDataCollection.prototype.roomFactory = function (options) {\n  return new KuzzleRoom(this, options);\n};\n\n/**\n * Instantiate a new KuzzleDataMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the KuzzleDataMapping object with\n * @constructor\n */\nKuzzleDataCollection.prototype.dataMappingFactory = function (mapping) {\n  return new KuzzleDataMapping(this, mapping);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDataCollection.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = KuzzleDataCollection;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleDataCollection.js\n// module id = 5\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The KuzzleDataMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} kuzzleDataCollection - Instance of the inherited KuzzleDataCollection object\n * @param {object} [mapping] - mappings\n * @constructor\n */\nfunction KuzzleDataMapping(kuzzleDataCollection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set', 'setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleDataMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('collection', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDataMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('collection', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb && cb(new Error('No mapping found for collection ' + self.collection.collection));\n      }\n    } else {\n      return cb && cb(new Error('No mapping found for index ' + self.collection.index));\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function wont be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {KuzzleDataMapping}\n */\nKuzzleDataMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDataMapping.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = KuzzleDataMapping;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleDataMapping.js\n// module id = 6\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * KuzzleDocument is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {object} kuzzleDataCollection - an instanciated KuzzleDataCollection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @constructor\n */\nfunction KuzzleDocument(kuzzleDataCollection, documentId, content) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: kuzzleDataCollection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nKuzzleDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data._version = this.version;\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nKuzzleDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('KuzzleDocument.delete: cannot delete a document without a document ID');\n  }\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'delete'), this.serialize(), options, cb && function (err) {\n    cb(err, err ? undefined : self.id);\n  });\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('KuzzleDocument.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDocument.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('document', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new KuzzleDocument(self.dataCollection, self.id, res.result._source);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('document', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb && cb(error);\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nKuzzleDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('realtime', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nKuzzleDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nKuzzleDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDocument.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('KuzzleDocument.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDocument.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n\nmodule.exports = KuzzleDocument;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleDocument.js\n// module id = 7\n// module chunks = 0","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), excepting:\n *   * all cluster based functions\n *   * all script based functions\n *   * all cursors functions\n *\n * For instance:\n *     kuzzle.memoryStorage\n *      .set('myKey', 'myValue')\n *      .get('myKey', function (err, response) {\n *        console.log(response.result);\n *\n *        // { _id: 'foo', body: { value: 'myValue' }}\n *      });\n *\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction KuzzleMemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  this.setHeaders = kuzzle.setHeaders.bind(this);\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * constructs the memoryStorage functions.\n */\n(function() {\n\n  var\n    keyVal = ['id', 'value'],\n    idOrKeys = ['id', 'keys'],\n    commands = {\n      append: keyVal,\n      bgrewriteaof: [],\n      bgsave: [],\n      bitcount: ['id', 'start', 'end'],\n      bitop: ['operation', 'destkey', idOrKeys],\n      bitpos: ['id', 'bit', { __opts__: ['start', 'end']}],\n      blpop: [idOrKeys, 'timeout'],\n      brpoplpush: ['source', 'destination'],\n      dbsize: [],\n      decrby: keyVal,\n      del: [idOrKeys],\n      discard: [],\n      exec: [],\n      exists: [idOrKeys],\n      expire: ['id', 'seconds'],\n      expireat: ['id', 'timestamp'],\n      flushdb: [],\n      // @todo: implement geolocation methods once available in Redis stable release\n      getbit: ['id', 'offset'],\n      getrange: ['id', 'start', 'end'],\n      hdel: ['id', ['field', 'fields']],\n      hexists: ['id', 'field'],\n      hincrby: ['id', 'field', 'value'],\n      hmset: ['id', 'values'],\n      hset: ['id', 'field', 'value'],\n      info: ['section'],\n      keys: [ 'pattern' ],\n      lastsave: [],\n      lindex: ['id', 'idx'],\n      linsert: ['id', 'position', 'pivot', 'value'],\n      lpush: ['id', ['value', 'values']],\n      lrange: ['id', 'start', 'stop'],\n      lrem: ['id', 'count', 'value'],\n      lset: ['id', 'idx', 'value'],\n      ltrim: ['id', 'start', 'stop'],\n      mset: ['values'],\n      multi: [],\n      object: ['subcommand', 'args'],\n      pexpire: ['id', 'milliseconds'],\n      pexpireat: ['id', 'timestamp'],\n      pfadd: ['id', ['element', 'elements']],\n      pfmerge: ['destkey', ['sourcekey', 'sourcekeys']],\n      ping: [],\n      psetex: ['id', 'milliseconds', 'value'],\n      publish: ['channel', 'message'],\n      randomkey: [],\n      rename: ['id', 'newkey'],\n      renamenx: ['id', 'newkey'],\n      restore: ['id', 'ttl', 'content'],\n      rpoplpush: ['source', 'destination'],\n      sadd: ['id', ['member', 'members']],\n      save: [],\n      set: ['id', 'value', {__opts__:['ex', 'px', 'nx', 'xx']}],\n      sdiffstore: ['destination', idOrKeys],\n      setbit: ['id', 'offset', 'value'],\n      setex: ['id', 'seconds', 'value'],\n      setrange: ['id', 'offset', 'value'],\n      sinterstore: ['destination', idOrKeys],\n      sismember: ['id', 'member'],\n      smove: ['id', 'destination', 'member'],\n      sort: ['id', {__opts__:['by', 'offset', 'count', 'get', 'direction', 'alpha', 'store']}],\n      spop: ['id', 'count'],\n      srem: ['id', ['member', 'members']],\n      sunionstore: ['destination', idOrKeys],\n      unwatch: [],\n      wait: ['numslaves', 'timeout'],\n      zadd: ['id', {__opts__: ['nx', 'xx', 'ch', 'incr', 'score', 'member', 'members']}],\n      zcount: ['id', 'min', 'max'],\n      zincrby: ['id', 'value', 'member'],\n      zinterstore: ['destination', idOrKeys, {__opts__: ['weight', 'weights', 'aggregate']}],\n      zlexcount: ['id', 'min', 'max'],\n      zrange: ['id', 'start', 'stop', {__opts__: ['withscores']}],\n      zrangebylex: ['id', 'min', 'max', {__opts__: ['offset', 'count']}],\n      zrangebyscore: ['id', 'min', 'max', {__opts__: ['withscores', 'offset', 'count']}],\n      zrem: ['id', 'member'],\n      zremrangebylex: ['id', 'min', 'max'],\n      zremrangebyscore: ['id', 'min', 'max'],\n      zrevrangebylex: ['id', 'max', 'min', {__opts__: ['offset', 'count']}],\n      zrevrangebyscore: ['id', 'max', 'min', {__opts__: ['withscores', 'offset', 'count']}],\n      zrevrank: ['id', 'member']\n    };\n\n  // unique argument key\n  commands.decr = commands.get = commands.dump = commands.hgetall = commands.hkeys = commands.hlen = commands.hstrlen = commands.hvals = commands.incr = commands.llen = commands.lpop = commands.persist = commands.pttl = commands.rpop = commands.scard = commands.smembers = commands.strlen = commands.ttl = commands.type = commands.zcard = ['id'];\n\n  // key value\n  commands.getset = commands.lpushx = keyVal;\n\n  // key key...\n  commands.del = commands.exists = commands.mget = commands.pfcount = commands.sdiff = commands.sinter = commands.sunion = commands.watch = [idOrKeys];\n\n  commands.incrby = commands.incrbyfloat = commands.decrby;\n  commands.brpop = commands.blpop;\n  commands.hget = commands.hexists;\n  commands.hmget = commands.hdel;\n  commands.hsetnx = commands.hset;\n  commands.msetnx = commands.mset;\n  commands.rpush = commands.lpush;\n  commands.hincrbyfloat = commands.hincrby;\n  commands.srandmember = commands.spop;\n  commands.zrevrange = commands.zrange;\n  commands.zscore = commands.zrevrank;\n\n  Object.keys(commands).forEach(function (command) {\n    KuzzleMemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      if (args.length && typeof args[args.length - 1] === 'object' && Object.keys(args[args.length - 1]).length === 1 && args[args.length - 1].queuable !== undefined) {\n        options = args.pop();\n      }\n\n      commands[command].forEach(function (v, i) {\n        if (args[i] === undefined) {\n          return;\n        }\n\n        if (Array.isArray(v)) {\n          v = Array.isArray(args[i]) ? v[1] : v[0];\n        }\n\n        if (v === 'id') {\n          data._id = args[i];\n        }\n        else {\n          if (!data.body) {\n            data.body = {};\n          }\n\n          if (typeof v === 'object' && v.__opts__ !== undefined) {\n            v.__opts__.forEach(function (arg) {\n              if (args[i][arg] !== undefined) {\n                data.body[arg] = args[i][arg];\n              }\n            });\n          }\n          else {\n            data.body[v] = args[i];\n          }\n        }\n      });\n\n      this.kuzzle.query(query, data, options, cb);\n\n      return this;\n\n    };\n  });\n\n})();\n\nmodule.exports = KuzzleMemoryStorage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleMemoryStorage.js\n// module id = 8\n// module chunks = 0","var\n  uuid = require('uuid');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then youll receive a notification about it.\n *\n * @param {object} kuzzleDataCollection - an instantiated and valid kuzzle object\n * @param {object} [options] - subscription optional configuration\n * @constructor\n */\nfunction KuzzleRoom(kuzzleDataCollection, options) {\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    callback: {\n      value: null,\n      writable: true\n    },\n    channel: {\n      value: null,\n      writable: true\n    },\n    id: {\n      value: uuid.v4()\n    },\n    lastRenewal: {\n      value: null,\n      writable: true\n    },\n    notifier: {\n      value: null,\n      writable: true\n    },\n    onDoneCB: {\n      value: null,\n      writable: true\n    },\n    queue: {\n      value: [],\n      writable: true\n    },\n    // Delay before allowing a subscription renewal\n    renewalDelay: {\n      value: 500\n    },\n    scope: {\n      value: options && options.scope ? options.scope : 'all'\n    },\n    state: {\n      value: options && options.state ? options.state : 'done'\n    },\n    subscribing: {\n      value: false,\n      writable: true\n    },\n    users: {\n      value: options && options.users ? options.users : 'none'\n    },\n    // read-only properties\n    collection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    filters: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    metadata: {\n      value: (options && options.metadata) ? options.metadata : {},\n      enumerable: true,\n      writable: true\n    },\n    roomId: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    subscribeToSelf: {\n      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['count'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of other subscriptions on that room.\n *\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleRoom.prototype.count = function (cb) {\n  var data;\n\n  this.kuzzle.callbackRequired('KuzzleRoom.count', cb);\n\n  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\n  if (!isReady.call(this)) {\n    this.queue.push({action: 'count', args: [cb]});\n    return;\n  }\n\n  if (!this.roomId) {\n    throw new Error('KuzzleRoom.count: cannot count subscriptions on an inactive room');\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('realtime', 'count'), data, function (err, res) {\n    cb(err, res && res.result.count);\n  });\n};\n\n/**\n * Renew the subscription using new filters\n *\n * @param {object} [filters] - Filters in Kuzzle DSL format\n * @param {responseCallback} notificationCB - called for each new notification\n * @param {responseCallback} [cb] - handles the query response\n */\nKuzzleRoom.prototype.renew = function (filters, notificationCB, cb) {\n  var\n    now = Date.now(),\n    subscribeQuery = {\n      scope: this.scope,\n      state: this.state,\n      users: this.users\n    },\n    self = this;\n\n  if (typeof filters === 'function') {\n    cb = notificationCB;\n    notificationCB = filters;\n    filters = null;\n  }\n\n  if (!cb) {\n    cb = self.onDoneCB;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleRoom.renew', notificationCB);\n\n  /*\n    Skip subscription renewal if another one was performed a moment before\n   */\n  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n    return cb && cb(new Error('Subscription already renewed less than ' + self.renewalDelay + 'ms ago'));\n  }\n\n  if (filters) {\n    self.filters = filters;\n  }\n\n  /*\n   if not yet connected, register itself to the subscriptions list and wait for the\n   main Kuzzle object to renew once online\n    */\n  if (self.kuzzle.state !== 'connected') {\n    self.callback = notificationCB;\n    self.onDoneCB = cb;\n    self.kuzzle.subscriptions.pending[self.id] = self;\n    return;\n  }\n\n  if (self.subscribing) {\n    self.queue.push({action: 'renew', args: [filters, notificationCB, cb]});\n    return;\n  }\n\n  self.unsubscribe();\n  self.roomId = null;\n  self.subscribing = true;\n  self.callback = notificationCB;\n  self.onDoneCB = cb;\n  self.kuzzle.subscriptions.pending[self.id] = self;\n\n  subscribeQuery.body = self.filters;\n  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, this.headers);\n\n  self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'subscribe'), subscribeQuery, {metadata: self.metadata}, function (error, response) {\n    delete self.kuzzle.subscriptions.pending[self.id];\n    self.subscribing = false;\n\n    if (error) {\n      self.queue = [];\n      return cb && cb(new Error('Error during Kuzzle subscription: ' + error.message));\n    }\n\n    self.lastRenewal = now;\n    self.roomId = response.result.roomId;\n    self.channel = response.result.channel;\n\n    if (!self.kuzzle.subscriptions[self.roomId]) {\n      self.kuzzle.subscriptions[self.roomId] = {};\n    }\n\n    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\n    self.notifier = notificationCallback.bind(self);\n    self.kuzzle.network.on(self.channel, self.notifier);\n\n    dequeue.call(self);\n    cb && cb(null, self);\n  });\n};\n\n/**\n * Unsubscribes from Kuzzle.\n *\n * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n * pending subscriptions reaches 0, and only if there is still no listener on that room.\n * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n *\n * @return {*} this\n */\nKuzzleRoom.prototype.unsubscribe = function () {\n  var\n    self = this,\n    room = self.roomId,\n    interval;\n\n  if (!isReady.call(this)) {\n    self.queue.push({action: 'unsubscribe', args: []});\n    return self;\n  }\n\n  if (room) {\n    self.kuzzle.network.off(self.channel, this.notifier);\n\n    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n      delete self.kuzzle.subscriptions[room];\n\n      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n        self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n      } else {\n        interval = setInterval(function () {\n          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n            if (!self.kuzzle.subscriptions[room]) {\n              self.kuzzle.query(self.collection.buildQueryArgs('realtime', 'unsubscribe'), {body: {roomId: room}});\n            }\n            clearInterval(interval);\n          }\n        }, 100);\n      }\n    } else {\n      delete self.kuzzle.subscriptions[room][self.id];\n    }\n\n    self.roomId = null;\n  }\n\n  return self;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleRoom.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n/**\n * Callback called by the network handler when a message is sent to the subscribed room ID\n * Calls the registered callback if the notification passes the subscription filters\n *\n * @param {object} data - data\n * @returns {*}\n */\nfunction notificationCallback (data) {\n  if (data.error) {\n    return this.callback(data.error);\n  }\n\n  if (data.action === 'jwtTokenExpired') {\n    this.kuzzle.jwtToken = undefined;\n    return this.kuzzle.emitEvent('jwtTokenExpired');\n  }\n\n  if (this.kuzzle.requestHistory[data.requestId]) {\n    if (this.subscribeToSelf) {\n      this.callback(null, data);\n    }\n    delete this.kuzzle.requestHistory[data.requestId];\n  } else {\n    this.callback(null, data);\n  }\n}\n\n\n/**\n * Dequeue actions performed while subscription was being renewed\n */\nfunction dequeue () {\n  var element;\n\n  while (this.queue.length > 0) {\n    element = this.queue.shift();\n\n    this[element.action].apply(this, element.args);\n  }\n}\n\nfunction isReady() {\n  return this.kuzzle.state === 'connected' && !this.subscribing;\n}\n\nmodule.exports = KuzzleRoom;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleRoom.js\n// module id = 9\n// module chunks = 0","/**\n *\n * @param {KuzzleDataCollection} dataCollection\n * @param {int} total\n * @param {KuzzleDocument[]} documents\n * @param {object} [aggregations]\n * @param {object} [searchArgs]\n * @param {KuzzleSearchResult} [previous]\n * @constructor\n */\nfunction KuzzleSearchResult (dataCollection, total, documents, aggregations, searchArgs, previous) {\n  Object.defineProperties(this, {\n    // read-only properties\n    dataCollection: {\n      value: dataCollection,\n    },\n    total: {\n      value: total,\n      enumerable: true\n    },\n    documents: {\n      value: documents,\n      enumerable: true\n    },\n    aggregations: {\n      value: aggregations || {},\n      enumerable: true\n    },\n    searchArgs: {\n      value: searchArgs || {},\n      enumerable: true\n    },\n    // writable properties\n    fetchedDocument: {\n      value: documents.length,\n      enumerable: true,\n      writable: true\n    },\n    _previous: {\n      value: previous || null,\n      writable: true\n    },\n    _next: {\n      value: null,\n      writable: true\n    }\n  });\n\n  if (this._previous instanceof KuzzleSearchResult) {\n    this._previous._next = this;\n    this.fetchedDocument += this._previous.fetchedDocument;\n  }\n\n  // promisifying\n  if (this.dataCollection.kuzzle.bluebird) {\n    return this.dataCollection.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['previous', 'next'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * @param cb\n * @returns {*}\n */\nKuzzleSearchResult.prototype.previous = function (cb) {\n  cb(null, this._previous);\n\n  return this;\n};\n\n/**\n * @param {function} cb\n */\nKuzzleSearchResult.prototype.next = function (cb) {\n  var\n    filters,\n    options = Object.assign({}, this.searchArgs.options),\n    self = this;\n\n  if (!this._next) {\n    // retrieve next results with scroll if original search use it\n    if (options.scrollId) {\n      if (this.fetchedDocument >= this.total) {\n        cb(null, null);\n        return;\n      }\n\n      this.dataCollection.scroll(\n        options.scrollId,\n        options,\n        this.searchArgs.filters || {},\n        function(error, newSearchResults) {\n          handleNextSearchResults(error, self, newSearchResults, cb);\n        }\n      );\n\n      return;\n    }\n    // retrieve next results with from/size if original search use it\n    else if (options.from !== undefined && options.size !== undefined) {\n      filters = Object.assign({}, this.searchArgs.filters);\n\n      // check if we need to do next request to fetch all matching documents\n      options.from += options.size;\n\n      if (options.from >= this.total) {\n        cb(null, null);\n\n        return;\n      }\n\n      this.dataCollection.search(\n        filters,\n        options,\n        function(error, newSearchResults) {\n          handleNextSearchResults(error, self, newSearchResults, cb);\n        }\n      );\n\n      return;\n    }\n  }\n\n  if (this._next instanceof KuzzleSearchResult) {\n    cb(null, this._next);\n\n    return;\n  }\n\n  cb(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n};\n\n/**\n * @param {Error} error\n * @param {KuzzleSearchResult} currentSearchResults\n * @param {KuzzleSearchResult} newSearchResults\n * @param {Function} cb\n */\nfunction handleNextSearchResults (error, currentSearchResults, newSearchResults, cb) {\n  if (error) {\n    cb(error);\n    return;\n  }\n\n  newSearchResults.fetchedDocument += currentSearchResults.fetchedDocument;\n\n  newSearchResults._previous = currentSearchResults;\n  currentSearchResults._next = newSearchResults;\n\n\n  cb(null, newSearchResults);\n}\n\nmodule.exports = KuzzleSearchResult;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleSearchResult.js\n// module id = 10\n// module chunks = 0","/**\n * Sugar-code handling the result of a KuzzleRoom.renew call\n * @constructor\n */\nfunction KuzzleSubscribeResult() {\n  this.cbs = [];\n  this.error = null;\n  this.room = null;\n}\n\n/**\n * Registers a callback to be called with a subscription result\n * @param {Function} cb\n */\nKuzzleSubscribeResult.prototype.onDone = function (cb) {\n  if (this.error || this.room) {\n    cb(this.error, this.room);\n  }\n  else {\n    this.cbs.push(cb);\n  }\n\n  return this;\n};\n\n/**\n * Calls all registered callbacks\n *\n * @param {Object} error object\n * @param {KuzzleRoom} room\n */\nKuzzleSubscribeResult.prototype.done = function (error, room) {\n  this.error = error;\n  this.room = room;\n\n  this.cbs.forEach(function (cb) {\n    cb(error, room);\n  });\n};\n\nmodule.exports = KuzzleSubscribeResult;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/kuzzleSubscribeResult.js\n// module id = 11\n// module chunks = 0","/**\n *\n * @param host\n * @param wsPort\n * @param ioPort\n * @param sslConnection\n * @returns {Object} tnstantiated WebSocket/Socket.IO object\n */\n\nfunction network(host, wsPort, ioPort, sslConnection) {\n  // Web browser / NodeJS websocket handling\n  if (typeof window !== 'undefined') {\n    // use native websockets if the browser supports it\n    if (typeof WebSocket !== 'undefined') {\n      return new (require('./wrappers/websocket'))(host, wsPort, sslConnection);\n    }\n    // otherwise fallback to socket.io, if available\n    else if (window.io) {\n      return new (require('./wrappers/socketio'))(host, ioPort, sslConnection);\n    }\n\n    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n  }\n\n  return new (require('./wrappers/websocket'))(host, wsPort, sslConnection);\n}\n\nmodule.exports = network;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/index.js\n// module id = 12\n// module chunks = 0","function SocketIO(host, port, ssl) {\n  this.host = host;\n  this.port = port;\n  this.ssl = ssl;\n  this.socket = null;\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: autoReconnect,\n      reconnectionDelay: reconnectionDelay,\n      forceNew: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.socket.on('connect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.socket.on('connect_error', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.socket.on('disconnect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.socket.on('reconnect', callback);\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    this.socket.once(roomId, callback);\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    this.socket.on(roomId, callback);\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    this.socket.off(roomId, callback);\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    this.socket.emit('kuzzle', payload);\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.socket.close();\n    this.socket = null;\n  };\n}\n\nmodule.exports = SocketIO;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/networkWrapper/wrappers/socketio.js\n// module id = 13\n// module chunks = 0","var\n  KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\nfunction KuzzleProfile(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nKuzzleProfile.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleProfile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.kuzzleSecurity.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nKuzzleProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nKuzzleProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = KuzzleProfile;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleProfile.js\n// module id = 14\n// module chunks = 0","var KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\nfunction KuzzleRole(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nKuzzleRole.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleRole\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleRole} this object\n */\nKuzzleRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = KuzzleRole;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleRole.js\n// module id = 15\n// module chunks = 0","var\n  KuzzleRole = require('./kuzzleRole'),\n  KuzzleProfile = require('./kuzzleProfile'),\n  KuzzleUser = require('./kuzzleUser');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {KuzzleSecurity}\n * @constructor\n */\nfunction KuzzleSecurity(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['roleFactory', 'profileFactory', 'userFactory', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for getRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new KuzzleRole(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nKuzzleSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new KuzzleRole(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleRole(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err) {\n    cb(err, err ? undefined : new KuzzleRole(self, id, content));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new KuzzleRole object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @constructor\n */\nKuzzleSecurity.prototype.roleFactory = function(id, content) {\n  return new KuzzleRole(this, id, content);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for getProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new KuzzleProfile(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new KuzzleProfile(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: response.result.total, profiles: documents });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {object} content - attribute `roles` in `content` must only contains an array of role id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createProfile = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleProfile(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {object} content - a plain javascript object representing the profile's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.updateProfile = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new KuzzleProfile(self, res.result._id, updatedContent));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new KuzzleProfile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @constructor\n */\nKuzzleSecurity.prototype.profileFactory = function(id, content) {\n  return new KuzzleProfile(this, id, content);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for getUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new KuzzleUser(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created wont be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new KuzzleUser(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: response.result.total, users: documents });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same user already exists: throw an error if sets to false.\n *        Replace the existing user otherwise\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'createUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createUser: cannot create a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceUser' : 'createUser';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createRestrictedUser: cannot create a user without a user ID');\n  }\n\n  if (content.profileIds) {\n    throw new Error('KuzzleSecurity.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new KuzzleUser(self, res.result._id, res.result._source));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {KuzzleSecurity} this object\n */\nKuzzleSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new KuzzleUser object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @constructor\n */\nKuzzleSecurity.prototype.userFactory = function(id, content) {\n  return new KuzzleUser(this, id, content);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nKuzzleSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nKuzzleSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\nmodule.exports = KuzzleSecurity;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/security/kuzzleSecurity.js\n// module id = 16\n// module chunks = 0","\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/uuid/lib/rng-browser.js\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}
>>>>>>> origin/master
