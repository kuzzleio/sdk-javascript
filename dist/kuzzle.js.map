{"version":3,"sources":["webpack://Kuzzle/webpack/universalModuleDefinition","webpack://Kuzzle/webpack/bootstrap","webpack://Kuzzle/./src/security/SecurityDocument.js","webpack://Kuzzle/./node_modules/uuid/v4.js","webpack://Kuzzle/./src/eventEmitter/index.js","webpack://Kuzzle/./src/controllers/searchResult/base.js","webpack://Kuzzle/./src/security/User.js","webpack://Kuzzle/./src/networkWrapper/protocols/abstract/realtime.js","webpack://Kuzzle/./src/Kuzzle.js","webpack://Kuzzle/./node_modules/uuid/lib/rng-browser.js","webpack://Kuzzle/./node_modules/uuid/lib/bytesToUuid.js","webpack://Kuzzle/./src/controllers/collection.js","webpack://Kuzzle/./src/controllers/searchResult/specifications.js","webpack://Kuzzle/./src/controllers/document.js","webpack://Kuzzle/./src/controllers/searchResult/document.js","webpack://Kuzzle/./src/controllers/index.js","webpack://Kuzzle/./src/controllers/realtime/index.js","webpack://Kuzzle/./src/controllers/realtime/room.js","webpack://Kuzzle/./src/controllers/server.js","webpack://Kuzzle/./src/security/Security.js","webpack://Kuzzle/./src/security/Role.js","webpack://Kuzzle/./src/security/Profile.js","webpack://Kuzzle/./src/MemoryStorage.js","webpack://Kuzzle/./src/networkWrapper/index.js","webpack://Kuzzle/./src/networkWrapper/protocols/websocket.js","webpack://Kuzzle/./src/networkWrapper/protocols/socketio.js"],"names":["root","factory","exports","module","define","amd","Kuzzle","window","e","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","t","SecurityDocument","Security","id","content","meta","Error","defineProperties","this","kuzzle","writable","setContent","bluebird","promisifyAll","suffix","filter","func","target","passes","indexOf","data","serialize","_id","body","delete","options","cb","query","buildQueryArgs","deleteActionName","error","res","result","update","self","updateActionName","response","_source","rng","bytesToUuid","buf","offset","Array","rnds","random","ii","Listener","fn","once","arguments","length","_classCallCheck","KuzzleEventEmitter","_events","listeners","Boolean","find","listener","eventName","map","listenerType","_typeof","_exists","push","addListener","concat","key","addOnceListener","prependListener","index","findIndex","splice","onceListeners","_len","payload","_key","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","apply","err","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","toDelete","removeListener","keys","[object Object]","request","fetched","hits","total","controller","searchAction","scrollAction","Promise","resolve","scroll","assign","scrollId","then","size","sort","search_after","hit","from","reject","KuzzleSecurityDocument","User","credentials","create","constructor","setProfiles","profileIds","isArray","setCredentials","addProfile","profileId","creationSerialize","replace","saveRestricted","getProfileIds","getProfiles","fetchedProfiles","errored","callbackRequired","forEach","fetchProfile","profile","uuidv4","RTWrapper","host","_this","__proto__","getPrototypeOf","port","ssl","sslConnection","queuing","reconnectionDelay","autoReconnect","autoQueue","autoReplay","state","offlineQueue","queueFilter","queueMaxSize","queueTTL","replayInterval","offlineQueueLoader","opt","getOwnPropertyDescriptor","offlineMode","wasConnected","stopRetryingToConnect","retrying","startQueuing","emit","stopQueuing","playQueue","_this2","setTimeout","connect","_cleanQueue","_dequeue","_this3","on","channel","fromSelf","volatile","sdkInstanceId","removeAllListeners","_this4","queuable","ts","Date","now","_emitRequest","_discardRequest","_this5","lastDocumentIndex","droppedRequest","_this6","uniqueQueue","additionalQueue","requestId","action","dequeuingProcess","catch","shift","Math","max","_this7","message","status","send","JSON","stringify","CollectionController","DocumentController","IndexController","RealtimeController","ServerController","MemoryStorage","networkWrapper","eventActions","autoResubscribe","defaultIndex","jwt","protocol","sdkVersion","collection","document","realtime","server","errorMessagePrefix","callback","eventTimeout","connected","timeout","disconnected","reconnected","tokenExpired","loginAttempt","network","set","checkPropertyType","eumerable","unsetJwt","_get2","protectedEvent","protectedEvents","lastEmitted","_get","connectionError","internal","disconnect","checkToken","valid","token","success","strategy","expiresIn","setJwt","security","_meta","event","toString","flushQueue","close","collections","prop","typestr","getRandomValues","crypto","bind","msCrypto","rnds8","Uint8Array","byteToHex","substr","bth","SpecificationsSearchResult","topions","SearchResultBase","super","DocumentSearchResult","includeTrash","count","refresh","documents","ids","retryOnConflict","indexes","autoRefresh","Room","subscriptions","filters","channels","roomId","room","subscribe","rooms","removeListeners","subscribeToSelf","_listenToChannelListener","_reSubscribeListener","exists","Role","Profile","fetchRole","searchRoles","doc","roles","createRole","replaceIfExist","updateRole","deleteRole","role","searchProfiles","profiles","createProfile","policies","updateProfile","updatedContent","deleteProfile","scrollProfiles","newProfile","version","_version","fetchUser","searchUsers","users","createUser","replaceUser","createRestrictedUser","updateUser","deleteUser","scrollUsers","user","newUser","isActionAllowed","rights","filteredRights","right","some","item","getUserRights","userId","createCredentials","kuid","deleteCredentials","getAllCredentialFields","getCredentialFields","getCredentials","hasCredentials","updateCredentials","validateCredentials","save","addPolicy","policy","roleId","setPolicies","getPolicies","getId","required","getIdField","getKeys","getMember","getxScan","opts","mapResults","mapScanResults","getZrange","assignZrangeOptions","mapZrangeResults","getZrangeBy","setId","setIdValue","commands","append","bitcount","bitop","bitpos","dbsize","decr","decrby","del","expire","expireat","flushdb","mapNoResult","geoadd","geodist","parseFloat","geohash","geopos","results","coords","latlon","georadius","assignGeoRadiusOptions","mapGeoRadiusResults","georadiusbymember","getbit","getrange","getset","hdel","hexists","hget","hgetall","hincrby","hincrbyfloat","hkeys","hlen","hmget","hmset","hscan","hset","hsetnx","hstrlen","hvals","incr","incrby","incrbyfloat","lindex","linsert","llen","lpop","lpush","lpushx","lrange","lrem","lset","ltrim","mget","mset","msetnx","persist","pexpire","pexpireat","pfadd","pfcount","pfmerge","ping","psetex","pttl","randomkey","rename","renamenx","rpop","rpoplpush","rpush","rpushx","sadd","scan","scard","sdiff","sdiffstore","setex","setnx","sinter","sinterstore","sismember","smembers","smove","spop","mapStringToArray","srandmember","srem","sscan","strlen","sunion","sunionstore","time","parseInt","touch","ttl","type","zadd","zcard","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrevrangebylex","zrangebyscore","zrank","zrem","zremrangebylex","zremrangebyrank","zremrangebyscore","zrevrange","zrevrangebyscore","zrevrank","zscan","zscore","zunionstore","assignParameter","parsed","limit","point","coordinates","coord","distance","buffer","mapped","member","score","cursor","values","command","args","slice","pop","param","WebSocket","io","WebSocketClient","WSNode","code","client","lasturl","url","perMessageDeflate","Function","u","onopen","clientConnected","onclose","closeEvent","reason","clientDisconnected","clientNetworkError","onerror","onmessage","parse","readyState","OPEN","SocketIO","socket","forceDisconnect","eventsWrapper","reconnection","forceNew","_addEventWrapper","off","wrapper","_event","Set","add"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Kuzzle\"] = factory();\n\telse\n\t\troot[\"Kuzzle\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","function SecurityDocument(Security, id, content, meta) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: Security.kuzzle\n    },\n    Security: {\n      value: Security\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    meta: {\n      value: meta || {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {SecurityDocument} this\n */\nSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {SecurityDocument} this\n */\nSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.Security.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\nmodule.exports = SecurityDocument;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","class Listener {\n  constructor(fn, once = false) {\n    this.fn = fn;\n    this.once = once;\n  }\n}\n\nclass KuzzleEventEmitter {\n  constructor() {\n    this._events = {};\n  }\n\n  _exists (listeners, fn) {\n    return Boolean(listeners.find(listener => listener.fn === fn));\n  }\n\n  listeners (eventName) {\n    if (this._events[eventName] === undefined) {\n      return [];\n    }\n\n    return this._events[eventName].map(listener => listener.fn);\n  }\n\n  addListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    const listenerType = typeof listener;\n\n    if (listenerType !== 'function') {\n      throw new Error(`Invalid listener type: expected a function, got a ${listenerType}`);\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName].push(new Listener(listener, once));\n    }\n\n    return this;\n  }\n\n  on (eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n\n  prependListener (eventName, listener, once = false) {\n    if (!eventName || !listener) {\n      return this;\n    }\n\n    if (this._events[eventName] === undefined) {\n      this._events[eventName] = [];\n    }\n\n    if (!this._exists(this._events[eventName], listener)) {\n      this._events[eventName] = [new Listener(listener, once)].concat(this._events[eventName]);\n    }\n\n    return this;\n  }\n\n  addOnceListener (eventName, listener) {\n    return this.addListener(eventName, listener, true);\n  }\n\n  once (eventName, listener) {\n    return this.addOnceListener(eventName, listener);\n  }\n\n  prependOnceListener (eventName, listener) {\n    return this.prependListener(eventName, listener, true);\n  }\n\n  removeListener (eventName, listener) {\n    const listeners = this._events[eventName];\n\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n\n    const index = listeners.findIndex(l => l.fn === listener);\n\n    if (index !== -1) {\n      listeners.splice(index, 1);\n    }\n\n    if (listeners.length === 0) {\n      delete this._events[eventName];\n    }\n\n    return this;\n  }\n\n  removeAllListeners (eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n\n    return this;\n  }\n\n  emit (eventName, ...payload) {\n    const listeners = this._events[eventName];\n\n    if (listeners === undefined) {\n      return false;\n    }\n\n    const onceListeners = [];\n\n    for (const listener of listeners) {\n      listener.fn(...payload);\n\n      if (listener.once) {\n        onceListeners.push(listener.fn);\n      }\n    }\n\n    for (const toDelete of onceListeners) {\n      this.removeListener(eventName, toDelete);\n    }\n\n    return true;\n  }\n\n  eventNames () {\n    return Object.keys(this._events);\n  }\n\n  listenerCount (eventName) {\n    return this._events[eventName] && this._events[eventName].length || 0;\n  }\n}\n\nmodule.exports = KuzzleEventEmitter;\n","class SearchResultBase {\n\n  /**\n   *\n   * @param {Kuzzle} kuzzle\n   * @param {object} request\n   * @param {object} options\n   * @param {object} response\n   */\n  constructor (kuzzle, request = {}, options = {}, response = {}) {\n    this.kuzzle = kuzzle;\n    this.request = request;\n    this.options = options;\n    this.response = response;\n\n    this.fetched = response.hits && response.hits.length || 0;\n    this.total = response.total && response.total || 0;\n\n    this.controller = 'controller';\n    this.searchAction = 'search';\n    this.scrollAction = 'scroll';\n  }\n\n  next () {\n    if (this.fetched >= this.total) {\n      return Promise.resolve(null);\n    }\n\n    if (this.request.scroll) {\n      return this.kuzzle.query(Object.assign({}, this.request, {\n        scrollId: this.response.scrollId\n      }), options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          return this;\n        });\n    }\n\n    if (this.request.size && this.request.sort) {\n      const\n        request = Object.assign({}, this.request, {\n          search_after: []\n        }),\n        hit = this.response.hits && this.response.hits[this.response.hits.length -1];\n\n      for (const sort of this.request.sort) {\n        if (typeof sort === 'string') {\n          request.search_after.push(hit._source[sort]);\n        }\n        else {\n          request.search_after.push(hit._source[Object.keys(sort)[0]]);\n        }\n      }\n\n      return this.kuzzle.query(request, this.options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          return this;\n        });\n    }\n\n    if (this.request.from && this.request.size) {\n      if (this.request.from >= this.response.total) {\n        return Promise.resolve(null);\n      }\n\n      return this.kuzzle.query(Object.assign({}, this.request, {\n        from: this.fetched + 1\n      }), this.options)\n        .then(r => {\n          this.fetched += r.hits.length;\n          this.response = r;\n          return this;\n        });\n    }\n\n    return Promise.reject(new Error('Unable to retrieve next results from search: missing scrollId or from/size params'));\n  }\n}\n\nmodule.exports = SearchResultBase;\n","var\n  KuzzleSecurityDocument = require('./SecurityDocument');\n\n/**\n * @param {Security} Security\n * @param {string} id\n * @param {Object} content\n * @constructor\n */\nfunction User(Security, id, content, meta) {\n  KuzzleSecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    },\n    credentials: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['create', 'replace', 'saveRestricted', 'update', 'getProfiles'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: User\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profileIds - an array of profiles ids string\n *\n * @returns {User} this\n */\nUser.prototype.setProfiles = function (profileIds) {\n  if (!Array.isArray(profileIds) || typeof profileIds[0] !== 'string') {\n    throw new Error('Parameter \"profileIds\" must be an array of strings');\n  }\n\n  this.content.profileIds = profileIds;\n\n  return this;\n};\n\n/**\n * @param {object} credentials\n */\nUser.prototype.setCredentials = function (credentials) {\n  if (typeof credentials !== 'object') {\n    throw new Error('Parameter \"credentials\" must be a object');\n  }\n\n  this.credentials = credentials;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profileId - a profile ids string\n *\n * @returns {User} this\n */\nUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profileIds) {\n    this.content.profileIds = [];\n  }\n\n  if (this.content.profileIds.indexOf(profileId) === -1) {\n    this.content.profileIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Creates this user into Kuzzle\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.create = function (options, cb) {\n  var\n    data = this.creationSerialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.Security.buildQueryArgs('createUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n\n/**\n * Replaces the latest version of this user in Kuzzle by the current content of this object.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.replace = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (!this.content.profileIds) {\n    throw new Error('Argument \"profileIds\" is mandatory in a user. This argument contains an array of profile identifiers.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n\n  this.kuzzle.query(this.Security.buildQueryArgs('replaceUser'), data, null, cb && function (err) {\n    cb(err, err ? undefined : self);\n  });\n\n  return this;\n};\n\n/**\n * Saves this user as restricted into Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * The \"profileIds\" property must not be provided, or the request will be rejected by Kuzzle.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {User} this\n */\nUser.prototype.saveRestricted = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createRestrictedUser'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.serialize = function () {\n  return {_id: this.id, body: this.content, meta: this.meta};\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nUser.prototype.creationSerialize = function () {\n  return {_id: this.id, body: {content: this.content, credentials: this.credentials, meta: this.meta}};\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array.<string>} the associated profiles IDs\n */\nUser.prototype.getProfileIds = function () {\n  return this.content.profileIds || [];\n};\n\n/**\n * Return the associated Profile objects\n *\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n */\nUser.prototype.getProfiles = function (options, cb) {\n  var \n    self = this,\n    fetchedProfiles = [],\n    errored = false;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.Security.kuzzle.callbackRequired('User.getProfiles', cb);\n\n  if (!self.content.profileIds) {\n    return cb(null, fetchedProfiles);\n  }\n\n  self.content.profileIds.forEach(function (profileId) {\n    self.Security.fetchProfile(profileId, options, function (error, profile) {\n      if (error) {\n        if (errored) {\n          return;\n        }\n\n        errored = true; // prevents multiple callback resolutions\n        return cb(error);\n      }\n\n      fetchedProfiles.push(profile);\n\n      if (fetchedProfiles.length === self.content.profileIds.length) {\n        cb(null, fetchedProfiles);\n      }\n    });\n  });\n};\n\nmodule.exports = User;\n","'use strict';\n\nconst\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('../../../eventEmitter');\n\nlet\n  _id = uuidv4();\n\n\nclass RTWrapper extends KuzzleEventEmitter {\n\n  constructor (host, options) {\n    super();\n\n    Object.defineProperties(this, {\n      host: {\n        value: host,\n        enumerable: true\n      },\n      port: {\n        value: (options && typeof options.port === 'number') ? options.port : 7512,\n        enumerable: true\n      },\n      ssl: {\n        value: (options && typeof options.sslConnection === 'boolean') ? options.sslConnection : false,\n        enumerable: true\n      },\n      queuing: {\n        value: false,\n        writable: true\n      },\n      reconnectionDelay: {\n        value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n        enumerable: true\n      },\n      // configuration properties\n      autoReconnect: {\n        value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n        enumerable: true\n      },\n      autoQueue: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      autoReplay: {\n        value: false,\n        enumerable: true,\n        writable: true\n      },\n      state: {\n        value: 'offline',\n        enumerable: true,\n        writable: true\n      },\n      /*\n        Offline queue use the following format:\n              [\n                {\n                  ts: <query timestamp>,\n                  query: 'query',\n                  resolve,\n                  reject\n                }\n              ]\n       */\n      offlineQueue: {\n        value: [],\n        enumerable: true,\n        writable: true\n      },\n      queueFilter: {\n        value: null,\n        enumerable: true,\n        writable: true\n      },\n      queueMaxSize: {\n        value: 500,\n        enumerable: true,\n        writable: true\n      },\n      queueTTL: {\n        value: 120000,\n        enumerable: true,\n        writable: true\n      },\n      replayInterval: {\n        value: 10,\n        enumerable: true,\n        writable: true\n      },\n      offlineQueueLoader: {\n        value: null,\n        enumerable: true,\n        writable: true\n      }\n    });\n\n    if (options) {\n      Object.keys(options).forEach(opt => {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      });\n\n      if (options.offlineMode === 'auto' && this.autoReconnect) {\n        this.autoQueue = this.autoReplay = true;\n      }\n    }\n\n    this.wasConnected = false;\n    this.stopRetryingToConnect = false;\n    this.retrying = false;\n  }\n\n  get id () {\n    return _id;\n  }\n\n  connect() {\n    this.state = 'connecting';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n  }\n\n  /**\n   * Called when the client's connection is established\n   */\n  clientConnected() {\n    this.state = 'connected';\n    this.emit(this.wasConnected && 'reconnect' || 'connect');\n    this.wasConnected = true;\n    this.stopRetryingToConnect = false;\n\n    if (this.autoQueue) {\n      this.stopQueuing();\n    }\n\n    if (this.autoReplay) {\n      this.playQueue();\n    }\n  }\n\n  /**\n   * Called when the client's connection is closed\n   */\n  clientDisconnected() {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.emit('disconnect');\n  }\n\n  /**\n   * Called when the client's connection is closed with an error state\n   *\n   * @param {Error} error\n   */\n  clientNetworkError(error) {\n    this.state = 'offline';\n    if (this.autoQueue) {\n      this.startQueuing();\n    }\n\n    this.emit('networkError', error);\n    if (this.autoReconnect && !this.retrying && !this.stopRetryingToConnect) {\n      this.retrying = true;\n      setTimeout(() => {\n        this.retrying = false;\n        this.connect();\n      }, this.reconnectionDelay);\n    } else {\n      this.emit('disconnect');\n    }\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   */\n  flushQueue() {\n    this.offlineQueue = [];\n  }\n\n  /**\n   * Replays the requests queued during offline mode.\n   */\n  playQueue() {\n    if (this.state === 'connected') {\n      this._cleanQueue();\n      this._dequeue();\n    }\n  }\n\n  /**\n   * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  startQueuing() {\n    this.queuing = true;\n  }\n\n  /**\n   * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n   */\n  stopQueuing() {\n    this.queuing = false;\n  }\n\n  subscribe(request, options, cb) {\n    if (this.state !== 'connected') {\n      return Promise.reject(new Error('Not Connected'));\n    }\n\n    return this.query(request, options)\n      .then(response => {\n        this.on(response.result.channel, data => {\n          data.fromSelf = data.volatile !== undefined && data.volatile.sdkInstanceId === this.id;\n          cb(data);\n        });\n\n        return response.result;\n      });\n  }\n\n  unsubscribe(object, channel) {\n    this.removeAllListeners(channel);\n    return this.query(object);\n  }\n\n  /**\n   * Sends a raw request to Kuzzle\n   *\n   * @param {object} request\n   * @param options\n   * @returns {Promise}\n   */\n  query(request, options) {\n    let queuable = options && (options.queuable !== false) || true;\n\n    if (this.queueFilter) {\n      queuable = queuable && this.queueFilter(request);\n    }\n\n    if (this.queuing && queuable) {\n      this._cleanQueue();\n\n      this.emit('offlineQueuePush', {query: request});\n      return new Promise((resolve, reject) => {\n        this.offlineQueue.push({\n          resolve,\n          reject,\n          ts: Date.now(),\n          query: request\n        });\n      });\n    }\n\n    if (this.state === 'connected') {\n      return this._emitRequest(request);\n    }\n\n    return this.constructor._discardRequest(request);\n  }\n\n  /**\n   * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n   *\n   * @private\n   */\n  _cleanQueue () {\n    const now = Date.now();\n    let lastDocumentIndex = -1;\n\n    if (this.queueTTL > 0) {\n      this.offlineQueue.forEach((query, index) => {\n        if (query.ts < now - this.queueTTL) {\n          lastDocumentIndex = index;\n        }\n      });\n\n      if (lastDocumentIndex !== -1) {\n        this.offlineQueue\n          .splice(0, lastDocumentIndex + 1)\n          .forEach(droppedRequest => {\n            this.emit('offlineQueuePop', droppedRequest.query);\n          });\n      }\n    }\n\n    if (this.queueMaxSize > 0 && this.offlineQueue.length > this.queueMaxSize) {\n      this.offlineQueue\n        .splice(0, this.offlineQueue.length - this.queueMaxSize)\n        .forEach(droppedRequest => {\n          this.emit('offlineQueuePop', droppedRequest.query);\n        });\n    }\n\n  }\n\n  /**\n   * Play all queued requests, in order.\n   *\n   * @private\n   */\n  _dequeue () {\n    const\n      uniqueQueue = {},\n      dequeuingProcess = () => {\n        if (this.offlineQueue.length > 0) {\n          this._emitRequest(this.offlineQueue[0].query)\n            .then(response => this.offlineQueue[0].resolve(response))\n            .catch(error => this.offlineQueue[0].reject(error));\n\n          this.emit('offlineQueuePop', this.offlineQueue.shift());\n\n          setTimeout(() => {\n            dequeuingProcess();\n          }, Math.max(0, this.replayInterval));\n        }\n      };\n\n    if (this.offlineQueueLoader) {\n      if (typeof this.offlineQueueLoader !== 'function') {\n        throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof this.offlineQueueLoader);\n      }\n\n      const additionalQueue = this.offlineQueueLoader();\n      if (Array.isArray(additionalQueue)) {\n        this.offlineQueue = additionalQueue\n          .concat(this.offlineQueue)\n          .filter(request => {\n            // throws if the query object does not contain required attributes\n            if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n              throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n            }\n\n            return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n          });\n      } else {\n        throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n      }\n    }\n\n    dequeuingProcess();\n  }\n\n  /**\n   * @param request\n   * @returns {Promise<any>}\n   * @private\n   */\n  _emitRequest (request) {\n    return new Promise((resolve, reject) => {\n      this.once(request.requestId, response => {\n        let error = null;\n\n        if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n          this.emit('tokenExpired', request);\n        }\n\n        if (response.error) {\n          error = new Error(response.error.message);\n          Object.assign(error, response.error);\n          error.status = response.status;\n\n          this.emit('queryError', error);\n          return reject(error);\n        }\n\n        return resolve(response);\n      });\n\n      // Track requests made to allow Room.subscribeToSelf to work\n      this.send(request);\n    });\n  }\n\n  /**\n   * @param object\n   * @returns {Promise<never>}\n   * @private\n   */\n  static _discardRequest (object) {\n    return Promise.reject(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n  }\n\n}\n\nmodule.exports = RTWrapper;\n","const\n  uuidv4 = require('uuid/v4'),\n  KuzzleEventEmitter = require('./eventEmitter'),\n  CollectionController = require('./controllers/collection'),\n  DocumentController = require('./controllers/document'),\n  IndexController = require('./controllers/index'),\n  RealtimeController = require('./controllers/realtime'),\n  ServerController = require('./controllers/server'),\n  Security = require('./security/Security'),\n  MemoryStorage = require('./MemoryStorage'),\n  User = require('./security/User'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n */\nclass Kuzzle extends KuzzleEventEmitter {\n  constructor(host, options) {\n    super();\n\n    if (!host || host === '') {\n      throw new Error('host argument missing');\n    }\n\n    Object.defineProperties(this, {\n      // 'private' properties\n      eventActions: {\n        value: [\n          'connected',\n          'discarded',\n          'disconnected',\n          'loginAttempt',\n          'networkError',\n          'offlineQueuePush',\n          'offlineQueuePop',\n          'queryError',\n          'reconnected',\n          'tokenExpired'\n        ]\n      },\n      // configuration properties\n      autoResubscribe: {\n        value: options && typeof options.autoResubscribe === 'boolean' ? options.autoResubscribe : true,\n        enumerable: true\n      },\n      defaultIndex: {\n        value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n        writable: true,\n        enumerable: true\n      },\n      jwt: {\n        value: undefined,\n        enumerable: true,\n        writable: true\n      },\n      protocol: {\n        value: (options && typeof options.protocol === 'string') ? options.protocol : 'websocket',\n        enumerable: true\n      },\n      sdkVersion: {\n        value: (typeof SDKVERSION === 'undefined') ? require('../package.json').version : SDKVERSION\n      },\n      volatile: {\n        value: {},\n        enumerable: true,\n        writable: true\n      },\n      collection: {\n        value: new CollectionController(this),\n        enumerable: true\n      },\n      document: {\n        value: new DocumentController(this),\n        enumerable: true\n      },\n      index: {\n        value: new IndexController(this),\n        enumerable: true\n      },\n      realtime: {\n        value: new RealtimeController(this),\n        enumerable: true\n      },\n      server: {\n        value: new ServerController(this),\n        enumerable: true\n      }\n\n    });\n\n    if (options) {\n      for (const opt of Object.keys(options)) {\n        if (this.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(this, opt).writable) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    /**\n     * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n     * and is called by these methods\n     */\n    Object.defineProperty(this, 'callbackRequired', {\n      value: (errorMessagePrefix, callback) => {\n        if (!callback || typeof callback !== 'function') {\n          throw new Error(`${errorMessagePrefix}: a callback argument is required for read queries`);\n        }\n      }\n    });\n\n    /**\n     * Create an attribute security that embed all methods to manage Role, Profile and User\n     */\n    Object.defineProperty(this, 'security', {\n      value: new Security(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'memoryStorage', {\n      value: new MemoryStorage(this),\n      enumerable: true\n    });\n\n    Object.defineProperty(this, 'collections',{\n      value: {},\n      writable: true\n    });\n\n    Object.defineProperty(this, 'eventTimeout',{\n      value: options && typeof options.eventTimeout === 'number' ? options.eventTimeout : 200\n    });\n\n    Object.defineProperty(this, 'protectedEvents', {\n      value: {\n        connected: {timeout: this.eventTimeout},\n        error: {timeout: this.eventTimeout},\n        disconnected: {timeout: this.eventTimeout},\n        reconnected: {timeout: this.eventTimeout},\n        tokenExpired: {timeout: this.eventTimeout},\n        loginAttempt: {timeout: this.eventTimeout}\n      }\n    });\n\n    this.network = networkWrapper(this.protocol, host, options);\n\n    // Properties related to the network layer\n    // Accessing a property irrelevant for a given protocol\n    // (e.g. \"autoReconnect\" for the HTTP layer) should\n    // throw an exception\n    Object.defineProperties(this, {\n      autoQueue: {\n        enumerable: true,\n        get: () => this.network.autoQueue,\n        set: value => {\n          checkPropertyType('autoQueue', 'boolean', value);\n          this.network.autoQueue = value;\n        }\n      },\n      autoReconnect: {\n        enumerable: true,\n        get: () => this.network.autoReconnect\n      },\n      autoReplay: {\n        enumerable: true,\n        get: () => this.network.autoReplay,\n        set: value => {\n          checkPropertyType('autoReplay', 'boolean', value);\n          this.network.autoReplay = value;\n        }\n      },\n      host: {\n        enumerable: true,\n        get: () => this.network.host\n      },\n      offlineQueue: {\n        enumerable: true,\n        get: () => this.network.offlineQueue\n      },\n      offlineQueueLoader: {\n        enumerable: true,\n        get: () => this.network.offlineQueueLoader,\n        set: value => {\n          if (value !== null) {\n            checkPropertyType('offlineQueueLoader', 'function', value);\n          }\n          this.network.offlineQueueLoader = value;\n        }\n      },\n      port: {\n        enumerable: true,\n        get: () => this.network.port\n      },\n      queueFilter: {\n        enumerable: true,\n        get: () => this.network.queueFilter,\n        set: value => {\n          checkPropertyType('queueFilter', 'function', value);\n          this.network.queueFilter = value;\n        }\n      },\n      queueMaxSize: {\n        enumerable: true,\n        get: () => this.network.queueMaxSize,\n        set: value => {\n          checkPropertyType('queueMaxSize', 'number', value);\n          this.network.queueMaxSize = value;\n        }\n      },\n      queueTTL: {\n        enumerable: true,\n        get: () => this.network.queueTTL,\n        set: value => {\n          checkPropertyType('queueTTL', 'number', value);\n          this.network.queueTTL = value;\n        }\n      },\n      replayInterval: {\n        enumerable: true,\n        get: () => this.network.replayInterval,\n        set: value => {\n          checkPropertyType('replayInterval', 'number', value);\n          this.network.replayInterval = value;\n        }\n      },\n      reconnectionDelay: {\n        enumerable: true,\n        get: () => this.network.reconnectionDelay\n      },\n      sslConnection: {\n        eumerable: true,\n        get: () => this.network.ssl\n      }\n    });\n\n    this.network.addListener('offlineQueuePush', data => this.emit('offlineQueuePush', data));\n    this.network.addListener('offlineQueuePop', data => this.emit('offlineQueuePop', data));\n    this.network.addListener('queryError', (err, query) => this.emit('queryError', err, query));\n\n    this.network.addListener('tokenExpired', () => {\n      this.unsetJwt();\n      this.emit('tokenExpired');\n    });\n  }\n\n  /**\n  * Emit an event to all registered listeners\n  * An event cannot be emitted multiple times before a timeout has been reached.\n  */\n  emit (eventName, ...payload) {\n    const\n      now = Date.now(),\n      protectedEvent = this.protectedEvents[eventName];\n\n    if (protectedEvent) {\n      if (protectedEvent.lastEmitted && protectedEvent.lastEmitted > now - protectedEvent.timeout) {\n        return false;\n      }\n      protectedEvent.lastEmitted = now;\n    }\n\n    super.emit(eventName, ...payload);\n  }\n\n  /**\n   * Connects to a Kuzzle instance using the provided host name\n   * @param {function} [cb] Connection callback\n   */\n  connect (cb) {\n    if (this.network.state !== 'offline') {\n      if (cb) {\n        cb(null, this);\n      }\n      return;\n    }\n\n    this.network.connect();\n\n    this.network.addListener('connect', () => {\n      this.emit('connected');\n\n      if (cb) {\n        cb(null, this);\n      }\n    });\n\n    this.network.addListener('networkError', error => {\n      const connectionError = new Error(`Unable to connect to kuzzle proxy server at ${this.network.host}:${this.network.port}`);\n\n      connectionError.internal = error;\n      this.emit('networkError', connectionError);\n\n      if (cb) {\n        cb(connectionError);\n      }\n    });\n\n    this.network.addListener('disconnect', () => {\n      this.disconnect();\n      this.emit('disconnected');\n    });\n\n    this.network.addListener('reconnect', () => {\n      if (this.jwt) {\n        this.checkToken(this.jwt, (err, res) => {\n          // shouldn't obtain an error but let's invalidate the token anyway\n          if (err || !res.valid) {\n            this.unsetJwt();\n          }\n\n          this.emit('reconnected');\n        });\n      } else {\n        this.emit('reconnected');\n      }\n    });\n\n    this.network.on('discarded', data => this.emit('discarded', data));\n  }\n\n  /**\n   * Set the jwt used to query kuzzle\n   * @param token\n   * @returns {Kuzzle}\n   */\n  setJwt (token) {\n    if (typeof token === 'string') {\n      this.jwt = token;\n    } else if (typeof token === 'object') {\n      if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n        this.jwt = token.result.jwt;\n      } else {\n        this.emit('loginAttempt', {\n          success: false,\n          error: 'Cannot find a valid JWT in the following object: ' + JSON.stringify(token)\n        });\n\n        return this;\n      }\n    } else {\n      this.emit('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n      return this;\n    }\n\n    this.emit('loginAttempt', {success: true});\n    return this;\n  }\n\n  /**\n   * Unset the jwt used to query kuzzle\n   * @returns {Kuzzle}\n   */\n  unsetJwt () {\n    this.jwt = undefined;\n    return this;\n  }\n\n  /**\n   * Get the jwt used by kuzzle\n   * @returns {Kuzzle}\n   */\n  getJwt () {\n    return this.jwt;\n  }\n\n  /**\n   * Send login request to kuzzle with credentials\n   * If login success, store the jwt into kuzzle object\n   *\n   * @param strategy\n   * @param credentials\n   * @param expiresIn\n   * @param cb\n   */\n  login (strategy, ...args) {\n    if (!strategy || typeof strategy !== 'string') {\n      throw new Error('Kuzzle.login: strategy required');\n    }\n\n    const \n      request = {\n        strategy,\n        body: {}\n      };\n\n    let cb = null;\n\n    // Handle arguments (credentials, expiresIn, cb)\n    if (args[0]) {\n      if (typeof args[0] === 'object') {\n        request.body = args[0];\n      } else if (typeof args[0] === 'number' || typeof args[0] === 'string') {\n        request.expiresIn = args[0];\n      } else if (typeof args[0] === 'function') {\n        cb = args[0];\n      }\n    }\n    if (args[1]) {\n      if (typeof args[1] === 'number' || typeof args[1] === 'string') {\n        request.expiresIn = args[1];\n      } else if (typeof args[1] === 'function') {\n        cb = args[1];\n      }\n    }\n    if (args[2] && typeof args[2] === 'function') {\n      cb = args[2];\n    }\n\n    this.query({controller: 'auth', action: 'login'}, request, {queuable: false}, (error, response) => {\n      if (!error) {\n        if (response.result.jwt) {\n          this.setJwt(response.result.jwt);\n        }\n\n        cb && cb(null, response.result);\n      }\n      else {\n        cb && cb(error);\n        this.emit('loginAttempt', {success: false, error: error.message});\n      }\n    });\n  }\n\n  /**\n   * Create credentials of the specified <strategy> for the current user.\n   *\n   * @param credentials\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  createMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'createMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result._source);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Delete credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  deleteMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'deleteMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Get credential information of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param options\n   * @param cb\n   */\n  getMyCredentials (strategy, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'getMyCredentials'}, {strategy}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Update credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentals\n   * @param options\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  updateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Validate credentials of the specified <strategy> for the current user.\n   *\n   * @param strategy\n   * @param credentials\n   * @param options\n   * @param cb\n   */\n  validateMyCredentials (strategy, credentials, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'validateMyCredentials'}, {strategy, body: credentials}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n  }\n\n  /**\n   * Send logout request to kuzzle with jwt.\n   *\n   * @param cb\n   * @returns {Kuzzle}\n   */\n  logout (cb) {\n    const\n      request = {\n        action: 'logout',\n        controller: 'auth',\n        requestId: uuidv4(),\n        body: {}\n      };\n\n    this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, error => {\n      if (typeof cb === 'function') {\n        cb(error, this);\n      }\n    });\n\n    return this.unsetJwt();\n  }\n\n  /**\n   * Checks whether a given jwt token still represents a valid session in Kuzzle.\n   *\n   * @param  {string}   token     The jwt token to check\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  checkToken (token, cb) {\n    const\n      request = {\n        body: {\n          token\n        }\n      };\n\n    this.callbackRequired('Kuzzle.checkToken', cb);\n\n    this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, (err, res) => {\n      cb(err, err ? undefined : res.result);\n    });\n  }\n\n  /**\n   * Fetches the current user.\n   *\n   * @param  {function} cb  The callback to be called when the response is\n   *                              available. The signature is `function(error, response)`.\n   */\n  whoAmI (cb) {\n    this.callbackRequired('Kuzzle.whoAmI', cb);\n\n    this.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, (err, res) => {\n      cb(err, err ? undefined : new User(this.security, res.result._id, res.result._source, res.result._meta));\n    });\n  }\n\n  /**\n   * Gets the rights array of the currently logged user.\n   *\n   * @param {object} [options] - Optional parameters\n   * @param  {function} cb The callback containing the normalized array of rights.\n   */\n  getMyRights (options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.callbackRequired('Kuzzle.getMyRights', cb);\n\n    this.query({controller: 'auth', action:'getMyRights'}, {}, options, (err, res) => {\n      cb(err, err ? undefined : res.result.hits);\n    });\n  }\n\n  /**\n   * Update current user in Kuzzle.\n   *\n   * @param {object} content - a plain javascript object representing the user's modification\n   * @param {object} [options] - (optional) arguments\n   * @param {responseCallback} [cb] - (optional) Handles the query response\n   * @returns {Kuzzle} this object\n   */\n  updateSelf (content, options, cb) {\n    if (!cb && typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    this.query({controller: 'auth', action: 'updateSelf'}, {body: content}, options, (err, res) => {\n      if (typeof cb === 'function') {\n        cb(err, err ? undefined : res.result);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n   * insertion.\n   *\n   * @param {string} event - name of the global event to subscribe to\n   * @param {function} listener - callback to invoke each time an event is fired\n   */\n  addListener (event, listener) {\n    if (this.eventActions.indexOf(event) === -1) {\n      throw new Error(`[${event}] is not a known event. Known events: ${this.eventActions.toString()}`);\n    }\n\n    return super.addListener(event, listener);\n  }\n\n  /**\n   * Empties the offline queue without replaying it.\n   *\n   * @returns {Kuzzle}\n   */\n  flushQueue () {\n    this.network.flushQueue();\n    return this;\n  }\n\n  /**\n   * Disconnects from Kuzzle and invalidate this instance.\n   */\n  disconnect () {\n    this.network.close();\n\n    for (const collection of Object.keys(this.collections)) {\n      delete this.collections[collection];\n    }\n  }\n\n  /**\n   * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n   * Base method used to send read queries to Kuzzle\n   *\n   * Takes an optional argument object with the following properties:\n   *    - volatile (object, default: null):\n   *        Additional information passed to notifications to other users\n   *\n   * @param {object} queryArgs - Query configuration\n   * @param {object} query - The query data\n   * @param {object} [options] - Optional arguments\n   * @param {responseCallback} [cb] - Handles the query response\n   */\n  query (request = {}, options = {}) {\n    if (!request || typeof request !== 'object' || Array.isArray(request)) {\n      return Promise.reject(new Error(`Invalid request: ${JSON.stringify(request)}`));\n    }\n\n    // we follow the api but allow some more logical \"mistakes\"\n    if (request.options) {\n      request.options = 'wait_for';\n    }\n\n    if (!request.volatile) {\n      request.volatile = {};\n    }\n    if (!request.volatile || typeof request.volatile !== 'object' || Array.isArray(request.volatile)) {\n      return Promise.reject(new Error('Invalid volatile argument received. Must be an object.'));\n    }\n    request.volatile.sdkInstanceId= this.network.id;\n    request.volatile.sdkVersion = this.sdkVersion;\n\n    /*\n     * Do not add the token for the checkToken route, to avoid getting a token error when\n     * a developer simply wish to verify his token\n     */\n    if (this.jwt !== undefined\n      && request.controller !== 'auth'\n      && request.action !== 'checkToken'\n    ) {\n      request.jwt = this.jwt;\n    }\n\n    return this.network.query(request, options)\n      .then(response => response.result);\n  }\n\n  /**\n   * Starts the requests queuing.\n   */\n  startQueuing () {\n    this.network.startQueuing();\n    return this;\n  }\n\n  /**\n   * Stops the requests queuing.\n   */\n  stopQueuing () {\n    this.network.stopQueuing();\n    return this;\n  }\n\n  /**\n   * @DEPRECATED\n   * See Kuzzle.prototype.playQueue();\n   */\n  replayQueue () {\n    return this.playQueue();\n  }\n\n  /**\n   * Plays the requests queued during offline mode.\n   */\n  playQueue () {\n    this.network.playQueue();\n    return this;\n  }\n\n  /**\n   * Sets the default Kuzzle index\n   *\n   * @param index\n   * @returns this\n   */\n  setDefaultIndex (index) {\n    if (typeof index !== 'string') {\n      throw new Error(`Invalid default index: [${index}] (an index name is expected)`);\n    }\n\n    if (index.length === 0) {\n      throw new Error('Cannot set an empty index as the default index');\n    }\n\n    this.defaultIndex = index;\n\n    return this;\n  }\n}\n\nfunction checkPropertyType(prop, typestr, value) {\n  const wrongType = typestr === 'array' ? !Array.isArray(value) : typeof value !== typestr;\n\n  if (wrongType) {\n    throw new Error(`Can only assign a ${typestr} value to property \"${prop}\"`);\n  }\n}\n\nmodule.exports = Kuzzle;\n","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n","const\n  SpecificationsSearchResult = require('./searchResult/specifications');\n\nclass CollectionController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this.kuzzle = kuzzle;\n  }\n\n  create (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.create: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.create: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'create'\n    }, options);\n  }\n\n  deleteSpecification (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.deleteSpecification: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.deleteSpecification: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'deleteSpecification'\n    }, options);\n  }\n\n  exists (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.exists: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.exists: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'exists'\n    }, options);\n  }\n\n  getMapping (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.getMapping: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.getMapping: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'getMapping'\n    }, options);\n  }\n\n  getSpecifications (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.getSpecifications: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.getSpecifications: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'collection',\n      action: 'getSpecifications'\n    }, options);\n  }\n\n  list (index, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.list: index is required'));\n    }\n\n    const request = {\n      index,\n      controller: 'collection',\n      action: 'list',\n      from: options.from,\n      size: options.size\n    };\n    delete options.from;\n    delete topions.size;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  searchSpecifications (body = {}, options = {}) {\n    const request = {\n      body,\n      controller: 'collection',\n      action: 'searchSpecifications'\n    };\n    for (const opt of ['from', 'size', 'scroll']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(response => new SpecificationsSearchResult(this.kuzzle, query, options, response));\n  }\n\n  truncate (index, collection, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.truncate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.truncate: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      controller: 'colleciton',\n      action: 'truncate'\n    }, options);\n  }\n\n  updateMapping (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.updateMapping: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.updateMapping: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'collection',\n      action: 'updateMapping'\n    }, options);\n  }\n\n  updateSpecifications (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.collection.updateSpecifications: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.collection.updateSpecifications: collection is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'collection',\n      action: 'updateSpecifications'\n    }, options);\n  }\n\n  validateSpecifications (body, options = {}) {\n    return this.kuzzle.query({\n      body,\n      controller: 'collection',\n      action: 'validateSpecifications'\n    }, options);\n  }\n}\n\nmodule.exports = CollectionController;\n","const SearchResultBase = require('./base');\n\nclass SpecificationsSearchResult extends SearchResultBase {\n\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.controller = 'collection';\n    this.searchAction = 'searchSpecifications';\n    this.scrollAction = 'scrollSpecifications';\n  }\n}\n\nmodule.exports = SpecificationsSearchResult;\n","const\n  DocumentSearchResult = require('./searchResult/document');\n\nclass DocumentController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this.kuzzle = kuzzle;\n  }\n\n  count (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.count: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.count: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'count',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options)\n      .then(response => response.count);\n  }\n\n  create (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.create: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.create: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'create',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  createOrReplace (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: _id is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.createOrReplace: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'createOrReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  delete (index, collection, _id, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.delete: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.delete: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.delete: _id is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'delete',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  deleteByQuery(index, collection, body = {}, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.deleteByQuery: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.deleteByQuery: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'deleteByQuery',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  get (index, collection, _id, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.get: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.get: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      controller: 'document',\n      action: 'get',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mCreate (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mCreate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mCreate: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mCreate: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mCreate',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mCreateOrReplace (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mCreateOrReplace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mCreateOrReplace: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mCreateOrReplace: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mCreateOrReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mDelete (index, collection, ids, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mDelete: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mDelete: collection is required'));\n    }\n    if (!Array.isArray(ids)) {\n      return Promise.reject(new Error('Kuzzle.document.mDelete: ids must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {ids},\n      controller: 'document',\n      action: 'mDelete',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mGet (index, collection, ids, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mGet: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mGet: collection is required'));\n    }\n    if (!Array.isArray(ids)) {\n      return Promise.reject(new Error('Kuzzle.document.mGet: ids must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {ids},\n      controller: 'document',\n      action: 'mGet',\n      includeTrash: options.includeTrash\n    };\n    delete options.includeTrash;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  mReplace (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mReplace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mReplace: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mReplace: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mReplace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n    return this.kuzzle.query(request, options);\n  }\n\n  mUpdate (index, collection, documents, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.mUpdate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.mUpdate: collection is required'));\n    }\n    if (!Array.isArray(documents)) {\n      return Promise.reject(new Error('Kuzzle.document.mUpdate: documents must be an array'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body: {documents},\n      controller: 'document',\n      action: 'mUpdate',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  replace (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.replace: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.replace: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.replace: _id is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.replace: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'replace',\n      refresh: options.refresh\n    };\n    delete options.refresh;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  search (index, collection, body = {}, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.search: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.search: collection is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'search',\n    };\n    for (const opt of ['from', 'size', 'scroll', 'sort', 'includeTrash']) {\n      request[opt] = options[opt];\n      delete options[opt];\n    }\n\n    return this.kuzzle.query(request, options)\n      .then(response => new DocumentSearchResult(this.kuzzle, request, options, response));\n  }\n\n  update (index, collection, _id, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.update: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.update: collection is required'));\n    }\n    if (!_id) {\n      return Promise.reject(new Error('Kuzzle.document.update: _id is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.update: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      _id,\n      body,\n      controller: 'document',\n      action: 'update',\n      refresh: options.refresh,\n      retryOnConflict: options.retryOnConflict\n    };\n    delete options.refresh;\n    delete options.retryOnConflict;\n\n    return this.kuzzle.query(request, options);\n  }\n\n  validate (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.document.validate: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.document.validate: collection is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.document.validate: body is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'document',\n      action: 'validate'\n    }, options);\n  }\n}\n\nmodule.exports = DocumentController;\n","const\n  SearchResultBase = require('./base');\n\nclass DocumentsSearchResult extends SearchResultBase {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   * @param {object} query\n   * @param {object} options\n   * @param {object} response\n   */\n  constructor (kuzzle, query, options, response) {\n    super(kuzzle, query, options, response);\n\n    this.searchAction = 'search';\n    this.scrollAction = 'scroll';\n  }\n}\n\nmodule.exports = DocumentsSearchResult;\n","class IndexController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this.kuzzle = kuzzle;\n  }\n\n  create (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.create: index required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'create'\n    }, options);\n  }\n\n  delete (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.delete: index required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'delete'\n    }, options);\n  }\n\n  exists (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.exists: index required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action : 'exists'\n    }, options);\n  }\n\n  getAutoRefresh (index, options) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.index.getAutoRefresh: index is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'getAutoRefresh'\n    }, options);\n  }\n\n  list (options) {\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'list'\n    }, options);\n  }\n\n  mDelete (indexes, options) {\n    if (!Array.isArray(indexes)) {\n      return Promise.reject(new Error('Kuzzle.index.mDelete: indexes must be an array'));\n    }\n\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'mDelete'\n    }, {\n      body: {\n        indexes\n      }\n    }, options);\n  }\n\n  refresh (index, options) {\n    if (!index || index === '') {\n      return Promise.reject(new Error('Kuzzle.index.refresh: index is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'refresh'\n    }, options);\n  }\n\n  refreshInternal (options) {\n    return this.kuzzle.query({\n      controller: 'index',\n      action: 'refreshInternal'\n    }, options);\n  }\n\n  setAutoRefresh (index, autoRefresh, options) {\n    if (autoRefresh === undefined && typeof index === 'boolean') {\n      autoRefresh = index;\n      index = this.kuzzle.defaultIndex;\n    }\n\n    if (!index || index === '') {\n      return Promise.reject(new Error('Kuzzle.index.setAutoRefresh: index is required'));\n    }\n\n    if (typeof autoRefresh !== 'boolean') {\n      return Promise.reject(new Error('Kuzzle.index.setAutoRefresh: autoRefresh must be a boolean'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      controller: 'index',\n      action: 'setAutoRefresh',\n      body: {\n        autoRefresh\n      }\n    }, options);\n  }\n}\n\nmodule.exports = IndexController;\n","const\n  Room = require('./room');\n\nclass RealTimeController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this.kuzzle = kuzzle;\n\n    this.subscriptions = {\n      filters: {},\n      channels: {}\n    };\n  }\n\n  count (roomId, options = {}) {\n    if (!roomId) {\n      return Promise.reject(new Error('Kuzzle.realtime.count: roomId is required'));\n    }\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'count',\n      body: {roomId}\n    }, options);\n  }\n\n  join (roomId, options = {}) {\n    if (!roomId) {\n      return Promise.reject(new Error('Kuzzle.realtime.join: roomId is required'));\n    }\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'join',\n      body: {roomId}\n    }, options);\n  }\n\n  list (options = {}) {\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'list'\n    }, options);\n  }\n\n  publish (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: collection is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: body is required'));\n    }\n\n    const request = {\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'publish'\n    };\n\n    return this.kuzzle.query(request, options);\n  }\n\n  subscribe (index, collection, body, callback, options = {}) {\n    const room = new Room(this.kuzzle, index, collection, body, callback, options);\n\n    return room.subscribe()\n      .then(response => {\n        if (!this.subscriptions[room.id]) {\n          this.subscriptions[room.id] = [];\n        }\n        this.subscriptions[room.id].push(room);\n        return response;\n      });\n  }\n\n  unsubscribe (roomId, options = {}) {\n    const rooms = this.subscriptions[roomId];\n\n    if (!rooms) {\n      return Promise.reject(new Error(`not subscribed to ${roomId}`));\n    }\n\n    for (const room of rooms) {\n      room.removeListeners();\n    }\n    delete this.subscriptions[roomId];\n\n    return this.kuzzle.query({\n      controller: 'realtime',\n      action: 'unsubscribe',\n      body: {roomId}\n    }, options);\n  }\n\n  validate (index, collection, body, options = {}) {\n    if (!index) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: index is required'));\n    }\n    if (!collection) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: collection is required'));\n    }\n    if (!body) {\n      return Promise.reject(new Error('Kuzzle.realtime.publish: body is required'));\n    }\n\n    return this.kuzzle.query({\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'validate'\n    }, options);\n\n  }\n\n}\n\nmodule.exports = RealTimeController;\n","class Room {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   * @param {string} index\n   * @param {string} collection\n   * @param {object} body\n   * @param {function} callback\n   * @param {object} options\n   */\n  constructor (kuzzle, index, collection, body, callback, options = {}) {\n    this.kuzzle = kuzzle;\n    this.index = index;\n    this.collection = collection;\n    this.callback = callback;\n    this.options = options;\n\n    this.id = null;\n    this.channel = null;\n\n    // format complete request from body & options\n    this.request = {\n      index,\n      collection,\n      body,\n      controller: 'realtime',\n      action: 'subscribe'\n    };\n    for (const opt of ['state', 'scope', 'users', 'volatile']) {\n      this.request[opt] = this.options[opt];\n      delete this.options[opt];\n    }\n\n    this.autoResubscribe = typeof options.autoResubscribe === 'boolean'\n      ? options.autoResubscribe\n      : kuzzle.autoResubscribe;\n    this.subscribeToSelf = typeof options.subscribeToSelf === 'boolean'\n      ? options.subscribeToSelf\n      : true;\n  }\n\n  subscribe () {\n    return this.kuzzle.query(this.request, this.options)\n      .then(response => {\n        this.id = response.roomId;\n        this.channel = response.channel;\n\n        // we rely on kuzzle event emitter to not duplicate the listeners here\n        this.kuzzle.network.on(this.channel, this._listenToChannelListener);\n\n        this.kuzzle.addListener('reconnected', this._reSubscribeListener);\n\n        return response;\n      });\n  }\n\n  removeListeners () {\n    this.kuzzle.removeListener('reconnected', this._reSubscribeListener);\n\n    if (this.channel) {\n      this.kuzzle.network.removeListener(this.channel, this._listenToChannelListener);\n    }\n  }\n\n  _listenToChannelListener (data) {\n    const fromSelf = data.volatile !== undefined && data.volatile.sdkInstanceId === this.kuzzle.network.id;\n    if (this.subscribeToSelf || !fromSelf) {\n      this.callback(data);\n    }\n  }\n\n  _reSubscribeListener () {\n    if (this.autoResubscribe) {\n      return this.subscribe();\n    }\n  }\n}\n\nmodule.exports = Room;\n","class ServerController {\n\n  /**\n   * @param {Kuzzle} kuzzle\n   */\n  constructor (kuzzle) {\n    this.kuzzle = kuzzle;\n  }\n\n  adminExists (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'adminExists'\n    }, options)\n      .then(result => result.exists);\n  }\n\n  getAllStats (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getAllStats'\n    }, options);\n  }\n\n  getConfig (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getConfig'\n    }, options);\n  }\n\n  getLastStats (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'getLastStats'\n    }, options);\n  }\n\n  info (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'info'\n    }, options);\n  }\n\n  now (options) {\n    return this.kuzzle.query({\n      controller: 'server',\n      action: 'now'\n    }, options);\n  }\n}\n\nmodule.exports = ServerController;\n","var\n  Role = require('./Role'),\n  Profile = require('./Profile'),\n  User = require('./User');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {Security}\n * @constructor\n */\nfunction Security(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['role', 'profile', 'user', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.fetchRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for fetchRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    cb(err, err ? undefined : new Role(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new Role(self, doc._id, doc._source, doc._meta);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Role(self, id, content, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new Role object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @param {object} meta - role metadata\n * @constructor\n */\nSecurity.prototype.role = function(id, content, meta) {\n  return new Role(this, id, content, meta);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('Security.fetchProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    cb(error, error ? undefined : new Profile(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new Profile(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, profiles: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {array} policies - list of policies to attach to the new profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = { policies: policies };\n  }\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new Profile(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {array} policies - the list of policies to apply to this profile\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateProfile = function (id, policies, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n\n  if (policies) {\n    data.body = {policies: policies};\n  }\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    var updatedContent = {};\n\n    if (err) {\n      return cb(err);\n    }\n\n    Object.keys(res.result._source).forEach(function (property) {\n      updatedContent[property] = res.result._source[property];\n    });\n\n    cb(null, new Profile(self, res.result._id, updatedContent, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollProfiles = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollProfiles: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollProfiles', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollProfiles'}, request, options, function (error, result) {\n    var profiles = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (profile) {\n      var newProfile = new Profile(self, profile._id, profile._source, profile._meta);\n\n      newProfile.version = profile._version;\n\n      profiles.push(newProfile);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      profiles: profiles,\n      scrollId: scrollId\n    });\n  });\n};\n\n/**\n * Instantiate a new Profile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @param {object} meta - profile metadata\n * @constructor\n */\nSecurity.prototype.profile = function(id, content, meta) {\n  return new Profile(this, id, content, meta);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nSecurity.prototype.fetchUser = function (id, options, cb) {\n  var\n    data = {_id: id},\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for fetchUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.fetchUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    cb(err, err ? undefined : new User(self, response.result._id, response.result._source, response.result._meta));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created wont be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Security.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var\n      documents,\n      scrollId = null;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new User(self, doc._id, doc._source, doc._meta);\n    });\n\n    if (response.result.scrollId) {\n      scrollId = response.result.scrollId;\n    }\n\n    cb(null, { total: response.result.total, users: documents, scrollId: scrollId });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(self.buildQueryArgs('createUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Replace an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profileIds` in `content` must only contain an array of profile ids\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.replaceUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.replaceUser: cannot replace a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('replaceUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n};\n\n/**\n * Create a new restricted user in Kuzzle.\n *\n * This function will create a new user. It is not usable to update an existing user.\n * This function allows anonymous users to create a \"restricted\" user with predefined rights.\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nSecurity.prototype.createRestrictedUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {_id: id, body: content};\n\n  if (content.profileIds) {\n    throw new Error('Security.createRestrictedUser: cannot provide profileIds');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.buildQueryArgs('createRestrictedUser'), data, null, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source));\n  });\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Security.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  self.kuzzle.query(this.buildQueryArgs(action), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : new User(self, res.result._id, res.result._source, res.result._meta));\n  });\n\n  return this;\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Security} this object\n */\nSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result._id);\n  });\n\n  return this;\n};\n\n/**\n * @param {string} scrollId\n * @param {object} [options]\n * @param {responseCallback} cb\n */\nSecurity.prototype.scrollUsers = function (scrollId, options, cb) {\n  var\n    request = {},\n    self = this;\n\n  if (!scrollId) {\n    throw new Error('Security.scrollUsers: scrollId is required');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  this.kuzzle.callbackRequired('Security.scrollUsers', cb);\n\n  request.scrollId = scrollId;\n\n  if (options && options.scroll) {\n    request.scroll = options.scroll;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'scrollUsers'}, request, options, function (error, result) {\n    var users = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (user) {\n      var newUser = new User(self, user._id, user._source, user._meta);\n\n      newUser.version = user._version;\n\n      users.push(newUser);\n    });\n\n    cb(null, {\n      total: result.result.total,\n      users: users,\n      scrollId: scrollId\n    });\n  });\n\n  return this;\n};\n\n/**\n * Instantiate a new User object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @param {object} meta - user metadata\n * @constructor\n */\nSecurity.prototype.user = function(id, content, meta) {\n  return new User(this, id, content, meta);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights\n    .filter(function (right) {\n      return right.controller === controller || right.controller === '*';\n    })\n    .filter(function (right) {\n      return right.action === action || right.action === '*';\n    })\n    .filter(function (right) {\n      return right.index === index || right.index === '*';\n    })\n    .filter(function (right) {\n      return right.collection === collection || right.collection === '*';\n    });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object|responseCallback} [options] - (optional) arguments\n * @param {function} cb The callback containing the normalized array of rights.\n */\nSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, cb && function (err, res) {\n    cb(err, err ? undefined : res.result.hits);\n  });\n};\n\n/**\n * Create credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.createCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'createCredentials'}, {_id: kuid, strategy: strategy, body: credentials}, options, function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result._source);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Delete credentials of the specified <strategy> for the user <kuid> .\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.deleteCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'deleteCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Retrieve a list of accepted fields per authentication strategy.\n *\n * @param options\n * @param cb\n */\nSecurity.prototype.getAllCredentialFields = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getAllCredentialFields'}, {}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Retrieve the list of accepted field names by the specified <strategy>.\n *\n * @param strategy\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentialFields = function (strategy, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentialFields'}, {strategy: strategy}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Get credential information of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.getCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'getCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Check the existence of the specified <strategy>s credentials for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param options\n * @param cb\n */\nSecurity.prototype.hasCredentials = function (strategy, kuid, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'hasCredentials'}, {strategy: strategy, _id: kuid}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\n/**\n * Updates credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n * @returns {Security}\n */\nSecurity.prototype.updateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'updateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n\n  return this;\n};\n\n/**\n * Validate credentials of the specified <strategy> for the user <kuid>.\n *\n * @param strategy\n * @param kuid\n * @param credentials\n * @param options\n * @param cb\n */\nSecurity.prototype.validateCredentials = function (strategy, kuid, credentials, options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query({controller: 'security', action: 'validateCredentials'}, {strategy: strategy, _id: kuid, body: credentials}, options, typeof cb !== 'function' ? null : function(err, res) {\n    if (!err) {\n      cb && cb(null, res.result);\n    } else {\n      cb && cb(err);\n    }\n  });\n};\n\nmodule.exports = Security;\n","var SecurityDocument = require('./SecurityDocument');\n\nfunction Role(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nRole.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Role\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Role} this object\n */\nRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.Security.buildQueryArgs('createOrReplaceRole'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return this;\n};\n\nmodule.exports = Role;\n","var SecurityDocument = require('./SecurityDocument');\n\nfunction Profile(Security, id, content, meta) {\n\n  SecurityDocument.call(this, Security, id, content, meta);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (Security.kuzzle.bluebird) {\n    return Security.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nProfile.prototype = Object.create(SecurityDocument.prototype, {\n  constructor: {\n    value: Profile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Profile} this\n */\nProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.Security.buildQueryArgs('createOrReplaceProfile'), data, options, cb && function (error) {\n    cb(error, error ? undefined : self);\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {Profile} this\n */\nProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {Profile} this\n */\nProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data.meta = this.meta;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = Profile;\n","// Parameter mutualization\nvar\n  getId = {getter: true, required: ['_id']},\n  getIdField = {getter: true, required: ['_id', 'field']},\n  getKeys = {getter: true, required: ['keys']},\n  getMember = {getter: true, required: ['_id', 'member']},\n  getxScan = {\n    getter: true, \n    required: ['_id', 'cursor'], \n    opts: ['match', 'count'],\n    mapResults: mapScanResults\n  },\n  getZrange = {\n    getter: true,\n    required: ['_id', 'start', 'stop'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  getZrangeBy = {\n    getter: true,\n    required: ['_id', 'min', 'max'],\n    opts: assignZrangeOptions,\n    mapResults: mapZrangeResults\n  },\n  setId = {required: ['_id']},\n  setIdValue = {required: ['_id', 'value']};\n\n// Redis commands\nvar\n  commands = {\n    append: setIdValue,\n    bitcount: {getter: true, required: ['_id'], opts: ['start', 'end']},\n    bitop: {required: ['_id', 'operation', 'keys']},\n    bitpos: {getter: true, required: ['_id', 'bit'], opts: ['start', 'end']},\n    dbsize: {getter: true},\n    decr: setId,\n    decrby: setIdValue,\n    del: {required: ['keys']},\n    exists: getKeys,\n    expire: {required: ['_id', 'seconds'], mapResults: Boolean},\n    expireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    flushdb: {mapResults: mapNoResult},\n    geoadd: {required: ['_id', 'points']},\n    geodist: {\n      getter: true,\n      required: ['_id', 'member1', 'member2'],\n      opts: ['unit'],\n      mapResults: parseFloat\n    },\n    geohash: {getter: true, required: ['_id', 'members']},\n    geopos: {getter: true, required: ['_id', 'members'], mapResults: mapGeoposResults},\n    georadius: {\n      getter: true,\n      required: ['_id', 'lon', 'lat', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    georadiusbymember: {\n      getter: true,\n      required: ['_id', 'member', 'distance', 'unit'],\n      opts: assignGeoRadiusOptions,\n      mapResults: mapGeoRadiusResults\n    },\n    get: getId,\n    getbit: {getter: true, required: ['_id', 'offset']},\n    getrange: {getter: true, required: ['_id', 'start', 'end']},\n    getset: setIdValue,\n    hdel: {required: ['_id', 'fields']},\n    hexists: {getter: true, required: ['_id', 'field'], mapResults: Boolean},\n    hget: getIdField,\n    hgetall: {getter: true, required: ['_id']},\n    hincrby: {required: ['_id', 'field', 'value']},\n    hincrbyfloat: {required: ['_id', 'field', 'value'], mapResults: parseFloat},\n    hkeys: getId,\n    hlen: getId,\n    hmget: {getter: true, required: ['_id', 'fields']},\n    hmset: {required: ['_id', 'entries'], mapResults: mapNoResult},\n    hscan: getxScan,\n    hset: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hsetnx: {required: ['_id', 'field', 'value'], mapResults: Boolean},\n    hstrlen: getIdField,\n    hvals: getId,\n    incr: setId,\n    incrby: setIdValue,\n    incrbyfloat: {required: ['_id', 'value'], mapResults: parseFloat},\n    keys: {getter: true, required: ['pattern']},\n    lindex: {getter: true, required: ['_id', 'idx']},\n    linsert: {required: ['_id', 'position', 'pivot', 'value']},\n    llen: getId,\n    lpop: setId,\n    lpush: {required: ['_id', 'values']},\n    lpushx: setIdValue,\n    lrange: {getter: true, required: ['_id', 'start', 'stop']},\n    lrem: {required: ['_id', 'count', 'value']},\n    lset: {required: ['_id', 'index', 'value'], mapResults: mapNoResult},\n    ltrim: {required: ['_id', 'start', 'stop'], mapResults: mapNoResult},\n    mget: getKeys,\n    mset: {required: ['entries'], mapResults: mapNoResult},\n    msetnx: {required: ['entries'], mapResults: Boolean},\n    object: {getter: true, required: ['_id', 'subcommand']},\n    persist: {required: ['_id'], mapResults: Boolean},\n    pexpire: {required: ['_id', 'milliseconds'], mapResults: Boolean},\n    pexpireat: {required: ['_id', 'timestamp'], mapResults: Boolean},\n    pfadd: {required: ['_id', 'elements'], mapResults: Boolean},\n    pfcount: getKeys,\n    pfmerge: {required: ['_id', 'sources'], mapResults: mapNoResult},\n    ping: {getter: true},\n    psetex: {required: ['_id', 'value', 'milliseconds'], mapResults: mapNoResult},\n    pttl: getId,\n    randomkey: {getter: true},\n    rename: {required: ['_id', 'newkey'], mapResults: mapNoResult},\n    renamenx: {required: ['_id', 'newkey'], mapResults: Boolean},\n    rpop: setId,\n    rpoplpush: {required: ['source', 'destination']},\n    rpush: {required: ['_id', 'values']},\n    rpushx: setIdValue,\n    sadd: {required: ['_id', 'members']},\n    scan: {getter: true, required: ['cursor'], opts: ['match', 'count'], mapResults: mapScanResults},\n    scard: getId,\n    sdiff: {getter: true, required: ['_id', 'keys']},\n    sdiffstore: {required: ['_id', 'keys', 'destination']},\n    set: {required: ['_id', 'value'], opts: ['ex', 'px', 'nx', 'xx'], mapResults: mapNoResult},\n    setex: {required: ['_id', 'value', 'seconds'], mapResults: mapNoResult},\n    setnx: {required: ['_id', 'value'], mapResults: Boolean},\n    sinter: getKeys,\n    sinterstore: {required: ['destination', 'keys']},\n    sismember: {getter: true, required: ['_id', 'member'], mapResults: Boolean},\n    smembers: getId,\n    smove: {required: ['_id', 'destination', 'member'], mapResults: Boolean},\n    sort: {getter: true, required: ['_id'], opts: ['alpha', 'by', 'direction', 'get', 'limit']},\n    spop: {required: ['_id'], opts: ['count'], mapResults: mapStringToArray },\n    srandmember: {getter: true, required: ['_id'], opts: ['count'], mapResults: mapStringToArray},\n    srem: {required: ['_id', 'members']},\n    sscan: getxScan,\n    strlen: getId,\n    sunion: getKeys,\n    sunionstore: {required: ['destination', 'keys']},\n    time: {getter: true, mapResults: mapArrayStringToArrayInt},\n    touch: {required: ['keys']},\n    ttl: getId,\n    type: getId,\n    zadd: {required: ['_id', 'elements'], opts: ['nx', 'xx', 'ch', 'incr']},\n    zcard: getId,\n    zcount: {getter: true, required: ['_id', 'min', 'max']},\n    zincrby: {required: ['_id', 'member', 'value']},\n    zinterstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']},\n    zlexcount: {getter: true, required: ['_id', 'min', 'max']},\n    zrange: getZrange,\n    zrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrevrangebylex: {getter: true, required: ['_id', 'min', 'max'], opts: ['limit']},\n    zrangebyscore: getZrangeBy,\n    zrank: getMember,\n    zrem: {required: ['_id', 'members']},\n    zremrangebylex: {required: ['_id', 'min', 'max']},\n    zremrangebyrank: {required: ['_id', 'start', 'stop']},\n    zremrangebyscore: {required: ['_id', 'min', 'max']},\n    zrevrange: getZrange,\n    zrevrangebyscore: getZrangeBy,\n    zrevrank: getMember,\n    zscan: getxScan,\n    zscore: {getter: true, required: ['_id', 'member'], mapResults: parseFloat},\n    zunionstore: {required: ['_id', 'keys'], opts: ['weights', 'aggregate']}\n  };\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), except functions falling in the following categories:\n *\n *  - blocking functions\n *  - cluster commands\n *  - configuration commands\n *  - cursor functions\n *  - database administration commands\n *  - debugging functions\n *  - script based functions\n *  - transaction functions\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction MemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = [];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n// Dynamically builds this class' prototypes using the \"commands\" global variable\n(function () {\n  Object.keys(commands).forEach(function (command) {\n    MemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (args.length && typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      commands[command].getter && this.kuzzle.callbackRequired('MemoryStorage.' + command, cb);\n\n      if (!commands[command].getter) {\n        data.body = {};\n      }\n\n      if (commands[command].required) {\n        commands[command].required.forEach(function (param) {\n          var value = args.shift();\n\n          if (value === undefined) {\n            throw new Error('MemoryStorage.' + command + ': Missing parameter \"' + param + '\"');\n          }\n\n          assignParameter(data, commands[command].getter, param, value);\n        });\n      }\n\n      if (args.length > 1) {\n        throw new Error('MemoryStorage.' + command + ': Too many parameters provided');\n      }\n\n      if (args.length === 1 && typeof args[0] !== 'object' || Array.isArray(args[0])) {\n        throw new Error('MemoryStorage.' + command + ': Invalid optional parameter (expected an object)');\n      }\n\n      if (args.length) {\n        options = Object.assign({}, args[0]);\n\n        if (Array.isArray(commands[command].opts)) {\n          commands[command].opts.forEach(function (opt) {\n            if (options[opt] !== null && options[opt] !== undefined) {\n              assignParameter(data, commands[command].getter, opt, options[opt]);\n              delete options[opt];\n            }\n          });\n        }\n      }\n\n      /*\n       Options function mapper does not necessarily need\n       options to be passed by clients.\n       */\n      if (typeof commands[command].opts === 'function') {\n        commands[command].opts(data, options || {});\n      }\n\n      this.kuzzle.query(query, data, options, cb && function (err, res) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (commands[command].mapResults) {\n          return cb(null, commands[command].mapResults(res.result));\n        }\n\n        cb(null, res.result);\n      });\n\n      if (!commands[command].getter) {\n        return this;\n      }\n    };\n  });\n})();\n\n/**\n *\n * @param {object} data - target data object\n * @param {boolean} getter - tells if the command is a getter one\n * @param {string} name - parameter name\n * @param {*} value - parameter value\n */\nfunction assignParameter(data, getter, name, value) {\n  if (getter || name === '_id') {\n    data[name] = value;\n  }\n  else {\n    data.body[name] = value;\n  }\n}\n\n/**\n * Assign the provided options for the georadius* redis functions\n * to the request object, as expected by Kuzzle API\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignGeoRadiusOptions(data, options) {\n  var parsed = [];\n\n  Object.keys(options)\n    .filter(function (opt) {\n      return options[opt] && ['withcoord', 'withdist', 'count', 'sort'].indexOf(opt) !== -1;\n    })\n    .forEach(function (opt) {\n      if (opt === 'withcoord' || opt === 'withdist') {\n        parsed.push(opt);\n        delete options[opt];\n      }\n      else if (opt === 'count' || opt === 'sort') {\n        if (opt === 'count') {\n          parsed.push('count');\n        }\n\n        parsed.push(options[opt]);\n      }\n\n      delete options[opt];\n    });\n\n  if (parsed.length > 0) {\n    data.options = parsed;\n  }\n}\n\n/**\n * Force the WITHSCORES option on z*range* routes\n *\n * Mutates the provided data and options objects\n *\n * @param {object} data\n * @param {object} options\n */\nfunction assignZrangeOptions(data, options) {\n  data.options = ['withscores'];\n\n  if (options.limit) {\n    data.limit = options.limit;\n    delete options.limit;\n  }\n}\n\n/**\n * Maps geopos results, from array<array<string>> to array<array<number>>\n *\n * @param {Array.<Array.<string>>} results\n * @return {Array.<Array.<Number>>}\n */\nfunction mapGeoposResults(results) {\n  return results.map(function (coords) {\n    return coords.map(function (latlon) {\n      return parseFloat(latlon);\n    });\n  });\n}\n\n\n/**\n * Maps georadius results to the format specified in the SDK documentation,\n * preventing different formats depending on the passed options\n *\n * Results can be either an array of point names, or an array\n * of arrays, each one of them containing the point name,\n * and additional informations depending on the passed options\n * (coordinates, distances)\n *\n * @param {Array} results\n * @return {Array.<Object>}\n */\nfunction mapGeoRadiusResults(results) {\n  // Simple array of point names (no options provided)\n  if (!Array.isArray(results[0])) {\n    return results.map(function (point) {\n      return {name: point};\n    });\n  }\n\n  return results.map(function (point) {\n    // The point id is always the first item\n    var p = {\n        name: point[0]\n      },\n      i;\n\n    for (i = 1; i < point.length; i++) {\n      // withcoord result are in an array...\n      if (Array.isArray(point[i])) {\n        p.coordinates = point[i].map(function (coord) {\n          return parseFloat(coord);\n        });\n      }\n      else {\n        // ... and withdist are not\n        p.distance = parseFloat(point[i]);\n      }\n    }\n\n    return p;\n  });\n}\n\n/**\n * Map a string result to an array of strings.\n * Used to uniformize polymorphic results from redis\n *\n * @param {Array|string} results\n * @return {Array.<string>}\n */\nfunction mapStringToArray(results) {\n  return Array.isArray(results) ? results : [results];\n}\n\n/**\n * Map an array of strings to an array of integers\n *\n * @param {Array.<string>} results\n * @return {Array.<Number>}\n */\nfunction mapArrayStringToArrayInt(results) {\n  return results.map(function (value) {\n    return parseInt(value);\n  });\n}\n\n/**\n * Disable results for routes like flushdb\n * @return {undefined}\n */\nfunction mapNoResult() {\n  return undefined;\n}\n\n/**\n * Map zrange results with WITHSCORES:\n * [\n *  \"member1\",\n *  \"score of member1\",\n *  \"member2\",\n *  \"score of member2\"\n * ]\n *\n * into the following format:\n * [\n *  {\"member\": \"member1\", \"score\": <score of member1>},\n *  {\"member\": \"member2\", \"score\": <score of member2>},\n * ]\n *\n *\n * @param {Array.<string>} results\n * @return {Array.<Object>}\n */\nfunction mapZrangeResults(results) {\n  var\n    buffer = null,\n    mapped = [];\n\n  results.forEach(function (value) {\n    if (buffer === null) {\n      buffer = value;\n    }\n    else {\n      mapped.push({member: buffer, score: parseFloat(value)});\n      buffer = null;\n    }\n  });\n\n  return mapped;\n}\n\n/**\n * Map *scan calls results, from:\n * [\n *   \"<cursor>\",\n *   [\n *     \"value1\",\n *     \"value2\", \n *     \"...\"\n *   ]\n * ]\n *\n * To:\n * {\n *   cursor: <cursor>,\n *   values: [\n *     \"value1\",\n *     \"value2\",\n *     \"...\"\n *   ]\n * }\n * \n * @param  {array.<string|array>} results \n * @return {object}\n */\nfunction mapScanResults(results) {\n  return {\n    cursor: results[0],\n    values: results[1]\n  };\n}\n\nmodule.exports = MemoryStorage;\n","/**\n *\n * @param protocol\n * @param host\n * @param options\n * @returns {Object} Instantiated WebSocket/Socket.IO object\n */\n\nfunction network(protocol, host, options) {\n  switch (protocol) {\n    case 'websocket':\n      if (typeof window !== 'undefined' && typeof WebSocket === 'undefined') {\n        throw new Error('Aborting: no websocket support detected.');\n      }\n      return new (require('./protocols/websocket'))(host, options);\n    case 'socketio':\n      if (!window.io) {\n        throw new Error('Aborting: no socket.io library loaded.');\n      }\n      return new (require('./protocols/socketio'))(host, options);\n    default:\n      throw new Error('Aborting: unknown protocol \"' + protocol + '\" (only \"websocket\" and \"socketio\" are available).');\n  }\n}\n\nmodule.exports = network;\n","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nlet WebSocketClient;\n\nclass WSNode extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    WebSocketClient = typeof WebSocket !== 'undefined' ? WebSocket : require('uws');\n    this.client = null;\n    this.lasturl = null;\n  }\n\n  /**\n   * Connect to the websocket server\n   */\n  connect () {\n    const\n      url = (this.ssl ? 'wss://' : 'ws://') + this.host + ':' + this.port,\n      opts = typeof window !== 'undefined' ? undefined : {perMessageDeflate: false};\n\n    super.connect();\n\n    if (url !== this.lasturl) {\n      this.wasConnected = false;\n      this.lasturl = url;\n    }\n\n    this.client = new WebSocketClient(url, opts);\n\n    this.client.onopen = () => {\n      this.clientConnected();\n    };\n\n    this.client.onclose = (closeEvent, message) => {\n      let\n        status,\n        reason = message;\n\n      if (typeof closeEvent === 'number') {\n        status = closeEvent;\n      }\n      else {\n        status = closeEvent.code;\n\n        if (closeEvent.reason) {\n          reason = closeEvent.reason;\n        }\n      }\n\n      if (status === 1000) {\n        this.clientDisconnected();\n      }\n      // do not forward a connection close error if no \n      // connection has been previously established\n      else if (this.wasConnected) {\n        const error = new Error(reason);\n        error.status = status;\n\n        this.clientNetworkError(error);\n      }\n    };\n\n    this.client.onerror = error => {\n      const err = (error instanceof Error) && error || new Error(error);\n\n      this.clientNetworkError(err);\n    };\n\n    this.client.onmessage = payload => {\n      const data = JSON.parse(payload.data || payload);\n\n      if (data.room) {\n        this.emit(data.room, data);\n      }\n      else {\n        this.emit('discarded', data);\n      }\n    };\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  }\n\n  /**\n   * Closes the connection\n   */\n  close () {\n    this.state = 'offline';\n    this.removeAllListeners();\n    this.wasConnected = false;\n    if (this.client) {\n      this.client.close();\n    }\n    this.client = null;\n    this.stopRetryingToConnect = true;\n  }\n}\n\nmodule.exports = WSNode;\n","'use strict';\n\nconst\n  RTWrapper = require('./abstract/realtime');\n\nclass SocketIO extends RTWrapper {\n\n  constructor(host, options) {\n    super(host, options);\n\n    this.socket = null;\n    this.forceDisconnect = false;\n    this.eventsWrapper = {};\n  }\n\n  /**\n   * Connect to the SocketIO server\n   */\n  connect() {\n    super.connect();\n\n    this.socket = window.io((this.ssl ? 'https://' : 'http://') + this.host + ':' + this.port, {\n      reconnection: this.autoReconnect,\n      reconnectionDelay: this.reconnectionDelay,\n      forceNew: true\n    });\n\n    this.socket.on('connect', () => this.clientConnected());\n    this.socket.on('connect_error', error => this.clientNetworkError(error));\n\n    this.socket.on('disconnect', () => {\n      if (this.forceDisconnect) {\n        this.clientDisconnected();\n      } else {\n        const error = new Error('An error occurred, kuzzle may not be ready yet');\n        error.status = 500;\n\n        this.clientNetworkError(error);\n      }\n\n      this.forceDisconnect = false;\n    });\n  }\n\n  /**\n   * Registers a callback on an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   * @param {boolean} once\n   */\n  addListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    super.addListener(event, callback, once);\n\n    return this;\n  }\n\n  prependListener(event, callback, once = false) {\n    this._addEventWrapper(event, callback, once);\n    return super.prependListener(event, callback, once);\n  }\n\n  /**\n   * Unregisters a callback from an event.\n   *\n   * @param {string} event\n   * @param {function} callback\n   */\n  removeListener(event, callback) {\n    if (this.eventsWrapper[event]) {\n      this.eventsWrapper[event].listeners.delete(callback);\n\n      if (this.eventsWrapper[event].listeners.size === 0) {\n        this.socket.off(event, this.eventsWrapper[event].wrapper);\n        delete this.eventsWrapper[event];\n      }\n\n      super.removeListener(event, callback);\n    }\n\n    return this;\n  }\n\n  /**\n   * Unregisters all listeners either from an event, or from all events\n   *\n   * @param {string} [event]\n   */\n  removeAllListeners(event) {\n    if (event !== undefined) {\n      if (this.eventsWrapper[event] !== undefined) {\n        for (const listener of this.eventsWrapper[event].listeners) {\n          this.removeListener(event, listener);\n        }\n      }\n    } else {\n      for (const _event of Object.keys(this.eventsWrapper)) {\n        this.removeAllListeners(_event);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  send(payload) {\n    this.socket.emit('kuzzle', payload);\n  }\n\n  /**\n   * Closes the connection\n   */\n  close() {\n    this.forceDisconnect = true;\n    this.state = 'offline';\n    this.socket.close();\n    this.socket = null;\n  }\n\n  _addEventWrapper(event, callback, once = false) {\n    if (!this.eventsWrapper[event]) {\n      const wrapper = (...args) => this.emit(event, ...args);\n\n      this.eventsWrapper[event] = {\n        wrapper,\n        listeners: new Set()\n      };\n\n      if (['connect', 'connect_error', 'disconnect'].indexOf(event) === -1) {\n        if (once) {\n          this.socket.once(event, wrapper);\n        } else {\n          this.socket.on(event, wrapper);\n        }\n      }\n    }\n\n    this.eventsWrapper[event].listeners.add(callback);\n  }\n}\n\nmodule.exports = SocketIO;\n"],"sourceRoot":""}