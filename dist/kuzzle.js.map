{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kuzzle.js","webpack:///webpack/bootstrap 800d06d171e852427e99","webpack:///./src/kuzzle.js","webpack:///./src/security/kuzzleSecurityDocument.js","webpack:///./src/security/kuzzleUser.js","webpack:///./~/node-uuid/uuid.js","webpack:///./src/kuzzleDataCollection.js","webpack:///./src/kuzzleDataMapping.js","webpack:///./src/kuzzleDocument.js","webpack:///./src/kuzzleMemoryStorage.js","webpack:///./src/kuzzleRoom.js","webpack:///./src/networkWrapper/index.js","webpack:///./src/networkWrapper/wrappers/socketio.js","webpack:///./src/networkWrapper/wrappers/wsbrowsers.js","webpack:///./src/security/kuzzleProfile.js","webpack:///./src/security/kuzzleRole.js","webpack:///./src/security/kuzzleSecurity.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","cleanQueue","self","now","Date","lastDocumentIndex","queueTTL","offlineQueue","forEach","query","index","ts","splice","droppedRequest","emitEvent","queueMaxSize","length","cleanHistory","requestHistory","Object","keys","key","setTimeout","emitRequest","request","cb","undefined","jwtToken","network","once","requestId","response","action","error","message","send","dequeue","additionalQueue","uniqueQueue","dequeuingProcess","shift","Math","max","replayInterval","queuing","offlineQueueLoader","Error","Array","isArray","concat","filter","controller","hasOwnProperty","renewAllSubscriptions","subscriptions","roomId","subscriptionId","subscription","renew","callback","uuid","KuzzleDataCollection","KuzzleSecurity","KuzzleMemoryStorage","KuzzleUser","networkWrapper","Kuzzle","host","options","defineProperties","collections","value","writable","connectCB","eventListeners","connected","lastEmitted","listeners","disconnected","reconnected","jwtTokenExpired","loginAttempt","offlineQueuePush","offlineQueuePop","eventTimeout","state","pending","autoReconnect","enumerable","defaultIndex","reconnectionDelay","wsPort","ioPort","autoQueue","autoReplay","autoResubscribe","headers","metadata","queueFilter","opt","getOwnPropertyDescriptor","offlineMode","defineProperty","header","errorMessagePrefix","event","args","prototype","slice","arguments","eventProperties","listener","process","nextTick","fn","apply","connect","bluebird","promisifyAll","suffix","name","func","target","passes","whitelist","indexOf","onConnect","onConnectError","connectionError","internal","onDisconnect","disconnect","onReconnect","reconnect","checkToken","err","res","valid","setJwtToken","token","success","result","jwt","JSON","stringify","getJwtToken","login","strategy","credentials","expiresIn","body","queuable","logout","v4","callbackRequired","whoAmI","security","_id","_source","getMyRights","hits","updateSelf","content","data","queryArgs","addListener","listenerId","knownEvents","listenerType","isValid","toString","push","getAllStatistics","getStatistics","timestamp","queryCB","startTime","dataCollectionFactory","collection","flushQueue","listCollections","collectionType","arg","type","listIndexes","indexes","close","getServerInfo","serverInfo","refreshIndex","getAutoRefresh","setAutoRefresh","autoRefresh","attr","object","meta","addHeaders","authorization","removeAllListeners","eventName","removeListener","replayQueue","setDefaultIndex","setHeaders","replace","startQueuing","stopQueuing","KuzzleSecurityDocument","kuzzleSecurity","kuzzle","setContent","serialize","buildQueryArgs","deleteActionName","update","updateActionName","create","constructor","setProfiles","profilesIds","addProfile","profileId","save","getProfiles","_window","setupBrowser","_crypto","crypto","msCrypto","_rng","getRandomValues","_rnds8","Uint8Array","_whatwgRNG","e","_rnds","_mathRNG","r","random","console","warn","setupNode","require","_rb","randomBytes","_nodeRNG","parse","s","buf","offset","ii","toLowerCase","oct","_hexToByte","unparse","bth","_byteToHex","v1","b","clockseq","_clockseq","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","node","_nodeId","n","BufferClass","rnds","rng","_previousRoot","Buffer","substr","_seedBytes","noConflict","window","blacklist","KuzzleDocument","KuzzleDataMapping","KuzzleRoom","advancedSearch","filters","documents","doc","newDocument","version","_version","total","count","createDocument","document","updateIfExist","deleteDocument","ids","fetchDocument","documentId","fetchAllDocuments","from","size","getMapping","kuzzleMapping","refresh","publishMessage","replaceDocument","subscribe","room","truncate","updateDocument","documentFactory","roomFactory","dataMappingFactory","mapping","kuzzleDataCollection","properties","mappings","set","field","dataCollection","publish","values","bind","keyVal","idOrKeys","commands","append","bgrewriteaof","bgsave","bitcount","bitop","bitpos","__opts__","blpop","brpoplpush","dbsize","decrby","del","discard","exec","exists","expire","expireat","flushdb","getbit","getrange","hdel","hexists","hincrby","hmset","hset","info","lastsave","lindex","linsert","lpush","lrange","lrem","lset","ltrim","mset","multi","pexpire","pexpireat","pfadd","pfmerge","ping","psetex","randomkey","rename","renamenx","restore","rpoplpush","sadd","sdiffstore","setbit","setex","setrange","sinterstore","sismember","smove","sort","spop","srem","sunionstore","unwatch","wait","zadd","zcount","zincrby","zinterstore","zlexcount","zrange","zrangebylex","zrangebyscore","zrem","zremrangebylex","zremrangebyscore","zrevrangebylex","zrevrangebyscore","zrevrank","decr","get","dump","hgetall","hkeys","hlen","hstrlen","hvals","incr","llen","lpop","persist","pttl","rpop","scard","smembers","strlen","ttl","zcard","getset","lpushx","mget","pfcount","sdiff","sinter","sunion","watch","incrby","incrbyfloat","brpop","hget","hmget","hsetnx","msetnx","rpush","hincrbyfloat","srandmember","zrevrange","zscore","command","pop","v","channel","lastRenewal","notifier","queue","renewalDelay","scope","subscribing","users","subscribeToSelf","notificationCallback","element","isReady","subscribeQuery","unsubscribe","on","interval","off","setInterval","clearInterval","WebSocket","io","code","SocketIO","port","socket","reconnection","forceNew","payload","emit","WSBrowsers","client","retrying","onopen","poke","onclose","onerror","onmessage","keep","findIndex","readyState","OPEN","KuzzleProfile","policies","addPolicy","policy","roleId","setPolicies","map","getPolicies","KuzzleRole","getRole","searchRoles","roles","createRole","replaceIfExist","updateRole","deleteRole","roleFactory","getProfile","searchProfiles","profiles","createProfile","updateProfile","updatedContent","property","deleteProfile","profileFactory","getUser","searchUsers","createUser","updateUser","deleteUser","userFactory","isActionAllowed","rights","filteredRights","right","some","item","getUserRights","userId"],"mappings":"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","file":"kuzzle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuid = __webpack_require__(3),\n\t  KuzzleDataCollection = __webpack_require__(4),\n\t  KuzzleSecurity = __webpack_require__(14),\n\t  KuzzleMemoryStorage = __webpack_require__(7),\n\t  KuzzleUser = __webpack_require__(2),\n\t  networkWrapper = __webpack_require__(9);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle object constructor.\n\t *\n\t * @constructor\n\t * @param host - Server name or IP Address to the Kuzzle instance\n\t * @param [options] - Connection options\n\t * @param {responseCallback} [cb] - Handles connection response\n\t * @constructor\n\t */\n\tmodule.exports = Kuzzle = function (host, options, cb) {\n\t  var self = this;\n\t\n\t  if (!(this instanceof Kuzzle)) {\n\t    return new Kuzzle(host, options, cb);\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!host || host === '') {\n\t    throw new Error('host argument missing');\n\t  }\n\t\n\t  Object.defineProperties(this, {\n\t    // 'private' properties\n\t    collections: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    connectCB: {\n\t      value: cb\n\t    },\n\t    eventListeners: {\n\t      value: {\n\t        connected: {lastEmitted: null, listeners: []},\n\t        error: {lastEmitted: null, listeners: []},\n\t        disconnected: {lastEmitted: null, listeners: []},\n\t        reconnected: {lastEmitted: null, listeners: []},\n\t        jwtTokenExpired: {lastEmitted: null, listeners: []},\n\t        loginAttempt: {lastEmitted: null, listeners: []},\n\t        offlineQueuePush: {listeners: []},\n\t        offlineQueuePop: {listeners: []}\n\t      }\n\t    },\n\t    eventTimeout: {\n\t      value: 200\n\t    },\n\t    queuing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    requestHistory: {\n\t      value: {},\n\t      writable: true\n\t    },\n\t    state: {\n\t      value: 'initializing',\n\t      writable: true\n\t    },\n\t    subscriptions: {\n\t      /*\n\t       Contains the centralized subscription list in the following format:\n\t          pending: <number of pending subscriptions>\n\t          'roomId': {\n\t            kuzzleRoomID_1: kuzzleRoomInstance_1,\n\t            kuzzleRoomID_2: kuzzleRoomInstance_2,\n\t            kuzzleRoomID_...: kuzzleRoomInstance_...\n\t          }\n\t\n\t       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n\t       This structure also allows renewing subscriptions after a connection loss\n\t       */\n\t      value: {\n\t        pending: {}\n\t      },\n\t      writable: true\n\t    },\n\t    // read-only properties\n\t    autoReconnect: {\n\t      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n\t      enumerable: true\n\t    },\n\t    defaultIndex: {\n\t      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    reconnectionDelay: {\n\t      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n\t      enumerable: true\n\t    },\n\t    host: {\n\t      value: host,\n\t      enumerable: true\n\t    },\n\t    wsPort: {\n\t      value: (options && typeof options.wsPort === 'number') ? options.wsPort : 7513,\n\t      enumerable: true\n\t    },\n\t    ioPort: {\n\t      value: (options && typeof options.ioPort === 'number') ? options.ioPort : 7512,\n\t      enumerable: true\n\t    },\n\t    autoQueue: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoReplay: {\n\t      value: false,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    autoResubscribe: {\n\t      value: true,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    metadata: {\n\t      value: {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    /*\n\t      Offline queue use the following format:\n\t            [\n\t              {\n\t                ts: <query timestamp>,\n\t                query: 'query',\n\t                cb: callbackFunction\n\t              }\n\t            ]\n\t     */\n\t    offlineQueue: {\n\t      value: [],\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueFilter: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueMaxSize: {\n\t      value: 500,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    queueTTL: {\n\t      value: 120000,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    replayInterval: {\n\t      value: 10,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    jwtToken: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    offlineQueueLoader: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (options) {\n\t    Object.keys(options).forEach(function (opt) {\n\t      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n\t        self[opt] = options[opt];\n\t      }\n\t    });\n\t\n\t    if (options.offlineMode === 'auto' && this.autoReconnect) {\n\t      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n\t    }\n\t  }\n\t\n\t  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n\t  Object.defineProperty(this, 'isValid', {\n\t    value: function () {\n\t      if (self.state === 'disconnected') {\n\t        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n\t      }\n\t    }\n\t  });\n\t\n\t  // Helper function copying headers to the query data\n\t  Object.defineProperty(this, 'addHeaders', {\n\t    value: function (query, headers) {\n\t      Object.keys(headers).forEach(function (header) {\n\t        if (!query[header]) {\n\t          query[header] = headers[header];\n\t        }\n\t      });\n\t\n\t      return query;\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n\t   * and is called by these methods\n\t   */\n\t  Object.defineProperty(this, 'callbackRequired', {\n\t    value: function (errorMessagePrefix, callback) {\n\t      if (!callback || typeof callback !== 'function') {\n\t        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n\t      }\n\t    }\n\t  });\n\t\n\t  /**\n\t   * Create an attribute security that embed all methods to manage Role, Profile and User\n\t   */\n\t  Object.defineProperty(this, 'security', {\n\t    value: new KuzzleSecurity(this),\n\t    enumerable: true\n\t  });\n\t\n\t  /**\n\t   * Emit an event to all registered listeners\n\t   * An event cannot be emitted multiple times before a timeout has been reached.\n\t   */\n\t  Object.defineProperty(this, 'emitEvent', {\n\t    value: function emitEvent(event) {\n\t      var\n\t        now = Date.now(),\n\t        args = Array.prototype.slice.call(arguments, 1),\n\t        eventProperties = this.eventListeners[event];\n\t\n\t      if (eventProperties.lastEmitted && eventProperties.lastEmitted >= now - this.eventTimeout) {\n\t        return false;\n\t      }\n\t\n\t      eventProperties.listeners.forEach(function (listener) {\n\t        process.nextTick(function () {\n\t          listener.fn.apply(undefined, args);\n\t        });\n\t      });\n\t\n\t      // Events without the 'lastEmitted' property can be emitted without minimum time between emissions\n\t      if (eventProperties.lastEmitted !== undefined) {\n\t        eventProperties.lastEmitted = now;\n\t      }\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'memoryStorage', {\n\t    value: new KuzzleMemoryStorage(this),\n\t    enumerable: true\n\t  });\n\t\n\t\n\t  if (!options || !options.connect || options.connect === 'auto') {\n\t    this.connect();\n\t  } else {\n\t    this.state = 'ready';\n\t  }\n\t\n\t  cleanHistory(this.requestHistory);\n\t\n\t  if (this.bluebird) {\n\t    return this.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n\t          'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n\t          'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n\t          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n\t        ];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t};\n\t\n\t/**\n\t * Connects to a Kuzzle instance using the provided host name.\n\t * @returns {Object} this\n\t */\n\tKuzzle.prototype.connect = function () {\n\t  var self = this;\n\t\n\t  if (!self.network) {\n\t    self.network = networkWrapper(self.host, self.wsPort, self.ioPort);\n\t  }\n\t\n\t  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t    return self;\n\t  }\n\t\n\t  self.state = 'connecting';\n\t  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\t\n\t  self.network.onConnect(function () {\n\t    self.state = 'connected';\n\t    renewAllSubscriptions.call(self);\n\t    dequeue.call(self);\n\t    self.emitEvent('connected');\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(null, self);\n\t    }\n\t  });\n\t\n\t  self.network.onConnectError(function (error) {\n\t    var connectionError = new Error('Unable to connect to kuzzle server at \"' + self.host + '\"');\n\t\n\t    connectionError.internal = error;\n\t    self.state = 'error';\n\t    self.emitEvent('error', connectionError);\n\t\n\t    if (self.connectCB) {\n\t      self.connectCB(connectionError);\n\t    }\n\t  });\n\t\n\t  self.network.onDisconnect(function () {\n\t    self.state = 'offline';\n\t\n\t    if (!self.autoReconnect) {\n\t      self.disconnect();\n\t    }\n\t\n\t    if (self.autoQueue) {\n\t      self.queuing = true;\n\t    }\n\t\n\t    self.emitEvent('disconnected');\n\t  });\n\t\n\t  self.network.onReconnect(function () {\n\t    var reconnect = function () {\n\t      // renew subscriptions\n\t      if (self.autoResubscribe) {\n\t        renewAllSubscriptions.call(self);\n\t      }\n\t\n\t      // replay queued requests\n\t      if (self.autoReplay) {\n\t        cleanQueue.call(self);\n\t        dequeue.call(self);\n\t      }\n\t\n\t      // alert listeners\n\t      self.emitEvent('reconnected');\n\t    };\n\t\n\t    self.state = 'connected';\n\t\n\t    if (self.jwtToken) {\n\t      self.checkToken(self.jwtToken, function (err, res) {\n\t        // shouldn't obtain an error but let's invalidate the token anyway\n\t        if (err || !res.valid) {\n\t          self.jwtToken = undefined;\n\t          self.emitEvent('jwtTokenExpired');\n\t        }\n\t\n\t        reconnect();\n\t      });\n\t    } else {\n\t      reconnect();\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set the jwtToken used to query kuzzle\n\t * @param token\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.setJwtToken = function(token) {\n\t  if (typeof token === 'string') {\n\t    this.jwtToken = token;\n\t  } else if (typeof token === 'object') {\n\t    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n\t      this.jwtToken = token.result.jwt;\n\t    } else {\n\t      this.emitEvent('loginAttempt', {\n\t        success: false,\n\t        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n\t      });\n\t\n\t      return this;\n\t    }\n\t  } else {\n\t    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n\t    return this;\n\t  }\n\t\n\t  renewAllSubscriptions.call(this);\n\t  this.emitEvent('loginAttempt', {success: true});\n\t  return this;\n\t};\n\t\n\t/**\n\t * Get the jwtToken used by kuzzle\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.getJwtToken = function() {\n\t  return this.jwtToken;\n\t};\n\t\n\t/**\n\t * Send login request to kuzzle with credentials\n\t * If login success, store the jwtToken into kuzzle object\n\t *\n\t * @param strategy\n\t * @param credentials\n\t * @param expiresIn\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.login = function (strategy) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      strategy: strategy\n\t    },\n\t    credentials,\n\t    cb;\n\t\n\t  // Handle arguments (credentials, expiresIn, cb)\n\t  if (arguments[1]) {\n\t    if (typeof arguments[1] === 'object') {\n\t      credentials = arguments[1];\n\t    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n\t      request.expiresIn = arguments[1];\n\t    } else if (typeof arguments[1] === 'function') {\n\t      cb = arguments[1];\n\t    }\n\t  }\n\t  if (arguments[2]) {\n\t    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n\t      request.expiresIn = arguments[2];\n\t    } else if (typeof arguments[2] === 'function') {\n\t      cb = arguments[2];\n\t    }\n\t  }\n\t  if (arguments[3] && typeof arguments[3] === 'function') {\n\t    cb = arguments[3];\n\t  }\n\t\n\t  if (typeof credentials === 'object') {\n\t    Object.keys(credentials).forEach(function (key) {\n\t      request[key] = credentials[key];\n\t    });\n\t  }\n\t\n\t  this.query({controller: 'auth', action: 'login'}, {body: request}, {queuable: false}, function(error, response) {\n\t    if (!error) {\n\t      if (response.result.jwt) {\n\t        self.setJwtToken(response.result.jwt);\n\t      }\n\t\n\t      if (cb && typeof cb === 'function') {\n\t        cb(null, response.result);\n\t      }\n\t    }\n\t    else {\n\t      if (cb && typeof cb === 'function') {\n\t        cb(error);\n\t      }\n\t\n\t      self.emitEvent('loginAttempt', {success: false, error: error.message});\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Send logout request to kuzzle with jwtToken.\n\t *\n\t * @param cb\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.logout = function (cb) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      action: 'logout',\n\t      controller: 'auth',\n\t      requestId: uuid.v4(),\n\t      body: {}\n\t    };\n\t\n\t  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, function(error) {\n\t    if (error === null) {\n\t      self.jwtToken = undefined;\n\t\n\t      if (typeof cb === 'function') {\n\t        cb(null, self);\n\t      }\n\t    }\n\t    else if (typeof cb === 'function') {\n\t      cb(error);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Checks whether a given jwt token still represents a valid session in Kuzzle.\n\t *\n\t * @param  {string}   token     The jwt token to check\n\t * @param  {function} callback  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t * @return {Kuzzle}             The Kuzzle instance to enable chaining.\n\t */\n\tKuzzle.prototype.checkToken = function (token, callback) {\n\t  var\n\t    self = this,\n\t    request = {\n\t      body: {\n\t        token: token\n\t      }\n\t    };\n\t\n\t  this.callbackRequired('Kuzzle.checkToken', callback);\n\t\n\t  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, response) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t\n\t    callback(null, response.result);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Fetches the current user.\n\t *\n\t * @param  {function} callback  The callback to be called when the response is\n\t *                              available. The signature is `function(error, response)`.\n\t * @return {Kuzzle}             The Kuzzle instance to enable chaining.\n\t */\n\tKuzzle.prototype.whoAmI = function (callback) {\n\t  var self = this;\n\t\n\t  self.callbackRequired('Kuzzle.whoAmI', callback);\n\t\n\t  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, response) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t\n\t    callback(null, new KuzzleUser(self.security, response.result._id, response.result._source));\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Gets the rights array of the currently logged user.\n\t *\n\t * @param  {function} cb The callback containing the normalized array of rights.\n\t */\n\tKuzzle.prototype.getMyRights = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.callbackRequired('Kuzzle.getMyRights', cb);\n\t\n\t  self.query({controller: 'auth', action:'getMyRights'}, {}, null, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.hits);\n\t  });\n\t};\n\t\n\t/**\n\t * Update current user in Kuzzle.\n\t *\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzle.prototype.updateSelf = function (content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data.body = content;\n\t\n\t  if (cb) {\n\t    self.query(queryArgs, data, options, function (err, res) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      cb(null, res.result);\n\t    });\n\t  } else {\n\t    self.query(queryArgs, data, options);\n\t  }\n\t};\n\t\n\t/**\n\t * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n\t */\n\tfunction cleanQueue () {\n\t  var\n\t    self = this,\n\t    now = Date.now(),\n\t    lastDocumentIndex = -1;\n\t\n\t  if (self.queueTTL > 0) {\n\t    self.offlineQueue.forEach(function (query, index) {\n\t      if (query.ts < now - self.queueTTL) {\n\t        lastDocumentIndex = index;\n\t      }\n\t    });\n\t\n\t    if (lastDocumentIndex !== -1) {\n\t      self.offlineQueue\n\t        .splice(0, lastDocumentIndex + 1)\n\t        .forEach(function (droppedRequest) {\n\t          self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t        });\n\t    }\n\t  }\n\t\n\t  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n\t    self.offlineQueue\n\t      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n\t      .forEach(function (droppedRequest) {\n\t        self.emitEvent('offlineQueuePop', droppedRequest.query);\n\t      });\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Clean history from requests made more than 10s ago\n\t */\n\tfunction cleanHistory (requestHistory) {\n\t  var\n\t    now = Date.now();\n\t\n\t  Object.keys(requestHistory).forEach(function (key) {\n\t    if (requestHistory[key] < now - 10000) {\n\t      delete requestHistory[key];\n\t    }\n\t  });\n\t\n\t  setTimeout(function () {\n\t    cleanHistory(requestHistory);\n\t  }, 1000);\n\t}\n\t\n\t/**\n\t * Emit a request to Kuzzle\n\t *\n\t * @param {object} request\n\t * @param {responseCallback} [cb]\n\t */\n\tfunction emitRequest (request, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (self.jwtToken !== undefined || cb) {\n\t    self.network.once(request.requestId, function (response) {\n\t      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n\t        self.jwtToken = undefined;\n\t        self.emitEvent('jwtTokenExpired', request, cb);\n\t      }\n\t\n\t      if (cb) {\n\t        cb(response.error, response);\n\t      }\n\t    });\n\t  }\n\t\n\t  this.network.send(request);\n\t\n\t  // Track requests made to allow KuzzleRoom.subscribeToSelf to work\n\t  self.requestHistory[request.requestId] = Date.now();\n\t}\n\t\n\t/**\n\t * Play all queued requests, in order.\n\t */\n\tfunction dequeue () {\n\t  var\n\t    self = this,\n\t    additionalQueue,\n\t    uniqueQueue = {},\n\t    dequeuingProcess = function () {\n\t      if (self.offlineQueue.length > 0) {\n\t        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n\t        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\t\n\t        setTimeout(function () {\n\t          dequeuingProcess();\n\t        }, Math.max(0, self.replayInterval));\n\t      } else {\n\t        self.queuing = false;\n\t      }\n\t    };\n\t\n\t  if (self.offlineQueueLoader) {\n\t    if (typeof self.offlineQueueLoader !== 'function') {\n\t      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n\t    }\n\t\n\t    additionalQueue = self.offlineQueueLoader();\n\t    if (Array.isArray(additionalQueue)) {\n\t      self.offlineQueue = additionalQueue\n\t        .concat(self.offlineQueue)\n\t        .filter(function (request) {\n\t          // throws if the query object does not contain required attributes\n\t          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n\t            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n\t          }\n\t\n\t          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n\t        });\n\t    } else {\n\t      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n\t    }\n\t  }\n\t\n\t  dequeuingProcess();\n\t}\n\t\n\t/**\n\t * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n\t * successful login attempt\n\t */\n\tfunction renewAllSubscriptions() {\n\t  var self = this;\n\t\n\t  Object.keys(self.subscriptions).forEach(function (roomId) {\n\t    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n\t      var subscription = self.subscriptions[roomId][subscriptionId];\n\t      subscription.renew(subscription.callback);\n\t    });\n\t  });\n\t}\n\t\n\t/**\n\t * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n\t * insertion.\n\t *\n\t * The ID returned by this function is required to remove this listener at a later time.\n\t *\n\t * @param {string} event - name of the global event to subscribe to (see the 'eventListeners' object property)\n\t * @param {function} listener - callback to invoke each time an event is fired\n\t * @returns {string} Unique listener ID\n\t */\n\tKuzzle.prototype.addListener = function(event, listener) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    listenerType = typeof listener,\n\t    listenerId;\n\t\n\t  this.isValid();\n\t\n\t  if (knownEvents.indexOf(event) === -1) {\n\t    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t  }\n\t\n\t  if (listenerType !== 'function') {\n\t    throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n\t  }\n\t\n\t  listenerId = uuid.v4();\n\t  this.eventListeners[event].listeners.push({id: listenerId, fn: listener});\n\t  return listenerId;\n\t};\n\t\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method returns all available statistics from Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.getAllStatistics = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\t\n\t  this.query({controller:'admin', action: 'getAllStats'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.hits);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n\t * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n\t *\n\t * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n\t  var queryCB;\n\t\n\t  if (!cb) {\n\t    if (arguments.length === 1) {\n\t      cb = arguments[0];\n\t      options = null;\n\t      timestamp = null;\n\t    } else {\n\t      cb = arguments[1];\n\t      if (typeof arguments[0] === 'object') {\n\t        options = arguments[0];\n\t        timestamp = null;\n\t      } else {\n\t        timestamp = arguments[0];\n\t        options = null;\n\t      }\n\t    }\n\t  }\n\t\n\t  queryCB = function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    if (timestamp) {\n\t      cb(null, res.result.hits);\n\t    } else {\n\t      cb(null, [res.result]);\n\t    }\n\t  };\n\t\n\t  this.callbackRequired('Kuzzle.getStatistics', cb);\n\t\n\t  if (!timestamp) {\n\t    this.query({controller: 'admin', action: 'getLastStats'}, {}, options, queryCB);\n\t  } else {\n\t    this.query({controller: 'admin', action: 'getStats'}, { body: { startTime: timestamp } }, options, queryCB);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new instance of a KuzzleDataCollection object.\n\t * If no index is specified, takes the default index.\n\t *\n\t * @param {string} collection - The name of the data collection you want to manipulate\n\t * @param {string} [index] - The name of the data index containing the data collection\n\t * @returns {object} A KuzzleDataCollection instance\n\t */\n\tKuzzle.prototype.dataCollectionFactory = function(collection, index) {\n\t  this.isValid();\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Unable to create a new data collection object: no index specified');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (typeof index !== 'string') {\n\t    throw new Error('Invalid \"index\" argument: string expected, got ' + typeof index);\n\t  }\n\t\n\t  if (typeof collection !== 'string') {\n\t    throw new Error('Invalid \"collection\" argument: string expected, got ' + typeof collection);\n\t  }\n\t\n\t  if (!this.collections[index]) {\n\t    this.collections[index] = {};\n\t  }\n\t\n\t  if (!this.collections[index][collection]) {\n\t    this.collections[index][collection] = new KuzzleDataCollection(this, index, collection);\n\t  }\n\t\n\t  return this.collections[index][collection];\n\t};\n\t\n\t/**\n\t * Empties the offline queue without replaying it.\n\t *\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.flushQueue = function () {\n\t  this.offlineQueue = [];\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns the list of known persisted data collections.\n\t *\n\t * @param {string} [index] - Index containing collections to be listed\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.listCollections = function () {\n\t  var\n\t    collectionType = 'all',\n\t    index,\n\t    options,\n\t    cb,\n\t    args = Array.prototype.slice.call(arguments);\n\t\n\t  args.forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.listCollections: index required');\n\t    }\n\t\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listCollections', cb);\n\t\n\t  if (options && options.type) {\n\t    collectionType = options.type;\n\t  }\n\t\n\t  this.query({index: index, controller: 'read', action: 'listCollections'}, {body: {type: collectionType}}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    return cb(null, res.result.collections);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns the list of existing indexes in Kuzzle\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.listIndexes = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.listIndexes', cb);\n\t\n\t  this.query({controller: 'read', action: 'listIndexes'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    return cb(null, res.result.indexes);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Disconnects from Kuzzle and invalidate this instance.\n\t */\n\tKuzzle.prototype.disconnect = function () {\n\t  var collection;\n\t\n\t  this.logout();\n\t\n\t  this.state = 'disconnected';\n\t  this.network.close();\n\t\n\t  for (collection in this.collections) {\n\t    if (this.collections.hasOwnProperty(collection)) {\n\t      delete this.collections[collection];\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Returns the server informations\n\t *\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.getServerInfo = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\t\n\t  this.query({controller: 'read', action: 'serverInfo'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.serverInfo);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Forces an index refresh\n\t *\n\t * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Kuzzle}\n\t */\n\tKuzzle.prototype.refreshIndex = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function(arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.refreshIndex: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.query({ index: index, controller: 'admin', action: 'refreshIndex'}, {}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns de current autoRefresh status for the given index\n\t *\n\t * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n\t * @param {object} options - Optinal arguments\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.getAutoRefresh = function () {\n\t  var\n\t    index,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.getAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n\t  this.query({ index: index, controller: 'admin', action: 'getAutoRefresh'}, {}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * (Un)Sets the autoRefresh flag on the given index\n\t *\n\t * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n\t * @param {boolean} autoRefresh - The autoRefresh value to set\n\t * @param {object} options - Optional arguments\n\t * @param {responseCallback} cb - Handles the query result\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.setAutoRefresh = function () {\n\t  var\n\t    index,\n\t    autoRefresh,\n\t    options,\n\t    cb;\n\t\n\t  Array.prototype.slice.call(arguments).forEach(function (arg) {\n\t    switch (typeof arg) {\n\t      case 'string':\n\t        index = arg;\n\t        break;\n\t      case 'boolean':\n\t        autoRefresh = arg;\n\t        break;\n\t      case 'object':\n\t        options = arg;\n\t        break;\n\t      case 'function':\n\t        cb = arg;\n\t        break;\n\t    }\n\t  });\n\t\n\t  if (!index) {\n\t    if (!this.defaultIndex) {\n\t      throw new Error('Kuzzle.setAutoRefresh: index required');\n\t    }\n\t    index = this.defaultIndex;\n\t  }\n\t\n\t  if (autoRefresh === undefined) {\n\t    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n\t  }\n\t\n\t  this.query({ index: index, controller: 'admin', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return the current Kuzzle's UTC Epoch time, in milliseconds\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {object} this\n\t */\n\tKuzzle.prototype.now = function (options, cb) {\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.callbackRequired('Kuzzle.now', cb);\n\t\n\t  this.query({controller: 'read', action: 'now'}, {}, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.now);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n\t * Base method used to send read queries to Kuzzle\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} queryArgs - Query configuration\n\t * @param {object} query - The query data\n\t * @param {object} [options] - Optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n\t  var\n\t    attr,\n\t    object = {\n\t      action: queryArgs.action,\n\t      controller: queryArgs.controller,\n\t      metadata: this.metadata\n\t    },\n\t    self = this;\n\t\n\t  this.isValid();\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (options) {\n\t    if (options.metadata) {\n\t      Object.keys(options.metadata).forEach(function (meta) {\n\t        object.metadata[meta] = options.metadata[meta];\n\t      });\n\t    }\n\t\n\t    if (options.queuable === false && self.state === 'offline') {\n\t      return self;\n\t    }\n\t  }\n\t\n\t  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n\t    throw new Error('Invalid query parameter: ' + query);\n\t  }\n\t\n\t  if (query.metadata) {\n\t    Object.keys(query.metadata).forEach(function (meta) {\n\t      object.metadata[meta] = query.metadata[meta];\n\t    });\n\t  }\n\t\n\t  for (attr in query) {\n\t    if (attr !== 'metadata' && query.hasOwnProperty(attr)) {\n\t      object[attr] = query[attr];\n\t    }\n\t  }\n\t\n\t  object = self.addHeaders(object, this.headers);\n\t\n\t  /*\n\t   * Do not add the token for the checkToken route, to avoid getting a token error when\n\t   * a developer simply wish to verify his token\n\t   */\n\t  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n\t    object.headers = object.headers || {};\n\t    object.headers.authorization = 'Bearer ' + self.jwtToken;\n\t  }\n\t\n\t  if (queryArgs.collection) {\n\t    object.collection = queryArgs.collection;\n\t  }\n\t\n\t  if (queryArgs.index) {\n\t    object.index = queryArgs.index;\n\t  }\n\t\n\t  if (!object.requestId) {\n\t    object.requestId = uuid.v4();\n\t  }\n\t\n\t  if (self.state === 'connected' || (options && options.queuable === false)) {\n\t    if (self.state === 'connected') {\n\t      emitRequest.call(this, object, cb);\n\t    } else if (cb) {\n\t      cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n\t    }\n\t  } else if (self.queuing || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n\t    cleanQueue.call(this, object, cb);\n\t\n\t    if (!self.queueFilter || self.queueFilter(object)) {\n\t      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n\t      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n\t    }\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Removes all listeners, either from a specific event or from all events\n\t *\n\t * @param {string} event - One of the event described in the Event Handling section of this documentation\n\t */\n\tKuzzle.prototype.removeAllListeners = function (event) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    self = this;\n\t\n\t  if (event) {\n\t    if (knownEvents.indexOf(event) === -1) {\n\t      throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t    }\n\t\n\t    this.eventListeners[event].listeners = [];\n\t  } else {\n\t    knownEvents.forEach(function (eventName) {\n\t      self.eventListeners[eventName].listeners = [];\n\t    });\n\t  }\n\t};\n\t\n\t/**\n\t * Removes a listener from an event.\n\t *\n\t * @param {string} event - One of the event described in the Event Handling section of this documentation\n\t * @param {string} listenerId - The ID returned by addListener\n\t */\n\tKuzzle.prototype.removeListener = function (event, listenerId) {\n\t  var\n\t    knownEvents = Object.keys(this.eventListeners),\n\t    self = this;\n\t\n\t  if (knownEvents.indexOf(event) === -1) {\n\t    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n\t  }\n\t\n\t  this.eventListeners[event].listeners.forEach(function (listener, index) {\n\t    if (listener.id === listenerId) {\n\t      self.eventListeners[event].listeners.splice(index, 1);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Replays the requests queued during offline mode.\n\t * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n\t */\n\tKuzzle.prototype.replayQueue = function () {\n\t  if (this.state !== 'offline' && !this.autoReplay) {\n\t    cleanQueue.call(this);\n\t    dequeue.call(this);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Sets the default Kuzzle index\n\t *\n\t * @param index\n\t * @returns this\n\t */\n\tKuzzle.prototype.setDefaultIndex = function (index) {\n\t  if (typeof index !== 'string') {\n\t    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n\t  }\n\t\n\t  if (index.length === 0) {\n\t    throw new Error('Cannot set an empty index as the default index');\n\t  }\n\t\n\t  this.defaultIndex = index;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzle.prototype.setHeaders = function (content, replace) {\n\t  var self = this;\n\t\n\t  if (typeof content !== 'object' || Array.isArray(content)) {\n\t    throw new Error('Expected a content object, received a ' + typeof content);\n\t  }\n\t\n\t  if (replace) {\n\t    self.headers = content;\n\t  } else {\n\t    Object.keys(content).forEach(function (key) {\n\t      self.headers[key] = content[key];\n\t    });\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.startQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = true;\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n\t */\n\tKuzzle.prototype.stopQueuing = function () {\n\t  if (this.state === 'offline' && !this.autoQueue) {\n\t    this.queuing = false;\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tfunction KuzzleSecurityDocument(kuzzleSecurity, id, content) {\n\t\n\t  if (!id) {\n\t    throw new Error('A security document must have an id');\n\t  }\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    kuzzle: {\n\t      value: kuzzleSecurity.kuzzle\n\t    },\n\t    kuzzleSecurity: {\n\t      value: kuzzleSecurity\n\t    },\n\t    // read-only properties\n\t    // writable properties\n\t    id: {\n\t      value: id,\n\t      enumerable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    }\n\t  });\n\t\n\t  if (content) {\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'update'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {Object} data - New securityDocument content\n\t * @return {Object} this\n\t */\n\tKuzzleSecurityDocument.prototype.setContent = function (data) {\n\t  this.content = data;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a pojo\n\t *\n\t * @return {object} pojo representing this securityDocument\n\t */\n\tKuzzleSecurityDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Delete the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleSecurityDocument.prototype.delete = function (options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, res.result._id);\n\t    }\n\t  });\n\t};\n\t\n\t/**\n\t * Update the current KuzzleSecurityDocument into Kuzzle.\n\t *\n\t * @param {object} content - Content to add to KuzzleSecurityDocument\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleSecurityDocument.prototype.update = function (content, options, cb) {\n\t  var\n\t    data = {},\n\t    self = this;\n\t\n\t  if (typeof content !== 'object') {\n\t    throw new Error('Parameter \"content\" must be a object');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = self.id;\n\t  data.body = content;\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.setContent(response.result._source);\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t};\n\t\n\tmodule.exports = KuzzleSecurityDocument;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\tfunction KuzzleUser(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteUser'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateUser'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\tKuzzleUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleUser\n\t  }\n\t});\n\t\n\t/**\n\t * Set profiles in content\n\t * @param {array} profile - an array of profiles ids string\n\t *\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.setProfiles = function (profilesIds) {\n\t  if (!Array.isArray(profilesIds) || typeof profilesIds[0] !== 'string') {\n\t    throw new Error('Parameter \"profilesIds\" must be an array of strings');\n\t  }\n\t\n\t  this.content.profilesIds = profilesIds;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add a profile\n\t * @param {string} profile - a profile ids string\n\t *\n\t * @returns {KuzzleUser} this\n\t */\n\tKuzzleUser.prototype.addProfile = function (profileId) {\n\t  if (typeof profileId !== 'string') {\n\t    throw new Error('Parameter \"profileId\" must be a string');\n\t  }\n\t\n\t  if (!this.content.profilesIds) {\n\t    this.content.profilesIds = [];\n\t  }\n\t\n\t  if (this.content.profilesIds.indexOf(profileId) === -1) {\n\t    this.content.profilesIds.push(profileId);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Saves this user into Kuzzle.\n\t *\n\t * If this is a new user, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this user in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tKuzzleUser.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceUser'), data, options, function (error) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this User\n\t */\n\tKuzzleUser.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Return the associated profiles IDs\n\t *\n\t * @return {array} the associated profiles IDs\n\t */\n\tKuzzleUser.prototype.getProfiles = function () {\n\t  return this.content.profilesIds;\n\t};\n\t\n\tmodule.exports = KuzzleUser;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t//     uuid.js\n\t//\n\t//     Copyright (c) 2010-2012 Robert Kieffer\n\t//     MIT License - http://opensource.org/licenses/mit-license.php\n\t\n\t/*global window, require, define */\n\t(function(_window) {\n\t  'use strict';\n\t\n\t  // Unique ID creation requires a high quality random # generator.  We feature\n\t  // detect to determine the best RNG source, normalizing to a function that\n\t  // returns 128-bits of randomness, since that's what's usually required\n\t  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;\n\t\n\t  function setupBrowser() {\n\t    // Allow for MSIE11 msCrypto\n\t    var _crypto = _window.crypto || _window.msCrypto;\n\t\n\t    if (!_rng && _crypto && _crypto.getRandomValues) {\n\t      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n\t      //\n\t      // Moderately fast, high quality\n\t      try {\n\t        var _rnds8 = new Uint8Array(16);\n\t        _whatwgRNG = _rng = function whatwgRNG() {\n\t          _crypto.getRandomValues(_rnds8);\n\t          return _rnds8;\n\t        };\n\t        _rng();\n\t      } catch(e) {}\n\t    }\n\t\n\t    if (!_rng) {\n\t      // Math.random()-based (RNG)\n\t      //\n\t      // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t      // quality.\n\t      var  _rnds = new Array(16);\n\t      _mathRNG = _rng = function() {\n\t        for (var i = 0, r; i < 16; i++) {\n\t          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }\n\t          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t        }\n\t\n\t        return _rnds;\n\t      };\n\t      if ('undefined' !== typeof console && console.warn) {\n\t        console.warn(\"[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()\");\n\t      }\n\t    }\n\t  }\n\t\n\t  function setupNode() {\n\t    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n\t    //\n\t    // Moderately fast, high quality\n\t    if ('function' === typeof require) {\n\t      try {\n\t        var _rb = require('crypto').randomBytes;\n\t        _nodeRNG = _rng = _rb && function() {return _rb(16);};\n\t        _rng();\n\t      } catch(e) {}\n\t    }\n\t  }\n\t\n\t  if (_window) {\n\t    setupBrowser();\n\t  } else {\n\t    setupNode();\n\t  }\n\t\n\t  // Buffer class to use\n\t  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;\n\t\n\t  // Maps for number <-> hex string conversion\n\t  var _byteToHex = [];\n\t  var _hexToByte = {};\n\t  for (var i = 0; i < 256; i++) {\n\t    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t    _hexToByte[_byteToHex[i]] = i;\n\t  }\n\t\n\t  // **`parse()` - Parse a UUID into it's component bytes**\n\t  function parse(s, buf, offset) {\n\t    var i = (buf && offset) || 0, ii = 0;\n\t\n\t    buf = buf || [];\n\t    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n\t      if (ii < 16) { // Don't overflow!\n\t        buf[i + ii++] = _hexToByte[oct];\n\t      }\n\t    });\n\t\n\t    // Zero out remaining bytes if string was short\n\t    while (ii < 16) {\n\t      buf[i + ii++] = 0;\n\t    }\n\t\n\t    return buf;\n\t  }\n\t\n\t  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n\t  function unparse(buf, offset) {\n\t    var i = offset || 0, bth = _byteToHex;\n\t    return  bth[buf[i++]] + bth[buf[i++]] +\n\t            bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t            bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t            bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t            bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t            bth[buf[i++]] + bth[buf[i++]] +\n\t            bth[buf[i++]] + bth[buf[i++]] +\n\t            bth[buf[i++]] + bth[buf[i++]];\n\t  }\n\t\n\t  // **`v1()` - Generate time-based UUID**\n\t  //\n\t  // Inspired by https://github.com/LiosK/UUID.js\n\t  // and http://docs.python.org/library/uuid.html\n\t\n\t  // random #'s we need to init node and clockseq\n\t  var _seedBytes = _rng();\n\t\n\t  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\t  var _nodeId = [\n\t    _seedBytes[0] | 0x01,\n\t    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n\t  ];\n\t\n\t  // Per 4.2.2, randomize (14 bit) clockseq\n\t  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\t\n\t  // Previous uuid creation time\n\t  var _lastMSecs = 0, _lastNSecs = 0;\n\t\n\t  // See https://github.com/broofa/node-uuid for API details\n\t  function v1(options, buf, offset) {\n\t    var i = buf && offset || 0;\n\t    var b = buf || [];\n\t\n\t    options = options || {};\n\t\n\t    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;\n\t\n\t    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();\n\t\n\t    // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t    // cycle to simulate higher resolution clock\n\t    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;\n\t\n\t    // Time since last uuid creation (in msecs)\n\t    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\t\n\t    // Per 4.2.1.2, Bump clockseq on clock regression\n\t    if (dt < 0 && options.clockseq == null) {\n\t      clockseq = clockseq + 1 & 0x3fff;\n\t    }\n\t\n\t    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t    // time interval\n\t    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n\t      nsecs = 0;\n\t    }\n\t\n\t    // Per 4.2.1.2 Throw error if too many uuids are requested\n\t    if (nsecs >= 10000) {\n\t      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t    }\n\t\n\t    _lastMSecs = msecs;\n\t    _lastNSecs = nsecs;\n\t    _clockseq = clockseq;\n\t\n\t    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t    msecs += 12219292800000;\n\t\n\t    // `time_low`\n\t    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t    b[i++] = tl >>> 24 & 0xff;\n\t    b[i++] = tl >>> 16 & 0xff;\n\t    b[i++] = tl >>> 8 & 0xff;\n\t    b[i++] = tl & 0xff;\n\t\n\t    // `time_mid`\n\t    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t    b[i++] = tmh >>> 8 & 0xff;\n\t    b[i++] = tmh & 0xff;\n\t\n\t    // `time_high_and_version`\n\t    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t    b[i++] = tmh >>> 16 & 0xff;\n\t\n\t    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t    b[i++] = clockseq >>> 8 | 0x80;\n\t\n\t    // `clock_seq_low`\n\t    b[i++] = clockseq & 0xff;\n\t\n\t    // `node`\n\t    var node = options.node || _nodeId;\n\t    for (var n = 0; n < 6; n++) {\n\t      b[i + n] = node[n];\n\t    }\n\t\n\t    return buf ? buf : unparse(b);\n\t  }\n\t\n\t  // **`v4()` - Generate random UUID**\n\t\n\t  // See https://github.com/broofa/node-uuid for API details\n\t  function v4(options, buf, offset) {\n\t    // Deprecated - 'format' argument, as supported in v1.2\n\t    var i = buf && offset || 0;\n\t\n\t    if (typeof(options) === 'string') {\n\t      buf = (options === 'binary') ? new BufferClass(16) : null;\n\t      options = null;\n\t    }\n\t    options = options || {};\n\t\n\t    var rnds = options.random || (options.rng || _rng)();\n\t\n\t    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t    // Copy bytes to buffer, if provided\n\t    if (buf) {\n\t      for (var ii = 0; ii < 16; ii++) {\n\t        buf[i + ii] = rnds[ii];\n\t      }\n\t    }\n\t\n\t    return buf || unparse(rnds);\n\t  }\n\t\n\t  // Export public API\n\t  var uuid = v4;\n\t  uuid.v1 = v1;\n\t  uuid.v4 = v4;\n\t  uuid.parse = parse;\n\t  uuid.unparse = unparse;\n\t  uuid.BufferClass = BufferClass;\n\t  uuid._rng = _rng;\n\t  uuid._mathRNG = _mathRNG;\n\t  uuid._nodeRNG = _nodeRNG;\n\t  uuid._whatwgRNG = _whatwgRNG;\n\t\n\t  if (('undefined' !== typeof module) && module.exports) {\n\t    // Publish as node.js module\n\t    module.exports = uuid;\n\t  } else if (typeof define === 'function' && define.amd) {\n\t    // Publish as AMD module\n\t    define(function() {return uuid;});\n\t\n\t\n\t  } else {\n\t    // Publish as global (in browsers)\n\t    _previousRoot = _window.uuid;\n\t\n\t    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n\t    uuid.noConflict = function() {\n\t      _window.uuid = _previousRoot;\n\t      return uuid;\n\t    };\n\t\n\t    _window.uuid = uuid;\n\t  }\n\t})('undefined' !== typeof window ? window : null);\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleDocument = __webpack_require__(6),\n\t  KuzzleDataMapping = __webpack_require__(5),\n\t  KuzzleRoom = __webpack_require__(8);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n\t * or like a room for pub/sub messages.\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @param {string} index - Index containing the data collection\n\t * @param {string} collection - name of the data collection to handle\n\t * @constructor\n\t */\n\tfunction KuzzleDataCollection(kuzzle, index, collection) {\n\t  if (!index || !collection) {\n\t    throw new Error('The KuzzleDataCollection object constructor needs an index and a collection arguments');\n\t  }\n\t\n\t\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: collection,\n\t      enumerable: true\n\t    },\n\t    index: {\n\t      value: index,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (controller, action) {\n\t      return {\n\t        controller: controller,\n\t        action: action,\n\t        collection: this.collection,\n\t        index: this.index\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Executes an advanced search on the data collection.\n\t *\n\t * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function.\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.advancedSearch = function (filters, options, cb) {\n\t  var\n\t    query,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleDataCollection.advancedSearch', cb);\n\t\n\t  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('read', 'search'), query, options, function (error, result) {\n\t    var documents = [];\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    result.result.hits.forEach(function (doc) {\n\t      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\t\n\t      newDocument.version = doc._version;\n\t\n\t      documents.push(newDocument);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, documents: documents });\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Returns the number of documents matching the provided set of filters.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * @param {object} filters - Filters in Elasticsearch Query DSL format\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.count = function (filters, options, cb) {\n\t  var\n\t    query;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.count', cb);\n\t\n\t  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('read', 'count'), query, options, function (error, result) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    cb(null, result.result.count);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new empty data collection, with no associated mapping.\n\t * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n\t * want to create and prepare data collections before storing documents in it.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.create = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('write', 'createCollection'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Create a new document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *    - updateIfExist (boolean, default: false):\n\t *        If the same document already exists: throw an error if sets to false.\n\t *        Update the existing document otherwise\n\t *\n\t * @param {string} [id] - (optional) document identifier\n\t * @param {object} document - either an instance of a KuzzleDocument object, or a document\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.createDocument = function (id, document, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'create';\n\t\n\t  if (id && typeof id !== 'string') {\n\t    cb = options;\n\t    options = document;\n\t    document = id;\n\t    id = null;\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (document instanceof KuzzleDocument) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  if (options) {\n\t    action = options.updateIfExist ? 'createOrReplace' : 'create';\n\t  }\n\t\n\t  if (id) {\n\t    data._id = id;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, self.headers);\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs('write', action), data, options, function (err, res) {\n\t      var doc;\n\t\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      doc = new KuzzleDocument(self, res.result._id, res.result._source);\n\t      doc.version = res.result._version;\n\t      cb(null, doc);\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs('write', action), data, options);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Delete persistent documents.\n\t *\n\t * There is a small delay between documents creation and their existence in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a document that was just been created wont be returned by this function\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.deleteDocument = function (arg, options, cb) {\n\t  var\n\t    action,\n\t    data = {};\n\t\n\t  if (typeof arg === 'string') {\n\t    data._id = arg;\n\t    action = 'delete';\n\t  } else {\n\t    data.body = arg;\n\t    action = 'deleteByQuery';\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  if (cb) {\n\t    this.kuzzle.query(this.buildQueryArgs('write', action), data, options, function (err, res) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      if (action === 'delete') {\n\t        cb(null, [res.result._id]);\n\t      } else {\n\t        cb(null, res.result.ids);\n\t      }\n\t    });\n\t  } else {\n\t    this.kuzzle.query(this.buildQueryArgs('write', action), data, options);\n\t  }\n\t};\n\t\n\t/**\n\t * Retrieve a single stored document using its unique document ID.\n\t *\n\t * @param {string} documentId - Unique document identifier\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.fetchDocument = function (documentId, options, cb) {\n\t  var\n\t    data = {_id: documentId},\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleDataCollection.fetch', cb);\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('read', 'get'), data, options, function (err, res) {\n\t    var document;\n\t\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    document = new KuzzleDocument(self, res.result._id, res.result._source);\n\t    document.version = res.result._version;\n\t    cb(null, document);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Retrieves all documents stored in this data collection\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleDataCollection.prototype.fetchAllDocuments = function (options, cb) {\n\t  var filters = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  // copying pagination options to the search filter\n\t  if (options) {\n\t    if (options.from) {\n\t      filters.from = options.from;\n\t    }\n\t\n\t    if (options.size) {\n\t      filters.size = options.size;\n\t    }\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.fetchAll', cb);\n\t\n\t  this.advancedSearch(filters, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Instantiates a KuzzleDataMapping object containing the current mapping of this collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} cb - Returns an instantiated KuzzleDataMapping object\n\t * @return {object} this\n\t */\n\tKuzzleDataCollection.prototype.getMapping = function (options, cb) {\n\t  var kuzzleMapping;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.getMapping', cb);\n\t\n\t  kuzzleMapping = new KuzzleDataMapping(this);\n\t  kuzzleMapping.refresh(options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Publish a realtime message\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} document - either a KuzzleDocument instance or a JSON object\n\t * @param {object} [options] - optional arguments\n\t * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.publishMessage = function (document, options, cb) {\n\t  var data = {};\n\t\n\t  if (document instanceof KuzzleDocument) {\n\t    data = document.serialize();\n\t  } else {\n\t    data.body = document;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('write', 'publish'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replace an existing document with a new one.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to replace\n\t * @param {object} content - JSON object representing the new document version\n\t * @param {object} [options] - additional arguments\n\t * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n\t * @return {object} this\n\t */\n\tKuzzleDataCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    };\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs('write', 'createOrReplace'), data, options, function (err, res) {\n\t      var document;\n\t\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      document = new KuzzleDocument(self, res.result._id, res.result._source);\n\t      document.version = res.result._version;\n\t      cb(null, document);\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs('write', 'createOrReplace'), data, options);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Subscribes to this data collection with a set of filters.\n\t * To subscribe to the entire data collection, simply provide an empty filter.\n\t *\n\t * @param {object} filters - Filters in Kuzzle DSL format\n\t * @param {object} [options] - subscriptions options\n\t * @param {responseCallback} cb - called for each new notification\n\t * @returns {*} KuzzleRoom object\n\t */\n\tKuzzleDataCollection.prototype.subscribe = function (filters, options, cb) {\n\t  var room;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDataCollection.subscribe', cb);\n\t\n\t  room = new KuzzleRoom(this, options);\n\t\n\t  return room.renew(filters, cb);\n\t};\n\t\n\t/**\n\t * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n\t * This method is a lot faster than removing all documents using a query.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t * @returns {*} this\n\t */\n\tKuzzleDataCollection.prototype.truncate = function (options, cb) {\n\t  var data = {};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t  this.kuzzle.query(this.buildQueryArgs('admin', 'truncateCollection'), data, options, cb);\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Update parts of a document\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {string} documentId - Unique document identifier of the document to update\n\t * @param {object} content - JSON object containing changes to perform on the document\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n\t * @return {object} this\n\t */\n\tKuzzleDataCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n\t  var\n\t    data = {\n\t      _id: documentId,\n\t      body: content\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = self.kuzzle.addHeaders(data, this.headers);\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs('write', 'update'), data, options, function (err, res) {\n\t      var doc;\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      doc = new KuzzleDocument(self, res.result._id);\n\t      doc.refresh(cb);\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs('write', 'update'), data, options);\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Instantiate a new KuzzleDocument object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - document id\n\t * @param {object} content - document content\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.documentFactory = function (id, content) {\n\t  return new KuzzleDocument(this, id, content);\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleRoom object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [options] - subscription configuration\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.roomFactory = function (options) {\n\t  return new KuzzleRoom(this, options);\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleDataMapping object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {object} [mapping] - mapping to instantiate the KuzzleDataMapping object with\n\t * @constructor\n\t */\n\tKuzzleDataCollection.prototype.dataMappingFactory = function (mapping) {\n\t  return new KuzzleDataMapping(this, mapping);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDataCollection.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleDataCollection;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n\t *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n\t *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n\t *  the amount of data you stored in a collection and the complexity of your database.\n\t *\n\t *  The KuzzleDataMapping object allow to get the current mapping of a data collection and to modify it if needed.\n\t *\n\t * @param {object} kuzzleDataCollection - Instance of the inherited KuzzleDataCollection object\n\t * @param {object} mapping - mappings\n\t * @constructor\n\t */\n\tfunction KuzzleDataMapping(kuzzleDataCollection, mapping) {\n\t  Object.defineProperties(this, {\n\t    //read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    mapping: {\n\t      value: mapping || {},\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['set', 'setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Applies the new mapping to the data collection.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleDataMapping.prototype.apply = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.collection.buildQueryArgs('admin', 'updateMapping'), data, options, function (err) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    self.refresh(options, cb);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with the mapping stored in Kuzzle\n\t *\n\t * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDataMapping.prototype.refresh = function (options, cb) {\n\t  var\n\t    self = this,\n\t    data = this.kuzzle.addHeaders({}, this.headers);\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('admin', 'getMapping'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb ? cb(err) : false;\n\t    }\n\t\n\t    if (res.result[self.collection.index]) {\n\t      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n\t        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\t\n\t        // Mappings can be empty. The mapping property should never be \"undefined\"\n\t        if (self.mapping === undefined) {\n\t          self.mapping = {};\n\t        }\n\t      } else {\n\t        return cb ? cb(new Error('No mapping found for collection ' + self.collection.collection)) : false;\n\t      }\n\t    } else {\n\t      return cb ? cb(new Error('No mapping found for index ' + self.collection.index)) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t\n\t/**\n\t * Adds or updates a field mapping.\n\t *\n\t * Changes made by this function wont be applied until you call the apply method\n\t *\n\t * @param {string} field - Name of the field from which the mapping is to be added or updated\n\t * @param {object} mapping - corresponding field mapping\n\t * @returns {KuzzleDataMapping}\n\t */\n\tKuzzleDataMapping.prototype.set = function (field, mapping) {\n\t  this.mapping[field] = mapping;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDataMapping.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\tmodule.exports = KuzzleDataMapping;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * Kuzzle handles documents either as realtime messages or as stored documents.\n\t * KuzzleDocument is the object representation of one of these documents.\n\t *\n\t * Notes:\n\t *   - this constructor may be called either with a documentId, a content, neither or both.\n\t *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n\t *\n\t *\n\t * @param {object} kuzzleDataCollection - an instanciated KuzzleDataCollection object\n\t * @param {string} [documentId] - ID of an existing document\n\t * @param {object} [content] - Initializes this document with the provided content\n\t * @constructor\n\t */\n\tfunction KuzzleDocument(kuzzleDataCollection, documentId, content) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection.collection,\n\t      enumerable: true\n\t    },\n\t    dataCollection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    id: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    content: {\n\t      value: {},\n\t      writable: true,\n\t      enumerable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    version: {\n\t      value: undefined,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  // handling provided arguments\n\t  if (!content && documentId && typeof documentId === 'object') {\n\t    content = documentId;\n\t    documentId = null;\n\t  }\n\t\n\t  if (content) {\n\t    if (content._version) {\n\t      this.version = content._version;\n\t      delete content._version;\n\t    }\n\t    this.setContent(content, true);\n\t  }\n\t\n\t  if (documentId) {\n\t    Object.defineProperty(this, 'id', {\n\t      value: documentId,\n\t      enumerable: true\n\t    });\n\t  }\n\t\n\t  // promisifying\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['delete', 'refresh', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this document\n\t */\n\tKuzzleDocument.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t  data._version = this.version;\n\t  data = this.kuzzle.addHeaders(data, this.headers);\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Overrides the toString() method in order to return a serialized version of the document\n\t *\n\t * @return {string} serialized version of this object\n\t */\n\tKuzzleDocument.prototype.toString = function () {\n\t  return JSON.stringify(this.serialize());\n\t};\n\t\n\t/**\n\t * Deletes this document in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.delete = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('KuzzleDocument.delete: cannot delete a document without a document ID');\n\t  }\n\t\n\t  if (cb) {\n\t    this.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'delete'), this.serialize(), options, function (err) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      cb(null, self.id);\n\t    });\n\t  } else {\n\t    this.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'delete'), this.serialize(), options);\n\t  }\n\t};\n\t\n\t/**\n\t * Replaces the current content with the last version of this document stored in Kuzzle.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.refresh = function (options, cb) {\n\t  var self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!self.id) {\n\t    throw new Error('KuzzleDocument.refresh: cannot retrieve a document if no ID has been provided');\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDocument.refresh', cb);\n\t\n\t  self.kuzzle.query(self.dataCollection.buildQueryArgs('read', 'get'), {_id: self.id}, options, function (error, res) {\n\t    var newDocument;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    newDocument = new KuzzleDocument(self.dataCollection, self.id, res.result._source);\n\t    newDocument.version = res.result._version;\n\t\n\t    cb(null, newDocument);\n\t  });\n\t};\n\t\n\t/**\n\t * Saves this document into Kuzzle.\n\t *\n\t * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n\t * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'createOrReplace'), data, options, function (error, res) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    self.id = res.result._id;\n\t    self.version = res.result._version;\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Sends the content of this document as a realtime message.\n\t *\n\t * Takes an optional argument object with the following properties:\n\t *    - metadata (object, default: null):\n\t *        Additional information passed to notifications to other users\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @returns {*} this\n\t */\n\tKuzzleDocument.prototype.publish = function (options) {\n\t  var data = this.serialize();\n\t\n\t  this.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'publish'), data, options);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Replaces the current content with new data.\n\t * Changes made by this function wont be applied until the save method is called.\n\t *\n\t * @param {object} data - New content\n\t * @param {boolean} replace - if true: replace this document content with the provided data\n\t */\n\tKuzzleDocument.prototype.setContent = function (data, replace) {\n\t  var self = this;\n\t\n\t  if (replace) {\n\t    this.content = data;\n\t  }\n\t  else {\n\t    Object.keys(data).forEach(function (key) {\n\t      self.content[key] = data[key];\n\t    });\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Listens to events concerning this document. Has no effect if the document does not have an ID\n\t * (i.e. if the document has not yet been created as a persisted document).\n\t *\n\t * @param {object} [options] - subscription options\n\t * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n\t */\n\tKuzzleDocument.prototype.subscribe = function (options, cb) {\n\t  var filters;\n\t\n\t  if (options && !cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  this.kuzzle.callbackRequired('KuzzleDocument.subscribe', cb);\n\t\n\t  if (!this.id) {\n\t    throw new Error('KuzzleDocument.subscribe: cannot subscribe to a document if no ID has been provided');\n\t  }\n\t\n\t  filters = { ids: { values: [this.id] } };\n\t\n\t  return this.dataCollection.subscribe(filters, options, cb);\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleDocument.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t\n\tmodule.exports = KuzzleDocument;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t\n\t/**\n\t * Kuzzle's memory storage is a separate data store from the database layer.\n\t * It is internaly based on Redis. You can access most of Redis functions (all\n\t * lowercased), excepting:\n\t *   * all cluster based functions\n\t *   * all script based functions\n\t *   * all cursors functions\n\t *\n\t * For instance:\n\t *     kuzzle.memoryStorage\n\t *      .set('myKey', 'myValue')\n\t *      .get('myKey', function (err, response) {\n\t *        console.log(response.result);\n\t *\n\t *        // { _id: 'foo', body: { value: 'myValue' }}\n\t *      });\n\t *\n\t *\n\t * @param {object} kuzzle - Kuzzle instance to inherit from\n\t * @constructor\n\t */\n\tfunction KuzzleMemoryStorage(kuzzle) {\n\t  Object.defineProperties(this, {\n\t    // read-only properties\n\t    kuzzle: {\n\t      value: kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  this.setHeaders = kuzzle.setHeaders.bind(this);\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['setHeaders'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * constructs the memoryStorage functions.\n\t */\n\t(function() {\n\t\n\t  var\n\t    keyVal = ['id', 'value'],\n\t    idOrKeys = ['id', 'keys'],\n\t    commands = {\n\t      append: keyVal,\n\t      bgrewriteaof: [],\n\t      bgsave: [],\n\t      bitcount: ['id', 'start', 'end'],\n\t      bitop: ['operation', 'destkey', idOrKeys],\n\t      bitpos: ['id', 'bit', { __opts__: ['start', 'end']}],\n\t      blpop: [idOrKeys, 'timeout'],\n\t      brpoplpush: ['source', 'destination'],\n\t      dbsize: [],\n\t      decrby: keyVal,\n\t      del: [idOrKeys],\n\t      discard: [],\n\t      exec: [],\n\t      exists: [idOrKeys],\n\t      expire: ['id', 'seconds'],\n\t      expireat: ['id', 'timestamp'],\n\t      flushdb: [],\n\t      // @todo: implement geolocation methods once available in Redis stable release\n\t      getbit: ['id', 'offset'],\n\t      getrange: ['id', 'start', 'end'],\n\t      hdel: ['id', ['field', 'fields']],\n\t      hexists: ['id', 'field'],\n\t      hincrby: ['id', 'field', 'value'],\n\t      hmset: ['id', 'values'],\n\t      hset: ['id', 'field', 'value'],\n\t      info: ['section'],\n\t      keys: [ 'pattern' ],\n\t      lastsave: [],\n\t      lindex: ['id', 'idx'],\n\t      linsert: ['id', 'position', 'pivot', 'value'],\n\t      lpush: ['id', ['value', 'values']],\n\t      lrange: ['id', 'start', 'stop'],\n\t      lrem: ['id', 'count', 'value'],\n\t      lset: ['id', 'idx', 'value'],\n\t      ltrim: ['id', 'start', 'stop'],\n\t      mset: ['values'],\n\t      multi: [],\n\t      object: ['subcommand', 'args'],\n\t      pexpire: ['id', 'milliseconds'],\n\t      pexpireat: ['id', 'timestamp'],\n\t      pfadd: ['id', ['element', 'elements']],\n\t      pfmerge: ['destkey', ['sourcekey', 'sourcekeys']],\n\t      ping: [],\n\t      psetex: ['id', 'milliseconds', 'value'],\n\t      publish: ['channel', 'message'],\n\t      randomkey: [],\n\t      rename: ['id', 'newkey'],\n\t      renamenx: ['id', 'newkey'],\n\t      restore: ['id', 'ttl', 'content'],\n\t      rpoplpush: ['source', 'destination'],\n\t      sadd: ['id', ['member', 'members']],\n\t      save: [],\n\t      set: ['id', 'value', {__opts__:['ex', 'px', 'nx', 'xx']}],\n\t      sdiffstore: ['destination', idOrKeys],\n\t      setbit: ['id', 'offset', 'value'],\n\t      setex: ['id', 'seconds', 'value'],\n\t      setrange: ['id', 'offset', 'value'],\n\t      sinterstore: ['destination', idOrKeys],\n\t      sismember: ['id', 'member'],\n\t      smove: ['id', 'destination', 'member'],\n\t      sort: ['id', {__opts__:['by', 'offset', 'count', 'get', 'direction', 'alpha', 'store']}],\n\t      spop: ['id', 'count'],\n\t      srem: ['id', ['member', 'members']],\n\t      sunionstore: ['destination', idOrKeys],\n\t      unwatch: [],\n\t      wait: ['numslaves', 'timeout'],\n\t      zadd: ['id', {__opts__: ['nx', 'xx', 'ch', 'incr', 'score', 'member', 'members']}],\n\t      zcount: ['id', 'min', 'max'],\n\t      zincrby: ['id', 'value', 'member'],\n\t      zinterstore: ['destination', idOrKeys, {__opts__: ['weight', 'weights', 'aggregate']}],\n\t      zlexcount: ['id', 'min', 'max'],\n\t      zrange: ['id', 'start', 'stop', {__opts__: ['withscores']}],\n\t      zrangebylex: ['id', 'min', 'max', {__opts__: ['offset', 'count']}],\n\t      zrangebyscore: ['id', 'min', 'max', {__opts__: ['withscores', 'offset', 'count']}],\n\t      zrem: ['id', 'member'],\n\t      zremrangebylex: ['id', 'min', 'max'],\n\t      zremrangebyscore: ['id', 'min', 'max'],\n\t      zrevrangebylex: ['id', 'max', 'min', {__opts__: ['offset', 'count']}],\n\t      zrevrangebyscore: ['id', 'max', 'min', {__opts__: ['withscores', 'offset', 'count']}],\n\t      zrevrank: ['id', 'member']\n\t    };\n\t\n\t  // unique argument key\n\t  commands.decr = commands.get = commands.dump = commands.hgetall = commands.hkeys = commands.hlen = commands.hstrlen = commands.hvals = commands.incr = commands.llen = commands.lpop = commands.persist = commands.pttl = commands.rpop = commands.scard = commands.smembers = commands.strlen = commands.ttl = commands.type = commands.zcard = ['id'];\n\t\n\t  // key value\n\t  commands.getset = commands.lpushx = keyVal;\n\t\n\t  // key key...\n\t  commands.del = commands.exists = commands.mget = commands.pfcount = commands.sdiff = commands.sinter = commands.sunion = commands.watch = [idOrKeys];\n\t\n\t  commands.incrby = commands.incrbyfloat = commands.decrby;\n\t  commands.brpop = commands.blpop;\n\t  commands.hget = commands.hexists;\n\t  commands.hmget = commands.hdel;\n\t  commands.hsetnx = commands.hset;\n\t  commands.msetnx = commands.mset;\n\t  commands.rpush = commands.lpush;\n\t  commands.hincrbyfloat = commands.hincrby;\n\t  commands.srandmember = commands.spop;\n\t  commands.zrevrange = commands.zrange;\n\t  commands.zscore = commands.zrevrank;\n\t\n\t  Object.keys(commands).forEach(function (command) {\n\t    KuzzleMemoryStorage.prototype[command] = function () {\n\t      var\n\t        args = Array.prototype.slice.call(arguments),\n\t        options = null,\n\t        cb,\n\t        query = {\n\t          controller: 'ms',\n\t          action: command\n\t        },\n\t        data = {};\n\t\n\t      if (typeof args[args.length - 1] === 'function') {\n\t        cb = args.pop();\n\t      }\n\t\n\t      if (args.length && typeof args[args.length - 1] === 'object' && Object.keys(args[args.length - 1]).length === 1 && args[args.length - 1].queuable !== undefined) {\n\t        options = args.pop();\n\t      }\n\t\n\t      commands[command].forEach(function (v, i) {\n\t        if (args[i] === undefined) {\n\t          return;\n\t        }\n\t\n\t        if (Array.isArray(v)) {\n\t          v = Array.isArray(args[i]) ? v[1] : v[0];\n\t        }\n\t\n\t        if (v === 'id') {\n\t          data._id = args[i];\n\t        }\n\t        else {\n\t          if (!data.body) {\n\t            data.body = {};\n\t          }\n\t\n\t          if (typeof v === 'object' && v.__opts__ !== undefined) {\n\t            v.__opts__.forEach(function (arg) {\n\t              if (args[i][arg] !== undefined) {\n\t                data.body[arg] = args[i][arg];\n\t              }\n\t            });\n\t          }\n\t          else {\n\t            data.body[v] = args[i];\n\t          }\n\t        }\n\t      });\n\t\n\t      this.kuzzle.query(query, data, options, cb);\n\t\n\t      return this;\n\t\n\t    };\n\t  });\n\t\n\t})();\n\t\n\tmodule.exports = KuzzleMemoryStorage;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  uuid = __webpack_require__(3);\n\t\n\t/**\n\t * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n\t *\n\t * @callback responseCallback\n\t * @param {Object} err - Error object, NULL if the query is successful\n\t * @param {Object} [data] - The content of the query response\n\t */\n\t\n\t/**\n\t * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n\t *\n\t * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n\t *\n\t * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n\t * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n\t * document change (because it is created, updated or deleted), then youll receive a notification about it.\n\t *\n\t * @param {object} kuzzleDataCollection - an instantiated and valid kuzzle object\n\t * @param {object} [options] - subscription optional configuration\n\t * @constructor\n\t */\n\tfunction KuzzleRoom(kuzzleDataCollection, options) {\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    callback: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    channel: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    id: {\n\t      value: uuid.v4()\n\t    },\n\t    lastRenewal: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    notifier: {\n\t      value: null,\n\t      writable: true\n\t    },\n\t    queue: {\n\t      value: [],\n\t      writable: true\n\t    },\n\t    // Delay before allowing a subscription renewal\n\t    renewalDelay: {\n\t      value: 500\n\t    },\n\t    scope: {\n\t      value: options && options.scope ? options.scope : 'all'\n\t    },\n\t    state: {\n\t      value: options && options.state ? options.state : 'done'\n\t    },\n\t    subscribing: {\n\t      value: false,\n\t      writable: true\n\t    },\n\t    users: {\n\t      value: options && options.users ? options.users : 'none'\n\t    },\n\t    // read-only properties\n\t    collection: {\n\t      value: kuzzleDataCollection,\n\t      enumerable: true\n\t    },\n\t    kuzzle: {\n\t      value: kuzzleDataCollection.kuzzle,\n\t      enumerable: true\n\t    },\n\t    // writable properties\n\t    filters: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    headers: {\n\t      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    metadata: {\n\t      value: (options && options.metadata) ? options.metadata : {},\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    roomId: {\n\t      value: null,\n\t      enumerable: true,\n\t      writable: true\n\t    },\n\t    subscribeToSelf: {\n\t      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n\t      enumerable: true,\n\t      writable: true\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['count'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t/**\n\t * Returns the number of other subscriptions on that room.\n\t *\n\t * @param {responseCallback} cb - Handles the query response\n\t */\n\tKuzzleRoom.prototype.count = function (cb) {\n\t  var data;\n\t\n\t  this.kuzzle.callbackRequired('KuzzleRoom.count', cb);\n\t\n\t  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\t\n\t  if (!isReady.call(this)) {\n\t    this.queue.push({action: 'count', args: [cb]});\n\t    return this;\n\t  }\n\t\n\t  if (!this.roomId) {\n\t    throw new Error('KuzzleRoom.count: cannot count subscriptions on an inactive room');\n\t  }\n\t\n\t  this.kuzzle.query(this.collection.buildQueryArgs('subscribe', 'count'), data, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.count);\n\t  });\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Renew the subscription using new filters\n\t *\n\t * @param {object} [filters] - Filters in Kuzzle DSL format\n\t * @param {responseCallback} cb - called for each new notification\n\t */\n\tKuzzleRoom.prototype.renew = function (filters, cb) {\n\t  var\n\t    now = Date.now(),\n\t    subscribeQuery = {\n\t      scope: this.scope,\n\t      state: this.state,\n\t      users: this.users\n\t    },\n\t    self = this;\n\t\n\t  if (!cb && filters && typeof filters === 'function') {\n\t    cb = filters;\n\t    filters = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleRoom.renew', cb);\n\t\n\t  /*\n\t    Skip subscription renewal if another one was performed a moment before\n\t   */\n\t  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n\t    return self;\n\t  }\n\t\n\t  if (filters) {\n\t    self.filters = filters;\n\t  }\n\t\n\t  /*\n\t   if not yet connected, register itself to the subscriptions list and wait for the\n\t   main Kuzzle object to renew once online\n\t    */\n\t  if (self.kuzzle.state !== 'connected') {\n\t    self.callback = cb;\n\t    self.kuzzle.subscriptions.pending[self.id] = self;\n\t    return self;\n\t  }\n\t\n\t  if (self.subscribing) {\n\t    self.queue.push({action: 'renew', args: [filters, cb]});\n\t    return self;\n\t  }\n\t\n\t  self.unsubscribe();\n\t  self.roomId = null;\n\t  self.subscribing = true;\n\t  self.callback = cb;\n\t  self.kuzzle.subscriptions.pending[self.id] = self;\n\t\n\t  subscribeQuery.body = self.filters;\n\t  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, this.headers);\n\t\n\t  self.kuzzle.query(self.collection.buildQueryArgs('subscribe', 'on'), subscribeQuery, {metadata: self.metadata}, function (error, response) {\n\t    delete self.kuzzle.subscriptions.pending[self.id];\n\t    self.subscribing = false;\n\t\n\t    if (error) {\n\t      self.queue = [];\n\t      throw new Error('Error during Kuzzle subscription: ' + error.message);\n\t    }\n\t\n\t    self.lastRenewal = now;\n\t    self.roomId = response.result.roomId;\n\t    self.channel = response.result.channel;\n\t\n\t    if (!self.kuzzle.subscriptions[self.roomId]) {\n\t      self.kuzzle.subscriptions[self.roomId] = {};\n\t    }\n\t\n\t    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\t\n\t    self.notifier = notificationCallback.bind(self);\n\t    self.kuzzle.network.on(self.channel, self.notifier);\n\t\n\t    dequeue.call(self);\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Unsubscribes from Kuzzle.\n\t *\n\t * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n\t * pending subscriptions reaches 0, and only if there is still no listener on that room.\n\t * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n\t *\n\t * @return {*} this\n\t */\n\tKuzzleRoom.prototype.unsubscribe = function () {\n\t  var\n\t    self = this,\n\t    room = self.roomId,\n\t    interval;\n\t\n\t  if (!isReady.call(this)) {\n\t    self.queue.push({action: 'unsubscribe', args: []});\n\t    return self;\n\t  }\n\t\n\t  if (room) {\n\t    self.kuzzle.network.off(self.channel, this.notifier);\n\t\n\t    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n\t      delete self.kuzzle.subscriptions[room];\n\t\n\t      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t        self.kuzzle.query(self.collection.buildQueryArgs('subscribe', 'off'), {body: {roomId: room}});\n\t      } else {\n\t        interval = setInterval(function () {\n\t          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n\t            if (!self.kuzzle.subscriptions[room]) {\n\t              self.kuzzle.query(self.collection.buildQueryArgs('subscribe', 'off'), {body: {roomId: room}});\n\t            }\n\t            clearInterval(interval);\n\t          }\n\t        }, 100);\n\t      }\n\t    } else {\n\t      delete self.kuzzle.subscriptions[room][self.id];\n\t    }\n\t\n\t    self.roomId = null;\n\t  }\n\t\n\t  return self;\n\t};\n\t\n\t/**\n\t * Helper function allowing to set headers while chaining calls.\n\t *\n\t * If the replace argument is set to true, replace the current headers with the provided content.\n\t * Otherwise, it appends the content to the current headers, only replacing already existing values\n\t *\n\t * @param content - new headers content\n\t * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n\t */\n\tKuzzleRoom.prototype.setHeaders = function (content, replace) {\n\t  this.kuzzle.setHeaders.call(this, content, replace);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Callback called by the network handler when a message is sent to the subscribed room ID\n\t * Calls the registered callback if the notification passes the subscription filters\n\t *\n\t * @param {object} data - data\n\t * @returns {*}\n\t */\n\tfunction notificationCallback (data) {\n\t  if (data.error) {\n\t    return this.callback(data.error);\n\t  }\n\t\n\t  if (data.action === 'jwtTokenExpired') {\n\t    this.kuzzle.jwtToken = undefined;\n\t    return this.kuzzle.emitEvent('jwtTokenExpired');\n\t  }\n\t\n\t  if (this.kuzzle.requestHistory[data.requestId]) {\n\t    if (this.subscribeToSelf) {\n\t      this.callback(null, data);\n\t    }\n\t    delete this.kuzzle.requestHistory[data.requestId];\n\t  } else {\n\t    this.callback(null, data);\n\t  }\n\t}\n\t\n\t\n\t/**\n\t * Dequeue actions performed while subscription was being renewed\n\t */\n\tfunction dequeue () {\n\t  var element;\n\t\n\t  while (this.queue.length > 0) {\n\t    element = this.queue.shift();\n\t\n\t    this[element.action].apply(this, element.args);\n\t  }\n\t}\n\t\n\tfunction isReady() {\n\t  if (this.kuzzle.state !== 'connected' || this.subscribing) {\n\t    return false;\n\t  }\n\t  return true;\n\t}\n\t\n\tmodule.exports = KuzzleRoom;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t *\n\t * @param host\n\t * @param wsPort\n\t * @param ioPort\n\t * @returns {Object} tnstantiated WebSocket/Socket.IO object\n\t */\n\t\n\tfunction network(host, wsPort, ioPort) {\n\t  // Web browser / NodeJS websocket handling\n\t  if (typeof window !== 'undefined') {\n\t    // use native websockets if the browser supports it\n\t    if (typeof WebSocket !== 'undefined') {\n\t      return new (__webpack_require__(11))(host, wsPort);\n\t    }\n\t    // otherwise fallback to socket.io, if available\n\t    else if (window.io) {\n\t      return new (__webpack_require__(10))(host, ioPort);\n\t    }\n\t\n\t    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n\t  }\n\t\n\t  return new (__webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"./wrappers/wsnode\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())))(host, wsPort);\n\t}\n\t\n\tmodule.exports = network;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tfunction SocketIO(host, port) {\n\t  this.host = host;\n\t  this.port = port;\n\t  this.socket = null;\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    this.socket = window.io('http://' + this.host + ':' + this.port, {\n\t      reconnection: autoReconnect,\n\t      reconnectionDelay: reconnectionDelay,\n\t      forceNew: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    this.socket.on('connect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    this.socket.on('connect_error', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    this.socket.on('disconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    this.socket.on('reconnect', callback);\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room. Once 1 message is received, fires the\n\t   * callback and unregister it afterward.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.once = function (roomId, callback) {\n\t    this.socket.once(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.on = function (roomId, callback) {\n\t    this.socket.on(roomId, callback);\n\t  };\n\t\n\t  /**\n\t   * Unregisters a callback from a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.off = function (roomId, callback) {\n\t    this.socket.off(roomId, callback);\n\t  };\n\t\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    this.socket.emit('kuzzle', payload);\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.socket.close();\n\t    this.socket = null;\n\t  };\n\t}\n\t\n\tmodule.exports = SocketIO;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tfunction WSBrowsers(host, port) {\n\t  var self = this;\n\t  this.host = host;\n\t  this.port = port;\n\t  this.client = null;\n\t  this.retrying = false;\n\t\n\t  /*\n\t     Listeners are stored using the following format:\n\t     roomId: {\n\t     fn: callback_function,\n\t     once: boolean\n\t     }\n\t   */\n\t  this.listeners = {\n\t    error: [],\n\t    connect: [],\n\t    disconnect: [],\n\t    reconnect: []\n\t  };\n\t\n\t  /**\n\t   * Creates a new socket from the provided arguments\n\t   *\n\t   * @constructor\n\t   * @param {boolean} autoReconnect\n\t   * @param {int} reconnectionDelay\n\t   * @returns {Object} Socket\n\t   */\n\t  this.connect = function (autoReconnect, reconnectionDelay) {\n\t    this.client = new WebSocket('ws://' + this.host + ':' + this.port);\n\t\n\t    this.client.onopen = function () {\n\t      if (self.retrying) {\n\t        poke(self.listeners, 'reconnect');\n\t      }\n\t      else {\n\t        poke(self.listeners, 'connect');\n\t      }\n\t    };\n\t\n\t    this.client.onclose = function () {\n\t      poke(self.listeners, 'disconnect');\n\t    };\n\t\n\t    this.client.onerror = function () {\n\t      if (autoReconnect) {\n\t        self.retrying = true;\n\t        setTimeout(function () {\n\t          self.connect(autoReconnect, reconnectionDelay);\n\t        }, reconnectionDelay);\n\t      }\n\t\n\t      poke(self.listeners, 'error');\n\t    };\n\t\n\t    this.client.onmessage = function (payload) {\n\t      var data = JSON.parse(payload.data);\n\t\n\t      if (data.room && self.listeners[data.room]) {\n\t        poke(self.listeners, data.room, data);\n\t      }\n\t    };\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whence a connection is established\n\t   *\n\t   * @param {function} callback\n\t   */\n\t  this.onConnect = function (callback) {\n\t    this.listeners.connect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection error is received\n\t   * @param {function} callback\n\t   */\n\t  this.onConnectError = function (callback) {\n\t    this.listeners.error.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a disconnection occurred\n\t   * @param {function} callback\n\t   */\n\t  this.onDisconnect = function (callback) {\n\t    this.listeners.disconnect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Fires the provided callback whenever a connection has been reestablished\n\t   * @param {function} callback\n\t   */\n\t  this.onReconnect = function (callback) {\n\t    this.listeners.reconnect.push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room. Once 1 message is received, fires the\n\t   * callback and unregister it afterward.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.once = function (roomId, callback) {\n\t    if (!this.listeners[roomId]) {\n\t      this.listeners[roomId] = [];\n\t    }\n\t\n\t    this.listeners[roomId].push({\n\t      fn: callback,\n\t      keep: false\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Registers a callback on a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.on = function (roomId, callback) {\n\t    if (!this.listeners[roomId]) {\n\t      this.listeners[roomId] = [];\n\t    }\n\t\n\t    this.listeners[roomId].push({\n\t      fn: callback,\n\t      keep: true\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Unregisters a callback from a room.\n\t   *\n\t   * @param {string} roomId\n\t   * @param {function} callback\n\t   */\n\t  this.off = function (roomId, callback) {\n\t    var index;\n\t\n\t    if (this.listeners[roomId]) {\n\t      index = this.listeners[roomId].findIndex(function (listener) {\n\t        return listener.fn === callback;\n\t      });\n\t\n\t      if (index !== -1) {\n\t        if (this.listeners[roomId].length === 1 && ['error', 'connect', 'disconnect', 'reconnect'].indexOf(roomId) === -1) {\n\t          delete this.listeners[roomId];\n\t        }\n\t        else {\n\t          this.listeners[roomId].splice(index, 1);\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t\n\t  /**\n\t   * Sends a payload to the connected server\n\t   *\n\t   * @param {Object} payload\n\t   */\n\t  this.send = function (payload) {\n\t    if (this.client && this.client.readyState === this.client.OPEN) {\n\t      this.client.send(JSON.stringify(payload));\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Closes the connection\n\t   */\n\t  this.close = function () {\n\t    this.listeners = {\n\t      error: [],\n\t      connect: [],\n\t      disconnect: [],\n\t      reconnect: []\n\t    };\n\t\n\t    this.retrying = false;\n\t    this.client.close();\n\t    this.client = null;\n\t  };\n\t}\n\t\n\t/**\n\t * Executes all registered listeners in the provided\n\t * \"listeners\" structure.\n\t *\n\t * Listeners are of the following format:\n\t * [\n\t *    { fn: callback, once: boolean },\n\t *    ...\n\t * ]\n\t *\n\t * @private\n\t * @param {Object} listeners\n\t * @param {string} roomId\n\t * @param {Object} [payload]\n\t */\n\tfunction poke (listeners, roomId, payload) {\n\t  var\n\t    i,\n\t    length = listeners[roomId].length;\n\t\n\t  for (i = 0; i < length; ++i) {\n\t    listeners[roomId][i].fn(payload);\n\t\n\t    if (!listeners[roomId][i].keep) {\n\t      if (listeners[roomId].length > 1) {\n\t        listeners[roomId].splice(i, 1);\n\t        --i;\n\t        --length;\n\t      }\n\t      else {\n\t        delete listeners[roomId];\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tmodule.exports = WSBrowsers;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\tfunction KuzzleProfile(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteProfile'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateProfile'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['hydrate', 'save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tKuzzleProfile.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleProfile\n\t  }\n\t});\n\t\n\t/**\n\t * Persist to the persistent layer the current profile\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t * @returns {Object} this\n\t */\n\tKuzzleProfile.prototype.save = function (options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!this.content.policies) {\n\t    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n\t  }\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = this.serialize();\n\t\n\t  self.kuzzle.query(self.kuzzleSecurity.buildQueryArgs('createOrReplaceProfile'), data, options, function (error) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t\n\t  return self;\n\t};\n\t\n\t\n\t/**\n\t * Add a policy in the policies list\n\t * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n\t *\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.addPolicy = function (policy) {\n\t\n\t  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n\t  }\n\t\n\t  if (!this.content.policies) {\n\t    this.content.policies = [];\n\t  }\n\t\n\t  this.content.policies.push(policy);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set policies list\n\t * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @returns {KuzzleProfile} this\n\t */\n\tKuzzleProfile.prototype.setPolicies = function (policies) {\n\t\n\t  if (!Array.isArray(policies)) {\n\t    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t  }\n\t\n\t  policies.map(function (policy) {\n\t    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n\t      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n\t    }\n\t  });\n\t\n\t  this.content.policies = policies;\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Serialize this object into a JSON object\n\t *\n\t * @return {object} JSON object representing this securityDocument\n\t */\n\tKuzzleProfile.prototype.serialize = function () {\n\t  var\n\t    data = {};\n\t\n\t  if (this.id) {\n\t    data._id = this.id;\n\t  }\n\t\n\t  data.body = this.content;\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Returns the list of policies associated to this profile.\n\t * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n\t *\n\t * @return {object} an array of policies\n\t */\n\tKuzzleProfile.prototype.getPolicies = function () {\n\t  return this.content.policies;\n\t};\n\t\n\tmodule.exports = KuzzleProfile;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar KuzzleSecurityDocument = __webpack_require__(1);\n\t\n\tfunction KuzzleRole(kuzzleSecurity, id, content) {\n\t\n\t  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\t\n\t  // Define properties\n\t  Object.defineProperties(this, {\n\t    // private properties\n\t    deleteActionName: {\n\t      value: 'deleteRole'\n\t    },\n\t    updateActionName: {\n\t      value: 'updateRole'\n\t    }\n\t  });\n\t\n\t  // promisifying\n\t  if (kuzzleSecurity.kuzzle.bluebird) {\n\t    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var whitelist = ['save'];\n\t\n\t        return passes && whitelist.indexOf(name) !== -1;\n\t      }\n\t    });\n\t  }\n\t\n\t}\n\t\n\tKuzzleRole.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n\t  constructor: {\n\t    value: KuzzleRole\n\t  }\n\t});\n\t\n\t/**\n\t * Saves this role into Kuzzle.\n\t *\n\t * If this is a new role, this function will create it in Kuzzle.\n\t * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n\t * of this object.\n\t *\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleRole.prototype.save = function (options, cb) {\n\t  var\n\t    data = this.serialize(),\n\t    self = this;\n\t\n\t  if (options && cb === undefined && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceRole'), data, options, function (error) {\n\t    if (error) {\n\t      return cb ? cb(error) : false;\n\t    }\n\t\n\t    if (cb) {\n\t      cb(null, self);\n\t    }\n\t  });\n\t};\n\t\n\tmodule.exports = KuzzleRole;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar\n\t  KuzzleRole = __webpack_require__(13),\n\t  KuzzleProfile = __webpack_require__(12),\n\t  KuzzleUser = __webpack_require__(2);\n\t\n\t/**\n\t * Kuzzle security constructor\n\t *\n\t * @param kuzzle\n\t * @returns {KuzzleSecurity}\n\t * @constructor\n\t */\n\tfunction KuzzleSecurity(kuzzle) {\n\t\n\t  Object.defineProperty(this, 'kuzzle', {\n\t    value: kuzzle\n\t  });\n\t\n\t  Object.defineProperty(this, 'buildQueryArgs', {\n\t    value: function (action) {\n\t      return {\n\t        controller: 'security',\n\t        action: action\n\t      };\n\t    }\n\t  });\n\t\n\t  if (this.kuzzle.bluebird) {\n\t    return this.kuzzle.bluebird.promisifyAll(this, {\n\t      suffix: 'Promise',\n\t      filter: function (name, func, target, passes) {\n\t        var blacklist = ['roleFactory', 'profileFactory', 'userFactory', 'isActionAllowed'];\n\t\n\t        return passes && blacklist.indexOf(name) === -1;\n\t      }\n\t    });\n\t  }\n\t\n\t  return this;\n\t}\n\t\n\t\n\t/**\n\t * Retrieve a single Role using its unique role ID.\n\t *\n\t * @param {string} id\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getRole = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id) {\n\t    throw new Error('Id parameter is mandatory for getRole function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getRole', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, new KuzzleRole(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on roles according to a filter\n\t *\n\t * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n\t * @param {object} [options] - Optional parameters\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t *\n\t */\n\tKuzzleSecurity.prototype.searchRoles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchRoles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = result.result.hits.map(function (doc) {\n\t      return new KuzzleRole(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: result.result.total, roles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new role in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same role already exists: throw an error if sets to false.\n\t *        Replace the existing role otherwise\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createRole: cannot create a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n\t  }\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n\t      var doc;\n\t\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      doc = new KuzzleRole(self, res.result._id, res.result._source);\n\t      cb(null, doc);\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Update a role in Kuzzle.\n\t *\n\t * @param {string} id - role identifier\n\t * @param {object} content - a plain javascript object representing the role's modification\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.updateRole = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateRole';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateRole: cannot update a role without a role ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      cb(null, new KuzzleRole(self, id, content));\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data);\n\t  }\n\t};\n\t\n\t/**\n\t * Delete role.\n\t *\n\t * There is a small delay between role deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a role that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Role id to delete\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleSecurity.prototype.deleteRole = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (cb) {\n\t    this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, function (err, res) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      cb(null, res.result._id);\n\t    });\n\t  } else {\n\t    this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options);\n\t  }\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleRole object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - role id\n\t * @param {object} content - role content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.roleFactory = function(id, content) {\n\t  return new KuzzleRole(this, id, content);\n\t};\n\t\n\t\n\t/**\n\t * Get a specific profile from kuzzle\n\t *\n\t *\n\t * @param {string} id\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getProfile = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for getProfile function');\n\t  }\n\t\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getProfile', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    cb(null, new KuzzleProfile(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on profiles according to a filter\n\t *\n\t *\n\t * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.searchProfiles = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchProfiles', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new KuzzleProfile(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: response.result.total, profiles: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new profile in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same profile already exists: throw an error if sets to false.\n\t *        Replace the existing profile otherwise\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {object} content - attribute `roles` in `content` must only contains an array of role id\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createProfile = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createProfile: cannot create a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n\t  }\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n\t      var doc;\n\t\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      doc = new KuzzleProfile(self, res.result._id, res.result._source);\n\t      cb(null, doc);\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Update a profile in Kuzzle.\n\t *\n\t * @param {string} id - profile identifier\n\t * @param {object} content - a plain javascript object representing the profile's modification\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.updateProfile = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateProfile';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateProfile: cannot update a profile without a profile ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n\t      var updatedContent = {};\n\t\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      Object.keys(res.result._source).forEach(function (property) {\n\t        updatedContent[property] = res.result._source[property];\n\t      });\n\t\n\t      cb(null, new KuzzleProfile(self, res.result._id, updatedContent));\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data);\n\t  }\n\t};\n\t\n\t/**\n\t * Delete profile.\n\t *\n\t * There is a small delay between profile deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a profile that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleSecurity.prototype.deleteProfile = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (cb) {\n\t    this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, function (err, res) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      cb(null, res.result._id);\n\t    });\n\t  } else {\n\t    this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options);\n\t  }\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleProfile object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - profile id\n\t * @param {object} content - profile content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.profileFactory = function(id, content) {\n\t  return new KuzzleProfile(this, id, content);\n\t};\n\t\n\t/**\n\t * Get a specific user from kuzzle using its unique ID\n\t *\n\t * @param {string} id\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} cb - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.getUser = function (id, options, cb) {\n\t  var\n\t    data,\n\t    self = this;\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('Id parameter is mandatory for getUser function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data = {_id: id};\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.getUser', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, new KuzzleUser(self, response.result._id, response.result._source));\n\t  });\n\t};\n\t\n\t/**\n\t * Executes a search on user according to a filter\n\t *\n\t * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been created wont be returned by this function.\n\t *\n\t * @param {Object} filters - same filters as documents filters\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - returns Kuzzle's response\n\t */\n\tKuzzleSecurity.prototype.searchUsers = function (filters, options, cb) {\n\t  var\n\t    self = this;\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('KuzzleSecurity.searchUsers', cb);\n\t\n\t  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n\t    var documents;\n\t\n\t    if (error) {\n\t      return cb(error);\n\t    }\n\t\n\t    documents = response.result.hits.map(function (doc) {\n\t      return new KuzzleUser(self, doc._id, doc._source);\n\t    });\n\t\n\t    cb(null, { total: response.result.total, users: documents });\n\t  });\n\t};\n\t\n\t/**\n\t * Create a new user in Kuzzle.\n\t *\n\t * Takes an optional argument object with the following property:\n\t *    - replaceIfExist (boolean, default: false):\n\t *        If the same user already exists: throw an error if sets to false.\n\t *        Replace the existing user otherwise\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - attribute `profile` in `content` must only contains the profile id\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.createUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'createUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.createUser: cannot create a user without a user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (options) {\n\t    action = options.replaceIfExist ? 'createOrReplaceUser' : 'createUser';\n\t  }\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data, null, function (err, res) {\n\t      var doc;\n\t\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      doc = new KuzzleUser(self, res.result._id, res.result._source);\n\t      cb(null, doc);\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Update an user in Kuzzle.\n\t *\n\t * @param {string} id - user identifier\n\t * @param {object} content - a plain javascript object representing the user's modification\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - (optional) Handles the query response\n\t */\n\tKuzzleSecurity.prototype.updateUser = function (id, content, options, cb) {\n\t  var\n\t    self = this,\n\t    data = {},\n\t    action = 'updateUser';\n\t\n\t  if (!id || typeof id !== 'string') {\n\t    throw new Error('KuzzleSecurity.updateUser: cannot update an user without an user ID');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  data._id = id;\n\t  data.body = content;\n\t\n\t  if (cb) {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      cb(null, new KuzzleUser(self, res.result._id, res.result._source));\n\t    });\n\t  } else {\n\t    self.kuzzle.query(this.buildQueryArgs(action), data, options);\n\t  }\n\t};\n\t\n\t/**\n\t * Delete user.\n\t *\n\t * There is a small delay between user deletion and their deletion in our advanced search layer,\n\t * usually a couple of seconds.\n\t * That means that a user that was just been delete will be returned by this function\n\t *\n\t *\n\t * @param {string} id - Profile id to delete\n\t * @param {object} [options] - (optional) arguments\n\t * @param {responseCallback} [cb] - Handles the query response\n\t */\n\tKuzzleSecurity.prototype.deleteUser = function (id, options, cb) {\n\t  var data = {_id: id};\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  if (cb) {\n\t    this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, function (err, res) {\n\t      if (err) {\n\t        return cb(err);\n\t      }\n\t\n\t      cb(null, res.result._id);\n\t    });\n\t  } else {\n\t    this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options);\n\t  }\n\t};\n\t\n\t/**\n\t * Instantiate a new KuzzleUser object. Workaround to the module.exports limitation, preventing multiple\n\t * constructors to be exposed without having to use a factory or a composed object.\n\t *\n\t * @param {string} id - user id\n\t * @param {object} content - user content\n\t * @constructor\n\t */\n\tKuzzleSecurity.prototype.userFactory = function(id, content) {\n\t  return new KuzzleUser(this, id, content);\n\t};\n\t\n\t/**\n\t * Tells whether an action is allowed, denied or conditional based on the rights\n\t * rights provided as the first argument. An action is defined as a couple of\n\t * action and controller (mandatory), plus an index and a collection(optional).\n\t *\n\t * @param {object} rights - The rights rights associated to a user\n\t *                            (see getMyrights and getUserrights).\n\t * @param {string} controller - The controller to check the action onto.\n\t * @param {string} action - The action to perform.\n\t * @param {string} index - (optional) The name of index to perform the action onto.\n\t * @param {string} collection - (optional) The name of the collection to perform the action onto.\n\t *\n\t * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n\t *                   correspond to rights containing closures.\n\t *                   See also http://kuzzle.io/guide/#roles-definition\n\t */\n\tKuzzleSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n\t  var filteredRights;\n\t\n\t  if (!rights || typeof rights !== 'object') {\n\t    throw new Error('rights parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!controller || typeof controller !== 'string') {\n\t    throw new Error('controller parameter is mandatory for isActionAllowed function');\n\t  }\n\t  if (!action || typeof action !== 'string') {\n\t    throw new Error('action parameter is mandatory for isActionAllowed function');\n\t  }\n\t\n\t  // We filter in all the rights that match the request (including wildcards).\n\t  filteredRights = rights.filter(function (right) {\n\t    return right.controller === controller || right.controller === '*';\n\t  })\n\t  .filter(function (right) {\n\t    return right.action === action || right.action === '*';\n\t  })\n\t  .filter(function (right) {\n\t    return right.index === index || right.index === '*';\n\t  })\n\t  .filter(function (right) {\n\t    return right.collection === collection || right.collection === '*';\n\t  });\n\t\n\t  // Then, if at least one right allows the action, we return 'allowed'\n\t  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n\t    return 'allowed';\n\t  }\n\t  // If no right allows the action, we check for conditionals.\n\t  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n\t    return 'conditional';\n\t  }\n\t  // Otherwise we return 'denied'.\n\t  return 'denied';\n\t};\n\t\n\t\n\t/**\n\t * Gets the rights array of a given user.\n\t *\n\t * @param {string} userId The id of the user.\n\t * @param {object} [options] - (optional) arguments\n\t * @param {function} cb   The callback containing the normalized array of rights.\n\t */\n\tKuzzleSecurity.prototype.getUserRights = function (userId, options, cb) {\n\t  var\n\t    data = {_id: userId},\n\t    self = this;\n\t\n\t  if (!userId || typeof userId !== 'string') {\n\t    throw new Error('userId parameter is mandatory for getUserRights function');\n\t  }\n\t\n\t  if (!cb && typeof options === 'function') {\n\t    cb = options;\n\t    options = null;\n\t  }\n\t\n\t  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\t\n\t  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, function (err, res) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    cb(null, res.result.hits);\n\t  });\n\t};\n\t\n\tmodule.exports = KuzzleSecurity;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** kuzzle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 800d06d171e852427e99\n **/","var\n  uuid = require('node-uuid'),\n  KuzzleDataCollection = require('./kuzzleDataCollection'),\n  KuzzleSecurity = require('./security/kuzzleSecurity'),\n  KuzzleMemoryStorage = require('./kuzzleMemoryStorage'),\n  KuzzleUser = require('./security/kuzzleUser'),\n  networkWrapper = require('./networkWrapper');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle object constructor.\n *\n * @constructor\n * @param host - Server name or IP Address to the Kuzzle instance\n * @param [options] - Connection options\n * @param {responseCallback} [cb] - Handles connection response\n * @constructor\n */\nmodule.exports = Kuzzle = function (host, options, cb) {\n  var self = this;\n\n  if (!(this instanceof Kuzzle)) {\n    return new Kuzzle(host, options, cb);\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!host || host === '') {\n    throw new Error('host argument missing');\n  }\n\n  Object.defineProperties(this, {\n    // 'private' properties\n    collections: {\n      value: {},\n      writable: true\n    },\n    connectCB: {\n      value: cb\n    },\n    eventListeners: {\n      value: {\n        connected: {lastEmitted: null, listeners: []},\n        error: {lastEmitted: null, listeners: []},\n        disconnected: {lastEmitted: null, listeners: []},\n        reconnected: {lastEmitted: null, listeners: []},\n        jwtTokenExpired: {lastEmitted: null, listeners: []},\n        loginAttempt: {lastEmitted: null, listeners: []},\n        offlineQueuePush: {listeners: []},\n        offlineQueuePop: {listeners: []}\n      }\n    },\n    eventTimeout: {\n      value: 200\n    },\n    queuing: {\n      value: false,\n      writable: true\n    },\n    requestHistory: {\n      value: {},\n      writable: true\n    },\n    state: {\n      value: 'initializing',\n      writable: true\n    },\n    subscriptions: {\n      /*\n       Contains the centralized subscription list in the following format:\n          pending: <number of pending subscriptions>\n          'roomId': {\n            kuzzleRoomID_1: kuzzleRoomInstance_1,\n            kuzzleRoomID_2: kuzzleRoomInstance_2,\n            kuzzleRoomID_...: kuzzleRoomInstance_...\n          }\n\n       This was made to allow multiple subscriptions on the same set of filters, something that Kuzzle does not permit.\n       This structure also allows renewing subscriptions after a connection loss\n       */\n      value: {\n        pending: {}\n      },\n      writable: true\n    },\n    // read-only properties\n    autoReconnect: {\n      value: (options && typeof options.autoReconnect === 'boolean') ? options.autoReconnect : true,\n      enumerable: true\n    },\n    defaultIndex: {\n      value: (options && typeof options.defaultIndex === 'string') ? options.defaultIndex : undefined,\n      writable: true,\n      enumerable: true\n    },\n    reconnectionDelay: {\n      value: (options && typeof options.reconnectionDelay === 'number') ? options.reconnectionDelay : 1000,\n      enumerable: true\n    },\n    host: {\n      value: host,\n      enumerable: true\n    },\n    wsPort: {\n      value: (options && typeof options.wsPort === 'number') ? options.wsPort : 7513,\n      enumerable: true\n    },\n    ioPort: {\n      value: (options && typeof options.ioPort === 'number') ? options.ioPort : 7512,\n      enumerable: true\n    },\n    autoQueue: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoReplay: {\n      value: false,\n      enumerable: true,\n      writable: true\n    },\n    autoResubscribe: {\n      value: true,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    metadata: {\n      value: {},\n      enumerable: true,\n      writable: true\n    },\n    /*\n      Offline queue use the following format:\n            [\n              {\n                ts: <query timestamp>,\n                query: 'query',\n                cb: callbackFunction\n              }\n            ]\n     */\n    offlineQueue: {\n      value: [],\n      enumerable: true,\n      writable: true\n    },\n    queueFilter: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    queueMaxSize: {\n      value: 500,\n      enumerable: true,\n      writable: true\n    },\n    queueTTL: {\n      value: 120000,\n      enumerable: true,\n      writable: true\n    },\n    replayInterval: {\n      value: 10,\n      enumerable: true,\n      writable: true\n    },\n    jwtToken: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    offlineQueueLoader: {\n      value: null,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (options) {\n    Object.keys(options).forEach(function (opt) {\n      if (self.hasOwnProperty(opt) && Object.getOwnPropertyDescriptor(self, opt).writable) {\n        self[opt] = options[opt];\n      }\n    });\n\n    if (options.offlineMode === 'auto' && this.autoReconnect) {\n      this.autoQueue = this.autoReplay = this.autoResubscribe = true;\n    }\n  }\n\n  // Helper function ensuring that this Kuzzle object is still valid before performing a query\n  Object.defineProperty(this, 'isValid', {\n    value: function () {\n      if (self.state === 'disconnected') {\n        throw new Error('This Kuzzle object has been invalidated. Did you try to access it after a disconnect call?');\n      }\n    }\n  });\n\n  // Helper function copying headers to the query data\n  Object.defineProperty(this, 'addHeaders', {\n    value: function (query, headers) {\n      Object.keys(headers).forEach(function (header) {\n        if (!query[header]) {\n          query[header] = headers[header];\n        }\n      });\n\n      return query;\n    }\n  });\n\n  /**\n   * Some methods (mainly read queries) require a callback function. This function exists to avoid repetition of code,\n   * and is called by these methods\n   */\n  Object.defineProperty(this, 'callbackRequired', {\n    value: function (errorMessagePrefix, callback) {\n      if (!callback || typeof callback !== 'function') {\n        throw new Error(errorMessagePrefix + ': a callback argument is required for read queries');\n      }\n    }\n  });\n\n  /**\n   * Create an attribute security that embed all methods to manage Role, Profile and User\n   */\n  Object.defineProperty(this, 'security', {\n    value: new KuzzleSecurity(this),\n    enumerable: true\n  });\n\n  /**\n   * Emit an event to all registered listeners\n   * An event cannot be emitted multiple times before a timeout has been reached.\n   */\n  Object.defineProperty(this, 'emitEvent', {\n    value: function emitEvent(event) {\n      var\n        now = Date.now(),\n        args = Array.prototype.slice.call(arguments, 1),\n        eventProperties = this.eventListeners[event];\n\n      if (eventProperties.lastEmitted && eventProperties.lastEmitted >= now - this.eventTimeout) {\n        return false;\n      }\n\n      eventProperties.listeners.forEach(function (listener) {\n        process.nextTick(function () {\n          listener.fn.apply(undefined, args);\n        });\n      });\n\n      // Events without the 'lastEmitted' property can be emitted without minimum time between emissions\n      if (eventProperties.lastEmitted !== undefined) {\n        eventProperties.lastEmitted = now;\n      }\n    }\n  });\n\n  Object.defineProperty(this, 'memoryStorage', {\n    value: new KuzzleMemoryStorage(this),\n    enumerable: true\n  });\n\n\n  if (!options || !options.connect || options.connect === 'auto') {\n    this.connect();\n  } else {\n    this.state = 'ready';\n  }\n\n  cleanHistory(this.requestHistory);\n\n  if (this.bluebird) {\n    return this.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['getAllStatistics', 'getServerInfo', 'getStatistics',\n          'listCollections', 'listIndexes', 'login', 'logout', 'now', 'query',\n          'checkToken', 'whoAmI', 'updateSelf', 'getMyRights',\n          'refreshIndex', 'getAutoRefresh', 'setAutoRefresh'\n        ];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n};\n\n/**\n * Connects to a Kuzzle instance using the provided host name.\n * @returns {Object} this\n */\nKuzzle.prototype.connect = function () {\n  var self = this;\n\n  if (!self.network) {\n    self.network = networkWrapper(self.host, self.wsPort, self.ioPort);\n  }\n\n  if (['initializing', 'ready', 'disconnected', 'error', 'offline'].indexOf(this.state) === -1) {\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n    return self;\n  }\n\n  self.state = 'connecting';\n  self.network.connect(self.autoReconnect, self.reconnectionDelay);\n\n  self.network.onConnect(function () {\n    self.state = 'connected';\n    renewAllSubscriptions.call(self);\n    dequeue.call(self);\n    self.emitEvent('connected');\n\n    if (self.connectCB) {\n      self.connectCB(null, self);\n    }\n  });\n\n  self.network.onConnectError(function (error) {\n    var connectionError = new Error('Unable to connect to kuzzle server at \"' + self.host + '\"');\n\n    connectionError.internal = error;\n    self.state = 'error';\n    self.emitEvent('error', connectionError);\n\n    if (self.connectCB) {\n      self.connectCB(connectionError);\n    }\n  });\n\n  self.network.onDisconnect(function () {\n    self.state = 'offline';\n\n    if (!self.autoReconnect) {\n      self.disconnect();\n    }\n\n    if (self.autoQueue) {\n      self.queuing = true;\n    }\n\n    self.emitEvent('disconnected');\n  });\n\n  self.network.onReconnect(function () {\n    var reconnect = function () {\n      // renew subscriptions\n      if (self.autoResubscribe) {\n        renewAllSubscriptions.call(self);\n      }\n\n      // replay queued requests\n      if (self.autoReplay) {\n        cleanQueue.call(self);\n        dequeue.call(self);\n      }\n\n      // alert listeners\n      self.emitEvent('reconnected');\n    };\n\n    self.state = 'connected';\n\n    if (self.jwtToken) {\n      self.checkToken(self.jwtToken, function (err, res) {\n        // shouldn't obtain an error but let's invalidate the token anyway\n        if (err || !res.valid) {\n          self.jwtToken = undefined;\n          self.emitEvent('jwtTokenExpired');\n        }\n\n        reconnect();\n      });\n    } else {\n      reconnect();\n    }\n  });\n\n  return this;\n};\n\n/**\n * Set the jwtToken used to query kuzzle\n * @param token\n * @returns {Kuzzle}\n */\nKuzzle.prototype.setJwtToken = function(token) {\n  if (typeof token === 'string') {\n    this.jwtToken = token;\n  } else if (typeof token === 'object') {\n    if (token.result && token.result.jwt && typeof token.result.jwt === 'string') {\n      this.jwtToken = token.result.jwt;\n    } else {\n      this.emitEvent('loginAttempt', {\n        success: false,\n        error: 'Cannot find a valid JWT token in the following object: ' + JSON.stringify(token)\n      });\n\n      return this;\n    }\n  } else {\n    this.emitEvent('loginAttempt', {success: false, error: 'Invalid token argument: ' + token});\n    return this;\n  }\n\n  renewAllSubscriptions.call(this);\n  this.emitEvent('loginAttempt', {success: true});\n  return this;\n};\n\n/**\n * Get the jwtToken used by kuzzle\n * @returns {Kuzzle}\n */\nKuzzle.prototype.getJwtToken = function() {\n  return this.jwtToken;\n};\n\n/**\n * Send login request to kuzzle with credentials\n * If login success, store the jwtToken into kuzzle object\n *\n * @param strategy\n * @param credentials\n * @param expiresIn\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.login = function (strategy) {\n  var\n    self = this,\n    request = {\n      strategy: strategy\n    },\n    credentials,\n    cb;\n\n  // Handle arguments (credentials, expiresIn, cb)\n  if (arguments[1]) {\n    if (typeof arguments[1] === 'object') {\n      credentials = arguments[1];\n    } else if (typeof arguments[1] === 'number' || typeof arguments[1] === 'string') {\n      request.expiresIn = arguments[1];\n    } else if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n    }\n  }\n  if (arguments[2]) {\n    if (typeof arguments[2] === 'number' || typeof arguments[2] === 'string') {\n      request.expiresIn = arguments[2];\n    } else if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n    }\n  }\n  if (arguments[3] && typeof arguments[3] === 'function') {\n    cb = arguments[3];\n  }\n\n  if (typeof credentials === 'object') {\n    Object.keys(credentials).forEach(function (key) {\n      request[key] = credentials[key];\n    });\n  }\n\n  this.query({controller: 'auth', action: 'login'}, {body: request}, {queuable: false}, function(error, response) {\n    if (!error) {\n      if (response.result.jwt) {\n        self.setJwtToken(response.result.jwt);\n      }\n\n      if (cb && typeof cb === 'function') {\n        cb(null, response.result);\n      }\n    }\n    else {\n      if (cb && typeof cb === 'function') {\n        cb(error);\n      }\n\n      self.emitEvent('loginAttempt', {success: false, error: error.message});\n    }\n  });\n\n  return self;\n};\n\n/**\n * Send logout request to kuzzle with jwtToken.\n *\n * @param cb\n * @returns {Kuzzle}\n */\nKuzzle.prototype.logout = function (cb) {\n  var\n    self = this,\n    request = {\n      action: 'logout',\n      controller: 'auth',\n      requestId: uuid.v4(),\n      body: {}\n    };\n\n  this.query({controller: 'auth', action: 'logout'}, request, {queuable: false}, function(error) {\n    if (error === null) {\n      self.jwtToken = undefined;\n\n      if (typeof cb === 'function') {\n        cb(null, self);\n      }\n    }\n    else if (typeof cb === 'function') {\n      cb(error);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Checks whether a given jwt token still represents a valid session in Kuzzle.\n *\n * @param  {string}   token     The jwt token to check\n * @param  {function} callback  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n * @return {Kuzzle}             The Kuzzle instance to enable chaining.\n */\nKuzzle.prototype.checkToken = function (token, callback) {\n  var\n    self = this,\n    request = {\n      body: {\n        token: token\n      }\n    };\n\n  this.callbackRequired('Kuzzle.checkToken', callback);\n\n  this.query({controller: 'auth', action: 'checkToken'}, request, {queuable: false}, function (err, response) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, response.result);\n  });\n\n  return self;\n};\n\n/**\n * Fetches the current user.\n *\n * @param  {function} callback  The callback to be called when the response is\n *                              available. The signature is `function(error, response)`.\n * @return {Kuzzle}             The Kuzzle instance to enable chaining.\n */\nKuzzle.prototype.whoAmI = function (callback) {\n  var self = this;\n\n  self.callbackRequired('Kuzzle.whoAmI', callback);\n\n  self.query({controller: 'auth', action: 'getCurrentUser'}, {}, {}, function (err, response) {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new KuzzleUser(self.security, response.result._id, response.result._source));\n  });\n\n  return self;\n};\n\n/**\n * Gets the rights array of the currently logged user.\n *\n * @param  {function} cb The callback containing the normalized array of rights.\n */\nKuzzle.prototype.getMyRights = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.callbackRequired('Kuzzle.getMyRights', cb);\n\n  self.query({controller: 'auth', action:'getMyRights'}, {}, null, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.hits);\n  });\n};\n\n/**\n * Update current user in Kuzzle.\n *\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzle.prototype.updateSelf = function (content, options, cb) {\n  var\n    self = this,\n    data = {},\n    queryArgs = {controller: 'auth', action: 'updateSelf'};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data.body = content;\n\n  if (cb) {\n    self.query(queryArgs, data, options, function (err, res) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, res.result);\n    });\n  } else {\n    self.query(queryArgs, data, options);\n  }\n};\n\n/**\n * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected\n */\nfunction cleanQueue () {\n  var\n    self = this,\n    now = Date.now(),\n    lastDocumentIndex = -1;\n\n  if (self.queueTTL > 0) {\n    self.offlineQueue.forEach(function (query, index) {\n      if (query.ts < now - self.queueTTL) {\n        lastDocumentIndex = index;\n      }\n    });\n\n    if (lastDocumentIndex !== -1) {\n      self.offlineQueue\n        .splice(0, lastDocumentIndex + 1)\n        .forEach(function (droppedRequest) {\n          self.emitEvent('offlineQueuePop', droppedRequest.query);\n        });\n    }\n  }\n\n  if (self.queueMaxSize > 0 && self.offlineQueue.length > self.queueMaxSize) {\n    self.offlineQueue\n      .splice(0, self.offlineQueue.length - self.queueMaxSize)\n      .forEach(function (droppedRequest) {\n        self.emitEvent('offlineQueuePop', droppedRequest.query);\n      });\n  }\n}\n\n\n/**\n * Clean history from requests made more than 10s ago\n */\nfunction cleanHistory (requestHistory) {\n  var\n    now = Date.now();\n\n  Object.keys(requestHistory).forEach(function (key) {\n    if (requestHistory[key] < now - 10000) {\n      delete requestHistory[key];\n    }\n  });\n\n  setTimeout(function () {\n    cleanHistory(requestHistory);\n  }, 1000);\n}\n\n/**\n * Emit a request to Kuzzle\n *\n * @param {object} request\n * @param {responseCallback} [cb]\n */\nfunction emitRequest (request, cb) {\n  var\n    self = this;\n\n  if (self.jwtToken !== undefined || cb) {\n    self.network.once(request.requestId, function (response) {\n      if (request.action !== 'logout' && response.error && response.error.message === 'Token expired') {\n        self.jwtToken = undefined;\n        self.emitEvent('jwtTokenExpired', request, cb);\n      }\n\n      if (cb) {\n        cb(response.error, response);\n      }\n    });\n  }\n\n  this.network.send(request);\n\n  // Track requests made to allow KuzzleRoom.subscribeToSelf to work\n  self.requestHistory[request.requestId] = Date.now();\n}\n\n/**\n * Play all queued requests, in order.\n */\nfunction dequeue () {\n  var\n    self = this,\n    additionalQueue,\n    uniqueQueue = {},\n    dequeuingProcess = function () {\n      if (self.offlineQueue.length > 0) {\n        emitRequest.call(self, self.offlineQueue[0].query, self.offlineQueue[0].cb);\n        self.emitEvent('offlineQueuePop', self.offlineQueue.shift());\n\n        setTimeout(function () {\n          dequeuingProcess();\n        }, Math.max(0, self.replayInterval));\n      } else {\n        self.queuing = false;\n      }\n    };\n\n  if (self.offlineQueueLoader) {\n    if (typeof self.offlineQueueLoader !== 'function') {\n      throw new Error('Invalid value for offlineQueueLoader property. Expected: function. Got: ' + typeof self.offlineQueueLoader);\n    }\n\n    additionalQueue = self.offlineQueueLoader();\n    if (Array.isArray(additionalQueue)) {\n      self.offlineQueue = additionalQueue\n        .concat(self.offlineQueue)\n        .filter(function (request) {\n          // throws if the query object does not contain required attributes\n          if (!request.query || request.query.requestId === undefined || !request.query.action || !request.query.controller) {\n            throw new Error('Invalid offline queue request. One or more missing properties: requestId, action, controller.');\n          }\n\n          return uniqueQueue.hasOwnProperty(request.query.requestId) ? false : (uniqueQueue[request.query.requestId] = true);\n        });\n    } else {\n      throw new Error('Invalid value returned by the offlineQueueLoader function. Expected: array. Got: ' + typeof additionalQueue);\n    }\n  }\n\n  dequeuingProcess();\n}\n\n/**\n * Renew all registered subscriptions. Triggered either by a successful connection/reconnection or by a\n * successful login attempt\n */\nfunction renewAllSubscriptions() {\n  var self = this;\n\n  Object.keys(self.subscriptions).forEach(function (roomId) {\n    Object.keys(self.subscriptions[roomId]).forEach(function (subscriptionId) {\n      var subscription = self.subscriptions[roomId][subscriptionId];\n      subscription.renew(subscription.callback);\n    });\n  });\n}\n\n/**\n * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their\n * insertion.\n *\n * The ID returned by this function is required to remove this listener at a later time.\n *\n * @param {string} event - name of the global event to subscribe to (see the 'eventListeners' object property)\n * @param {function} listener - callback to invoke each time an event is fired\n * @returns {string} Unique listener ID\n */\nKuzzle.prototype.addListener = function(event, listener) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    listenerType = typeof listener,\n    listenerId;\n\n  this.isValid();\n\n  if (knownEvents.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n  }\n\n  if (listenerType !== 'function') {\n    throw new Error('Invalid listener type: expected a function, got a ' + listenerType);\n  }\n\n  listenerId = uuid.v4();\n  this.eventListeners[event].listeners.push({id: listenerId, fn: listener});\n  return listenerId;\n};\n\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method returns all available statistics from Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {object} this\n */\nKuzzle.prototype.getAllStatistics = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getAllStatistics', cb);\n\n  this.query({controller:'admin', action: 'getAllStats'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.hits);\n  });\n\n  return this;\n};\n\n/**\n * Kuzzle monitors active connections, and ongoing/completed/failed requests.\n * This method allows getting either the last statistics frame, or a set of frames starting from a provided timestamp.\n *\n * @param {number} timestamp -  Epoch time. Starting time from which the frames are to be retrieved\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {object} this\n */\nKuzzle.prototype.getStatistics = function (timestamp, options, cb) {\n  var queryCB;\n\n  if (!cb) {\n    if (arguments.length === 1) {\n      cb = arguments[0];\n      options = null;\n      timestamp = null;\n    } else {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'object') {\n        options = arguments[0];\n        timestamp = null;\n      } else {\n        timestamp = arguments[0];\n        options = null;\n      }\n    }\n  }\n\n  queryCB = function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    if (timestamp) {\n      cb(null, res.result.hits);\n    } else {\n      cb(null, [res.result]);\n    }\n  };\n\n  this.callbackRequired('Kuzzle.getStatistics', cb);\n\n  if (!timestamp) {\n    this.query({controller: 'admin', action: 'getLastStats'}, {}, options, queryCB);\n  } else {\n    this.query({controller: 'admin', action: 'getStats'}, { body: { startTime: timestamp } }, options, queryCB);\n  }\n\n  return this;\n};\n\n/**\n * Create a new instance of a KuzzleDataCollection object.\n * If no index is specified, takes the default index.\n *\n * @param {string} collection - The name of the data collection you want to manipulate\n * @param {string} [index] - The name of the data index containing the data collection\n * @returns {object} A KuzzleDataCollection instance\n */\nKuzzle.prototype.dataCollectionFactory = function(collection, index) {\n  this.isValid();\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Unable to create a new data collection object: no index specified');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  if (typeof index !== 'string') {\n    throw new Error('Invalid \"index\" argument: string expected, got ' + typeof index);\n  }\n\n  if (typeof collection !== 'string') {\n    throw new Error('Invalid \"collection\" argument: string expected, got ' + typeof collection);\n  }\n\n  if (!this.collections[index]) {\n    this.collections[index] = {};\n  }\n\n  if (!this.collections[index][collection]) {\n    this.collections[index][collection] = new KuzzleDataCollection(this, index, collection);\n  }\n\n  return this.collections[index][collection];\n};\n\n/**\n * Empties the offline queue without replaying it.\n *\n * @returns {Kuzzle}\n */\nKuzzle.prototype.flushQueue = function () {\n  this.offlineQueue = [];\n  return this;\n};\n\n/**\n * Returns the list of known persisted data collections.\n *\n * @param {string} [index] - Index containing collections to be listed\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {object} this\n */\nKuzzle.prototype.listCollections = function () {\n  var\n    collectionType = 'all',\n    index,\n    options,\n    cb,\n    args = Array.prototype.slice.call(arguments);\n\n  args.forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.listCollections: index required');\n    }\n\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.listCollections', cb);\n\n  if (options && options.type) {\n    collectionType = options.type;\n  }\n\n  this.query({index: index, controller: 'read', action: 'listCollections'}, {body: {type: collectionType}}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    return cb(null, res.result.collections);\n  });\n\n  return this;\n};\n\n/**\n * Returns the list of existing indexes in Kuzzle\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {object} this\n */\nKuzzle.prototype.listIndexes = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.listIndexes', cb);\n\n  this.query({controller: 'read', action: 'listIndexes'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    return cb(null, res.result.indexes);\n  });\n\n  return this;\n};\n\n/**\n * Disconnects from Kuzzle and invalidate this instance.\n */\nKuzzle.prototype.disconnect = function () {\n  var collection;\n\n  this.logout();\n\n  this.state = 'disconnected';\n  this.network.close();\n\n  for (collection in this.collections) {\n    if (this.collections.hasOwnProperty(collection)) {\n      delete this.collections[collection];\n    }\n  }\n};\n\n/**\n * Returns the server informations\n *\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {object} this\n */\nKuzzle.prototype.getServerInfo = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.getServerInfo', cb);\n\n  this.query({controller: 'read', action: 'serverInfo'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.serverInfo);\n  });\n\n  return this;\n};\n\n/**\n * Forces an index refresh\n *\n * @param {string} index - The index to refresh. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {Kuzzle}\n */\nKuzzle.prototype.refreshIndex = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function(arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.refreshIndex: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.query({ index: index, controller: 'admin', action: 'refreshIndex'}, {}, options, cb);\n\n  return this;\n};\n\n/**\n * Returns de current autoRefresh status for the given index\n *\n * @param {string} index - The index to get the status from. Defaults to Kuzzle.defaultIndex\n * @param {object} options - Optinal arguments\n * @param {responseCallback} cb - Handles the query response\n * @returns {object} this\n */\nKuzzle.prototype.getAutoRefresh = function () {\n  var\n    index,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.getAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  this.callbackRequired('Kuzzle.getAutoRefresh', cb);\n  this.query({ index: index, controller: 'admin', action: 'getAutoRefresh'}, {}, options, cb);\n\n  return this;\n};\n\n/**\n * (Un)Sets the autoRefresh flag on the given index\n *\n * @param {string} index - the index to modify. Defaults to Kuzzle.defaultIndex\n * @param {boolean} autoRefresh - The autoRefresh value to set\n * @param {object} options - Optional arguments\n * @param {responseCallback} cb - Handles the query result\n * @returns {object} this\n */\nKuzzle.prototype.setAutoRefresh = function () {\n  var\n    index,\n    autoRefresh,\n    options,\n    cb;\n\n  Array.prototype.slice.call(arguments).forEach(function (arg) {\n    switch (typeof arg) {\n      case 'string':\n        index = arg;\n        break;\n      case 'boolean':\n        autoRefresh = arg;\n        break;\n      case 'object':\n        options = arg;\n        break;\n      case 'function':\n        cb = arg;\n        break;\n    }\n  });\n\n  if (!index) {\n    if (!this.defaultIndex) {\n      throw new Error('Kuzzle.setAutoRefresh: index required');\n    }\n    index = this.defaultIndex;\n  }\n\n  if (autoRefresh === undefined) {\n    throw new Error('Kuzzle.setAutoRefresh: autoRefresh value is required');\n  }\n\n  this.query({ index: index, controller: 'admin', action: 'setAutoRefresh'}, { body: { autoRefresh: autoRefresh }}, options, cb);\n\n  return this;\n};\n\n/**\n * Return the current Kuzzle's UTC Epoch time, in milliseconds\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {object} this\n */\nKuzzle.prototype.now = function (options, cb) {\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.callbackRequired('Kuzzle.now', cb);\n\n  this.query({controller: 'read', action: 'now'}, {}, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.now);\n  });\n\n  return this;\n};\n\n/**\n * This is a low-level method, exposed to allow advanced SDK users to bypass high-level methods.\n * Base method used to send read queries to Kuzzle\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} queryArgs - Query configuration\n * @param {object} query - The query data\n * @param {object} [options] - Optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzle.prototype.query = function (queryArgs, query, options, cb) {\n  var\n    attr,\n    object = {\n      action: queryArgs.action,\n      controller: queryArgs.controller,\n      metadata: this.metadata\n    },\n    self = this;\n\n  this.isValid();\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (options) {\n    if (options.metadata) {\n      Object.keys(options.metadata).forEach(function (meta) {\n        object.metadata[meta] = options.metadata[meta];\n      });\n    }\n\n    if (options.queuable === false && self.state === 'offline') {\n      return self;\n    }\n  }\n\n  if (!query || typeof query !== 'object' || Array.isArray(query)) {\n    throw new Error('Invalid query parameter: ' + query);\n  }\n\n  if (query.metadata) {\n    Object.keys(query.metadata).forEach(function (meta) {\n      object.metadata[meta] = query.metadata[meta];\n    });\n  }\n\n  for (attr in query) {\n    if (attr !== 'metadata' && query.hasOwnProperty(attr)) {\n      object[attr] = query[attr];\n    }\n  }\n\n  object = self.addHeaders(object, this.headers);\n\n  /*\n   * Do not add the token for the checkToken route, to avoid getting a token error when\n   * a developer simply wish to verify his token\n   */\n  if (self.jwtToken !== undefined && !(object.controller === 'auth' && object.action === 'checkToken')) {\n    object.headers = object.headers || {};\n    object.headers.authorization = 'Bearer ' + self.jwtToken;\n  }\n\n  if (queryArgs.collection) {\n    object.collection = queryArgs.collection;\n  }\n\n  if (queryArgs.index) {\n    object.index = queryArgs.index;\n  }\n\n  if (!object.requestId) {\n    object.requestId = uuid.v4();\n  }\n\n  if (self.state === 'connected' || (options && options.queuable === false)) {\n    if (self.state === 'connected') {\n      emitRequest.call(this, object, cb);\n    } else if (cb) {\n      cb(new Error('Unable to execute request: not connected to a Kuzzle server.\\nDiscarded request: ' + JSON.stringify(object)));\n    }\n  } else if (self.queuing || ['initializing', 'connecting'].indexOf(self.state) !== -1) {\n    cleanQueue.call(this, object, cb);\n\n    if (!self.queueFilter || self.queueFilter(object)) {\n      self.offlineQueue.push({ts: Date.now(), query: object, cb: cb});\n      self.emitEvent('offlineQueuePush', {query: object, cb: cb});\n    }\n  }\n\n  return self;\n};\n\n/**\n * Removes all listeners, either from a specific event or from all events\n *\n * @param {string} event - One of the event described in the Event Handling section of this documentation\n */\nKuzzle.prototype.removeAllListeners = function (event) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    self = this;\n\n  if (event) {\n    if (knownEvents.indexOf(event) === -1) {\n      throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n    }\n\n    this.eventListeners[event].listeners = [];\n  } else {\n    knownEvents.forEach(function (eventName) {\n      self.eventListeners[eventName].listeners = [];\n    });\n  }\n};\n\n/**\n * Removes a listener from an event.\n *\n * @param {string} event - One of the event described in the Event Handling section of this documentation\n * @param {string} listenerId - The ID returned by addListener\n */\nKuzzle.prototype.removeListener = function (event, listenerId) {\n  var\n    knownEvents = Object.keys(this.eventListeners),\n    self = this;\n\n  if (knownEvents.indexOf(event) === -1) {\n    throw new Error('[' + event + '] is not a known event. Known events: ' + knownEvents.toString());\n  }\n\n  this.eventListeners[event].listeners.forEach(function (listener, index) {\n    if (listener.id === listenerId) {\n      self.eventListeners[event].listeners.splice(index, 1);\n    }\n  });\n};\n\n/**\n * Replays the requests queued during offline mode.\n * Works only if the SDK is not in a disconnected state, and if the autoReplay option is set to false.\n */\nKuzzle.prototype.replayQueue = function () {\n  if (this.state !== 'offline' && !this.autoReplay) {\n    cleanQueue.call(this);\n    dequeue.call(this);\n  }\n\n  return this;\n};\n\n/**\n * Sets the default Kuzzle index\n *\n * @param index\n * @returns this\n */\nKuzzle.prototype.setDefaultIndex = function (index) {\n  if (typeof index !== 'string') {\n    throw new Error('Invalid default index: [' + index + '] (an index name is expected)');\n  }\n\n  if (index.length === 0) {\n    throw new Error('Cannot set an empty index as the default index');\n  }\n\n  this.defaultIndex = index;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzle.prototype.setHeaders = function (content, replace) {\n  var self = this;\n\n  if (typeof content !== 'object' || Array.isArray(content)) {\n    throw new Error('Expected a content object, received a ' + typeof content);\n  }\n\n  if (replace) {\n    self.headers = content;\n  } else {\n    Object.keys(content).forEach(function (key) {\n      self.headers[key] = content[key];\n    });\n  }\n\n  return self;\n};\n\n/**\n * Starts the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.startQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = true;\n  }\n  return this;\n};\n\n/**\n * Stops the requests queuing. Works only during offline mode, and if the autoQueue option is set to false.\n */\nKuzzle.prototype.stopQueuing = function () {\n  if (this.state === 'offline' && !this.autoQueue) {\n    this.queuing = false;\n  }\n\n  return this;\n};\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kuzzle.js\n ** module id = 0\n ** module chunks = 0\n **/","function KuzzleSecurityDocument(kuzzleSecurity, id, content) {\n\n  if (!id) {\n    throw new Error('A security document must have an id');\n  }\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    kuzzle: {\n      value: kuzzleSecurity.kuzzle\n    },\n    kuzzleSecurity: {\n      value: kuzzleSecurity\n    },\n    // read-only properties\n    // writable properties\n    id: {\n      value: id,\n      enumerable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    }\n  });\n\n  if (content) {\n    this.setContent(content, true);\n  }\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'update'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {Object} data - New securityDocument content\n * @return {Object} this\n */\nKuzzleSecurityDocument.prototype.setContent = function (data) {\n  this.content = data;\n  return this;\n};\n\n/**\n * Serialize this object into a pojo\n *\n * @return {object} pojo representing this securityDocument\n */\nKuzzleSecurityDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n\n  return data;\n};\n\n/**\n * Delete the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleSecurityDocument.prototype.delete = function (options, cb) {\n  var\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.deleteActionName), {_id: this.id}, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, res.result._id);\n    }\n  });\n};\n\n/**\n * Update the current KuzzleSecurityDocument into Kuzzle.\n *\n * @param {object} content - Content to add to KuzzleSecurityDocument\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleSecurityDocument.prototype.update = function (content, options, cb) {\n  var\n    data = {},\n    self = this;\n\n  if (typeof content !== 'object') {\n    throw new Error('Parameter \"content\" must be a object');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = self.id;\n  data.body = content;\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs(this.updateActionName), data, options, function (error, response) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.setContent(response.result._source);\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n};\n\nmodule.exports = KuzzleSecurityDocument;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/security/kuzzleSecurityDocument.js\n ** module id = 1\n ** module chunks = 0\n **/","var\n  KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\nfunction KuzzleUser(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteUser'\n    },\n    updateActionName: {\n      value: 'updateUser'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n}\n\nKuzzleUser.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleUser\n  }\n});\n\n/**\n * Set profiles in content\n * @param {array} profile - an array of profiles ids string\n *\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.setProfiles = function (profilesIds) {\n  if (!Array.isArray(profilesIds) || typeof profilesIds[0] !== 'string') {\n    throw new Error('Parameter \"profilesIds\" must be an array of strings');\n  }\n\n  this.content.profilesIds = profilesIds;\n\n  return this;\n};\n\n/**\n * Add a profile\n * @param {string} profile - a profile ids string\n *\n * @returns {KuzzleUser} this\n */\nKuzzleUser.prototype.addProfile = function (profileId) {\n  if (typeof profileId !== 'string') {\n    throw new Error('Parameter \"profileId\" must be a string');\n  }\n\n  if (!this.content.profilesIds) {\n    this.content.profilesIds = [];\n  }\n\n  if (this.content.profilesIds.indexOf(profileId) === -1) {\n    this.content.profilesIds.push(profileId);\n  }\n\n  return this;\n};\n\n/**\n * Saves this user into Kuzzle.\n *\n * If this is a new user, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this user in Kuzzle by the current content\n * of this object.\n *\n * @param {responseCallback} [cb] - Handles the query response\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nKuzzleUser.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceUser'), data, options, function (error) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this User\n */\nKuzzleUser.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n\n  return data;\n};\n\n/**\n * Return the associated profiles IDs\n *\n * @return {array} the associated profiles IDs\n */\nKuzzleUser.prototype.getProfiles = function () {\n  return this.content.profilesIds;\n};\n\nmodule.exports = KuzzleUser;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/security/kuzzleUser.js\n ** module id = 2\n ** module chunks = 0\n **/","//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/*global window, require, define */\n(function(_window) {\n  'use strict';\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;\n\n  function setupBrowser() {\n    // Allow for MSIE11 msCrypto\n    var _crypto = _window.crypto || _window.msCrypto;\n\n    if (!_rng && _crypto && _crypto.getRandomValues) {\n      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n      //\n      // Moderately fast, high quality\n      try {\n        var _rnds8 = new Uint8Array(16);\n        _whatwgRNG = _rng = function whatwgRNG() {\n          _crypto.getRandomValues(_rnds8);\n          return _rnds8;\n        };\n        _rng();\n      } catch(e) {}\n    }\n\n    if (!_rng) {\n      // Math.random()-based (RNG)\n      //\n      // If all else fails, use Math.random().  It's fast, but is of unspecified\n      // quality.\n      var  _rnds = new Array(16);\n      _mathRNG = _rng = function() {\n        for (var i = 0, r; i < 16; i++) {\n          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }\n          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n        }\n\n        return _rnds;\n      };\n      if ('undefined' !== typeof console && console.warn) {\n        console.warn(\"[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()\");\n      }\n    }\n  }\n\n  function setupNode() {\n    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n    //\n    // Moderately fast, high quality\n    if ('function' === typeof require) {\n      try {\n        var _rb = require('crypto').randomBytes;\n        _nodeRNG = _rng = _rb && function() {return _rb(16);};\n        _rng();\n      } catch(e) {}\n    }\n  }\n\n  if (_window) {\n    setupBrowser();\n  } else {\n    setupNode();\n  }\n\n  // Buffer class to use\n  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) === 'string') {\n      buf = (options === 'binary') ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n  uuid._rng = _rng;\n  uuid._mathRNG = _mathRNG;\n  uuid._nodeRNG = _nodeRNG;\n  uuid._whatwgRNG = _whatwgRNG;\n\n  if (('undefined' !== typeof module) && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else if (typeof define === 'function' && define.amd) {\n    // Publish as AMD module\n    define(function() {return uuid;});\n\n\n  } else {\n    // Publish as global (in browsers)\n    _previousRoot = _window.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _window.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _window.uuid = uuid;\n  }\n})('undefined' !== typeof window ? window : null);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-uuid/uuid.js\n ** module id = 3\n ** module chunks = 0\n **/","var\n  KuzzleDocument = require('./kuzzleDocument'),\n  KuzzleDataMapping = require('./kuzzleDataMapping'),\n  KuzzleRoom = require('./kuzzleRoom');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * A data collection is a set of data managed by Kuzzle. It acts like a data table for persistent documents,\n * or like a room for pub/sub messages.\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @param {string} index - Index containing the data collection\n * @param {string} collection - name of the data collection to handle\n * @constructor\n */\nfunction KuzzleDataCollection(kuzzle, index, collection) {\n  if (!index || !collection) {\n    throw new Error('The KuzzleDataCollection object constructor needs an index and a collection arguments');\n  }\n\n\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: collection,\n      enumerable: true\n    },\n    index: {\n      value: index,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (controller, action) {\n      return {\n        controller: controller,\n        action: action,\n        collection: this.collection,\n        index: this.index\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['publishMessage', 'setHeaders', 'subscribe'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Executes an advanced search on the data collection.\n *\n * /!\\ There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function.\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.advancedSearch = function (filters, options, cb) {\n  var\n    query,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleDataCollection.advancedSearch', cb);\n\n  query = self.kuzzle.addHeaders({body: filters}, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('read', 'search'), query, options, function (error, result) {\n    var documents = [];\n\n    if (error) {\n      return cb(error);\n    }\n\n    result.result.hits.forEach(function (doc) {\n      var newDocument = new KuzzleDocument(self, doc._id, doc._source);\n\n      newDocument.version = doc._version;\n\n      documents.push(newDocument);\n    });\n\n    cb(null, { total: result.result.total, documents: documents });\n  });\n\n  return this;\n};\n\n/**\n * Returns the number of documents matching the provided set of filters.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * @param {object} filters - Filters in Elasticsearch Query DSL format\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.count = function (filters, options, cb) {\n  var\n    query;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.count', cb);\n\n  query = this.kuzzle.addHeaders({body: filters}, this.headers);\n\n  this.kuzzle.query(this.buildQueryArgs('read', 'count'), query, options, function (error, result) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, result.result.count);\n  });\n\n  return this;\n};\n\n/**\n * Create a new empty data collection, with no associated mapping.\n * Kuzzle automatically creates data collections when storing documents, but there are cases where we\n * want to create and prepare data collections before storing documents in it.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.create = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('write', 'createCollection'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Create a new document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *    - updateIfExist (boolean, default: false):\n *        If the same document already exists: throw an error if sets to false.\n *        Update the existing document otherwise\n *\n * @param {string} [id] - (optional) document identifier\n * @param {object} document - either an instance of a KuzzleDocument object, or a document\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.createDocument = function (id, document, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'create';\n\n  if (id && typeof id !== 'string') {\n    cb = options;\n    options = document;\n    document = id;\n    id = null;\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (document instanceof KuzzleDocument) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  if (options) {\n    action = options.updateIfExist ? 'createOrReplace' : 'create';\n  }\n\n  if (id) {\n    data._id = id;\n  }\n\n  data = self.kuzzle.addHeaders(data, self.headers);\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs('write', action), data, options, function (err, res) {\n      var doc;\n\n      if (err) {\n        return cb(err);\n      }\n\n      doc = new KuzzleDocument(self, res.result._id, res.result._source);\n      doc.version = res.result._version;\n      cb(null, doc);\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs('write', action), data, options);\n  }\n\n  return this;\n};\n\n/**\n * Delete persistent documents.\n *\n * There is a small delay between documents creation and their existence in our advanced search layer,\n * usually a couple of seconds.\n * That means that a document that was just been created wont be returned by this function\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string|object} arg - Either a document ID (will delete only this particular document), or a set of filters\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.deleteDocument = function (arg, options, cb) {\n  var\n    action,\n    data = {};\n\n  if (typeof arg === 'string') {\n    data._id = arg;\n    action = 'delete';\n  } else {\n    data.body = arg;\n    action = 'deleteByQuery';\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  if (cb) {\n    this.kuzzle.query(this.buildQueryArgs('write', action), data, options, function (err, res) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (action === 'delete') {\n        cb(null, [res.result._id]);\n      } else {\n        cb(null, res.result.ids);\n      }\n    });\n  } else {\n    this.kuzzle.query(this.buildQueryArgs('write', action), data, options);\n  }\n};\n\n/**\n * Retrieve a single stored document using its unique document ID.\n *\n * @param {string} documentId - Unique document identifier\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.fetchDocument = function (documentId, options, cb) {\n  var\n    data = {_id: documentId},\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleDataCollection.fetch', cb);\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  self.kuzzle.query(this.buildQueryArgs('read', 'get'), data, options, function (err, res) {\n    var document;\n\n    if (err) {\n      return cb(err);\n    }\n\n    document = new KuzzleDocument(self, res.result._id, res.result._source);\n    document.version = res.result._version;\n    cb(null, document);\n  });\n\n  return this;\n};\n\n/**\n * Retrieves all documents stored in this data collection\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Handles the query response\n * @returns {Object} this\n */\nKuzzleDataCollection.prototype.fetchAllDocuments = function (options, cb) {\n  var filters = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  // copying pagination options to the search filter\n  if (options) {\n    if (options.from) {\n      filters.from = options.from;\n    }\n\n    if (options.size) {\n      filters.size = options.size;\n    }\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.fetchAll', cb);\n\n  this.advancedSearch(filters, options, cb);\n\n  return this;\n};\n\n\n/**\n * Instantiates a KuzzleDataMapping object containing the current mapping of this collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} cb - Returns an instantiated KuzzleDataMapping object\n * @return {object} this\n */\nKuzzleDataCollection.prototype.getMapping = function (options, cb) {\n  var kuzzleMapping;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.getMapping', cb);\n\n  kuzzleMapping = new KuzzleDataMapping(this);\n  kuzzleMapping.refresh(options, cb);\n\n  return this;\n};\n\n/**\n * Publish a realtime message\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} document - either a KuzzleDocument instance or a JSON object\n * @param {object} [options] - optional arguments\n * @param {responseCallback} [cb] - Returns a raw Kuzzle response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.publishMessage = function (document, options, cb) {\n  var data = {};\n\n  if (document instanceof KuzzleDocument) {\n    data = document.serialize();\n  } else {\n    data.body = document;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('write', 'publish'), data, options, cb);\n\n  return this;\n};\n\n/**\n * Replace an existing document with a new one.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to replace\n * @param {object} content - JSON object representing the new document version\n * @param {object} [options] - additional arguments\n * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n * @return {object} this\n */\nKuzzleDataCollection.prototype.replaceDocument = function (documentId, content, options, cb) {\n  var\n    self = this,\n    data = {\n      _id: documentId,\n      body: content\n    };\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs('write', 'createOrReplace'), data, options, function (err, res) {\n      var document;\n\n      if (err) {\n        return cb(err);\n      }\n\n      document = new KuzzleDocument(self, res.result._id, res.result._source);\n      document.version = res.result._version;\n      cb(null, document);\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs('write', 'createOrReplace'), data, options);\n  }\n\n  return this;\n};\n\n/**\n * Subscribes to this data collection with a set of filters.\n * To subscribe to the entire data collection, simply provide an empty filter.\n *\n * @param {object} filters - Filters in Kuzzle DSL format\n * @param {object} [options] - subscriptions options\n * @param {responseCallback} cb - called for each new notification\n * @returns {*} KuzzleRoom object\n */\nKuzzleDataCollection.prototype.subscribe = function (filters, options, cb) {\n  var room;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDataCollection.subscribe', cb);\n\n  room = new KuzzleRoom(this, options);\n\n  return room.renew(filters, cb);\n};\n\n/**\n * Truncate the data collection, removing all stored documents but keeping all associated mappings.\n * This method is a lot faster than removing all documents using a query.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n * @returns {*} this\n */\nKuzzleDataCollection.prototype.truncate = function (options, cb) {\n  var data = {};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.kuzzle.addHeaders(data, this.headers);\n  this.kuzzle.query(this.buildQueryArgs('admin', 'truncateCollection'), data, options, cb);\n\n  return this;\n};\n\n\n/**\n * Update parts of a document\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {string} documentId - Unique document identifier of the document to update\n * @param {object} content - JSON object containing changes to perform on the document\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Returns an instantiated KuzzleDocument object\n * @return {object} this\n */\nKuzzleDataCollection.prototype.updateDocument = function (documentId, content, options, cb) {\n  var\n    data = {\n      _id: documentId,\n      body: content\n    },\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = self.kuzzle.addHeaders(data, this.headers);\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs('write', 'update'), data, options, function (err, res) {\n      var doc;\n      if (err) {\n        return cb(err);\n      }\n\n      doc = new KuzzleDocument(self, res.result._id);\n      doc.refresh(cb);\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs('write', 'update'), data, options);\n  }\n\n  return self;\n};\n\n\n/**\n * Instantiate a new KuzzleDocument object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - document id\n * @param {object} content - document content\n * @constructor\n */\nKuzzleDataCollection.prototype.documentFactory = function (id, content) {\n  return new KuzzleDocument(this, id, content);\n};\n\n/**\n * Instantiate a new KuzzleRoom object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [options] - subscription configuration\n * @constructor\n */\nKuzzleDataCollection.prototype.roomFactory = function (options) {\n  return new KuzzleRoom(this, options);\n};\n\n/**\n * Instantiate a new KuzzleDataMapping object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {object} [mapping] - mapping to instantiate the KuzzleDataMapping object with\n * @constructor\n */\nKuzzleDataCollection.prototype.dataMappingFactory = function (mapping) {\n  return new KuzzleDataMapping(this, mapping);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDataCollection.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = KuzzleDataCollection;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kuzzleDataCollection.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n *  When creating a new data collection in the persistent data storage layer, Kuzzle uses a default mapping.\n *  It means that, by default, you wont be able to exploit the full capabilities of our persistent data storage layer\n *  (currently handled by ElasticSearch), and your searches may suffer from below-average performances, depending on\n *  the amount of data you stored in a collection and the complexity of your database.\n *\n *  The KuzzleDataMapping object allow to get the current mapping of a data collection and to modify it if needed.\n *\n * @param {object} kuzzleDataCollection - Instance of the inherited KuzzleDataCollection object\n * @param {object} mapping - mappings\n * @constructor\n */\nfunction KuzzleDataMapping(kuzzleDataCollection, mapping) {\n  Object.defineProperties(this, {\n    //read-only properties\n    collection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    mapping: {\n      value: mapping || {},\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['set', 'setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Applies the new mapping to the data collection.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleDataMapping.prototype.apply = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({body: {properties: this.mapping}}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.collection.buildQueryArgs('admin', 'updateMapping'), data, options, function (err) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    self.refresh(options, cb);\n  });\n\n  return this;\n};\n\n/**\n * Replaces the current content with the mapping stored in Kuzzle\n *\n * Calling this function will discard any uncommited changes. You can commit changes by calling the apply function\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDataMapping.prototype.refresh = function (options, cb) {\n  var\n    self = this,\n    data = this.kuzzle.addHeaders({}, this.headers);\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('admin', 'getMapping'), data, options, function (err, res) {\n    if (err) {\n      return cb ? cb(err) : false;\n    }\n\n    if (res.result[self.collection.index]) {\n      if (res.result[self.collection.index].mappings[self.collection.collection]) {\n        self.mapping = res.result[self.collection.index].mappings[self.collection.collection].properties;\n\n        // Mappings can be empty. The mapping property should never be \"undefined\"\n        if (self.mapping === undefined) {\n          self.mapping = {};\n        }\n      } else {\n        return cb ? cb(new Error('No mapping found for collection ' + self.collection.collection)) : false;\n      }\n    } else {\n      return cb ? cb(new Error('No mapping found for index ' + self.collection.index)) : false;\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return this;\n};\n\n\n/**\n * Adds or updates a field mapping.\n *\n * Changes made by this function wont be applied until you call the apply method\n *\n * @param {string} field - Name of the field from which the mapping is to be added or updated\n * @param {object} mapping - corresponding field mapping\n * @returns {KuzzleDataMapping}\n */\nKuzzleDataMapping.prototype.set = function (field, mapping) {\n  this.mapping[field] = mapping;\n\n  return this;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDataMapping.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\nmodule.exports = KuzzleDataMapping;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kuzzleDataMapping.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * Kuzzle handles documents either as realtime messages or as stored documents.\n * KuzzleDocument is the object representation of one of these documents.\n *\n * Notes:\n *   - this constructor may be called either with a documentId, a content, neither or both.\n *   - providing a documentID to the constructor will automatically call refresh, unless a content is also provided\n *\n *\n * @param {object} kuzzleDataCollection - an instanciated KuzzleDataCollection object\n * @param {string} [documentId] - ID of an existing document\n * @param {object} [content] - Initializes this document with the provided content\n * @constructor\n */\nfunction KuzzleDocument(kuzzleDataCollection, documentId, content) {\n  Object.defineProperties(this, {\n    // read-only properties\n    collection: {\n      value: kuzzleDataCollection.collection,\n      enumerable: true\n    },\n    dataCollection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    id: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    },\n    content: {\n      value: {},\n      writable: true,\n      enumerable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    version: {\n      value: undefined,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  // handling provided arguments\n  if (!content && documentId && typeof documentId === 'object') {\n    content = documentId;\n    documentId = null;\n  }\n\n  if (content) {\n    if (content._version) {\n      this.version = content._version;\n      delete content._version;\n    }\n    this.setContent(content, true);\n  }\n\n  if (documentId) {\n    Object.defineProperty(this, 'id', {\n      value: documentId,\n      enumerable: true\n    });\n  }\n\n  // promisifying\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['delete', 'refresh', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this document\n */\nKuzzleDocument.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n  data._version = this.version;\n  data = this.kuzzle.addHeaders(data, this.headers);\n\n  return data;\n};\n\n/**\n * Overrides the toString() method in order to return a serialized version of the document\n *\n * @return {string} serialized version of this object\n */\nKuzzleDocument.prototype.toString = function () {\n  return JSON.stringify(this.serialize());\n};\n\n/**\n * Deletes this document in Kuzzle.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.delete = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('KuzzleDocument.delete: cannot delete a document without a document ID');\n  }\n\n  if (cb) {\n    this.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'delete'), this.serialize(), options, function (err) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, self.id);\n    });\n  } else {\n    this.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'delete'), this.serialize(), options);\n  }\n};\n\n/**\n * Replaces the current content with the last version of this document stored in Kuzzle.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.refresh = function (options, cb) {\n  var self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!self.id) {\n    throw new Error('KuzzleDocument.refresh: cannot retrieve a document if no ID has been provided');\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDocument.refresh', cb);\n\n  self.kuzzle.query(self.dataCollection.buildQueryArgs('read', 'get'), {_id: self.id}, options, function (error, res) {\n    var newDocument;\n\n    if (error) {\n      return cb(error);\n    }\n\n    newDocument = new KuzzleDocument(self.dataCollection, self.id, res.result._source);\n    newDocument.version = res.result._version;\n\n    cb(null, newDocument);\n  });\n};\n\n/**\n * Saves this document into Kuzzle.\n *\n * If this is a new document, this function will create it in Kuzzle and the id property will be made available.\n * Otherwise, this method will replace the latest version of this document in Kuzzle by the current content\n * of this object.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {*} this\n */\nKuzzleDocument.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'createOrReplace'), data, options, function (error, res) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    self.id = res.result._id;\n    self.version = res.result._version;\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n/**\n * Sends the content of this document as a realtime message.\n *\n * Takes an optional argument object with the following properties:\n *    - metadata (object, default: null):\n *        Additional information passed to notifications to other users\n *\n * @param {object} [options] - Optional parameters\n * @returns {*} this\n */\nKuzzleDocument.prototype.publish = function (options) {\n  var data = this.serialize();\n\n  this.kuzzle.query(this.dataCollection.buildQueryArgs('write', 'publish'), data, options);\n\n  return this;\n};\n\n/**\n * Replaces the current content with new data.\n * Changes made by this function wont be applied until the save method is called.\n *\n * @param {object} data - New content\n * @param {boolean} replace - if true: replace this document content with the provided data\n */\nKuzzleDocument.prototype.setContent = function (data, replace) {\n  var self = this;\n\n  if (replace) {\n    this.content = data;\n  }\n  else {\n    Object.keys(data).forEach(function (key) {\n      self.content[key] = data[key];\n    });\n  }\n\n  return this;\n};\n\n/**\n * Listens to events concerning this document. Has no effect if the document does not have an ID\n * (i.e. if the document has not yet been created as a persisted document).\n *\n * @param {object} [options] - subscription options\n * @param {responseCallback} cb - callback that will be called each time a change has been detected on this document\n */\nKuzzleDocument.prototype.subscribe = function (options, cb) {\n  var filters;\n\n  if (options && !cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  this.kuzzle.callbackRequired('KuzzleDocument.subscribe', cb);\n\n  if (!this.id) {\n    throw new Error('KuzzleDocument.subscribe: cannot subscribe to a document if no ID has been provided');\n  }\n\n  filters = { ids: { values: [this.id] } };\n\n  return this.dataCollection.subscribe(filters, options, cb);\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleDocument.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n\nmodule.exports = KuzzleDocument;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kuzzleDocument.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n\n/**\n * Kuzzle's memory storage is a separate data store from the database layer.\n * It is internaly based on Redis. You can access most of Redis functions (all\n * lowercased), excepting:\n *   * all cluster based functions\n *   * all script based functions\n *   * all cursors functions\n *\n * For instance:\n *     kuzzle.memoryStorage\n *      .set('myKey', 'myValue')\n *      .get('myKey', function (err, response) {\n *        console.log(response.result);\n *\n *        // { _id: 'foo', body: { value: 'myValue' }}\n *      });\n *\n *\n * @param {object} kuzzle - Kuzzle instance to inherit from\n * @constructor\n */\nfunction KuzzleMemoryStorage(kuzzle) {\n  Object.defineProperties(this, {\n    // read-only properties\n    kuzzle: {\n      value: kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzle.headers)),\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  this.setHeaders = kuzzle.setHeaders.bind(this);\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['setHeaders'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * constructs the memoryStorage functions.\n */\n(function() {\n\n  var\n    keyVal = ['id', 'value'],\n    idOrKeys = ['id', 'keys'],\n    commands = {\n      append: keyVal,\n      bgrewriteaof: [],\n      bgsave: [],\n      bitcount: ['id', 'start', 'end'],\n      bitop: ['operation', 'destkey', idOrKeys],\n      bitpos: ['id', 'bit', { __opts__: ['start', 'end']}],\n      blpop: [idOrKeys, 'timeout'],\n      brpoplpush: ['source', 'destination'],\n      dbsize: [],\n      decrby: keyVal,\n      del: [idOrKeys],\n      discard: [],\n      exec: [],\n      exists: [idOrKeys],\n      expire: ['id', 'seconds'],\n      expireat: ['id', 'timestamp'],\n      flushdb: [],\n      // @todo: implement geolocation methods once available in Redis stable release\n      getbit: ['id', 'offset'],\n      getrange: ['id', 'start', 'end'],\n      hdel: ['id', ['field', 'fields']],\n      hexists: ['id', 'field'],\n      hincrby: ['id', 'field', 'value'],\n      hmset: ['id', 'values'],\n      hset: ['id', 'field', 'value'],\n      info: ['section'],\n      keys: [ 'pattern' ],\n      lastsave: [],\n      lindex: ['id', 'idx'],\n      linsert: ['id', 'position', 'pivot', 'value'],\n      lpush: ['id', ['value', 'values']],\n      lrange: ['id', 'start', 'stop'],\n      lrem: ['id', 'count', 'value'],\n      lset: ['id', 'idx', 'value'],\n      ltrim: ['id', 'start', 'stop'],\n      mset: ['values'],\n      multi: [],\n      object: ['subcommand', 'args'],\n      pexpire: ['id', 'milliseconds'],\n      pexpireat: ['id', 'timestamp'],\n      pfadd: ['id', ['element', 'elements']],\n      pfmerge: ['destkey', ['sourcekey', 'sourcekeys']],\n      ping: [],\n      psetex: ['id', 'milliseconds', 'value'],\n      publish: ['channel', 'message'],\n      randomkey: [],\n      rename: ['id', 'newkey'],\n      renamenx: ['id', 'newkey'],\n      restore: ['id', 'ttl', 'content'],\n      rpoplpush: ['source', 'destination'],\n      sadd: ['id', ['member', 'members']],\n      save: [],\n      set: ['id', 'value', {__opts__:['ex', 'px', 'nx', 'xx']}],\n      sdiffstore: ['destination', idOrKeys],\n      setbit: ['id', 'offset', 'value'],\n      setex: ['id', 'seconds', 'value'],\n      setrange: ['id', 'offset', 'value'],\n      sinterstore: ['destination', idOrKeys],\n      sismember: ['id', 'member'],\n      smove: ['id', 'destination', 'member'],\n      sort: ['id', {__opts__:['by', 'offset', 'count', 'get', 'direction', 'alpha', 'store']}],\n      spop: ['id', 'count'],\n      srem: ['id', ['member', 'members']],\n      sunionstore: ['destination', idOrKeys],\n      unwatch: [],\n      wait: ['numslaves', 'timeout'],\n      zadd: ['id', {__opts__: ['nx', 'xx', 'ch', 'incr', 'score', 'member', 'members']}],\n      zcount: ['id', 'min', 'max'],\n      zincrby: ['id', 'value', 'member'],\n      zinterstore: ['destination', idOrKeys, {__opts__: ['weight', 'weights', 'aggregate']}],\n      zlexcount: ['id', 'min', 'max'],\n      zrange: ['id', 'start', 'stop', {__opts__: ['withscores']}],\n      zrangebylex: ['id', 'min', 'max', {__opts__: ['offset', 'count']}],\n      zrangebyscore: ['id', 'min', 'max', {__opts__: ['withscores', 'offset', 'count']}],\n      zrem: ['id', 'member'],\n      zremrangebylex: ['id', 'min', 'max'],\n      zremrangebyscore: ['id', 'min', 'max'],\n      zrevrangebylex: ['id', 'max', 'min', {__opts__: ['offset', 'count']}],\n      zrevrangebyscore: ['id', 'max', 'min', {__opts__: ['withscores', 'offset', 'count']}],\n      zrevrank: ['id', 'member']\n    };\n\n  // unique argument key\n  commands.decr = commands.get = commands.dump = commands.hgetall = commands.hkeys = commands.hlen = commands.hstrlen = commands.hvals = commands.incr = commands.llen = commands.lpop = commands.persist = commands.pttl = commands.rpop = commands.scard = commands.smembers = commands.strlen = commands.ttl = commands.type = commands.zcard = ['id'];\n\n  // key value\n  commands.getset = commands.lpushx = keyVal;\n\n  // key key...\n  commands.del = commands.exists = commands.mget = commands.pfcount = commands.sdiff = commands.sinter = commands.sunion = commands.watch = [idOrKeys];\n\n  commands.incrby = commands.incrbyfloat = commands.decrby;\n  commands.brpop = commands.blpop;\n  commands.hget = commands.hexists;\n  commands.hmget = commands.hdel;\n  commands.hsetnx = commands.hset;\n  commands.msetnx = commands.mset;\n  commands.rpush = commands.lpush;\n  commands.hincrbyfloat = commands.hincrby;\n  commands.srandmember = commands.spop;\n  commands.zrevrange = commands.zrange;\n  commands.zscore = commands.zrevrank;\n\n  Object.keys(commands).forEach(function (command) {\n    KuzzleMemoryStorage.prototype[command] = function () {\n      var\n        args = Array.prototype.slice.call(arguments),\n        options = null,\n        cb,\n        query = {\n          controller: 'ms',\n          action: command\n        },\n        data = {};\n\n      if (typeof args[args.length - 1] === 'function') {\n        cb = args.pop();\n      }\n\n      if (args.length && typeof args[args.length - 1] === 'object' && Object.keys(args[args.length - 1]).length === 1 && args[args.length - 1].queuable !== undefined) {\n        options = args.pop();\n      }\n\n      commands[command].forEach(function (v, i) {\n        if (args[i] === undefined) {\n          return;\n        }\n\n        if (Array.isArray(v)) {\n          v = Array.isArray(args[i]) ? v[1] : v[0];\n        }\n\n        if (v === 'id') {\n          data._id = args[i];\n        }\n        else {\n          if (!data.body) {\n            data.body = {};\n          }\n\n          if (typeof v === 'object' && v.__opts__ !== undefined) {\n            v.__opts__.forEach(function (arg) {\n              if (args[i][arg] !== undefined) {\n                data.body[arg] = args[i][arg];\n              }\n            });\n          }\n          else {\n            data.body[v] = args[i];\n          }\n        }\n      });\n\n      this.kuzzle.query(query, data, options, cb);\n\n      return this;\n\n    };\n  });\n\n})();\n\nmodule.exports = KuzzleMemoryStorage;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kuzzleMemoryStorage.js\n ** module id = 7\n ** module chunks = 0\n **/","var\n  uuid = require('node-uuid');\n\n/**\n * This is a global callback pattern, called by all asynchronous functions of the Kuzzle object.\n *\n * @callback responseCallback\n * @param {Object} err - Error object, NULL if the query is successful\n * @param {Object} [data] - The content of the query response\n */\n\n/**\n * This object is the result of a subscription request, allowing to manipulate the subscription itself.\n *\n * In Kuzzle, you dont exactly subscribe to a room or a topic but, instead, you subscribe to documents.\n *\n * What it means is that, to subscribe, you provide to Kuzzle a set of matching filters.\n * Once you have subscribed, if a pub/sub message is published matching your filters, or if a matching stored\n * document change (because it is created, updated or deleted), then youll receive a notification about it.\n *\n * @param {object} kuzzleDataCollection - an instantiated and valid kuzzle object\n * @param {object} [options] - subscription optional configuration\n * @constructor\n */\nfunction KuzzleRoom(kuzzleDataCollection, options) {\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    callback: {\n      value: null,\n      writable: true\n    },\n    channel: {\n      value: null,\n      writable: true\n    },\n    id: {\n      value: uuid.v4()\n    },\n    lastRenewal: {\n      value: null,\n      writable: true\n    },\n    notifier: {\n      value: null,\n      writable: true\n    },\n    queue: {\n      value: [],\n      writable: true\n    },\n    // Delay before allowing a subscription renewal\n    renewalDelay: {\n      value: 500\n    },\n    scope: {\n      value: options && options.scope ? options.scope : 'all'\n    },\n    state: {\n      value: options && options.state ? options.state : 'done'\n    },\n    subscribing: {\n      value: false,\n      writable: true\n    },\n    users: {\n      value: options && options.users ? options.users : 'none'\n    },\n    // read-only properties\n    collection: {\n      value: kuzzleDataCollection,\n      enumerable: true\n    },\n    kuzzle: {\n      value: kuzzleDataCollection.kuzzle,\n      enumerable: true\n    },\n    // writable properties\n    filters: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    headers: {\n      value: JSON.parse(JSON.stringify(kuzzleDataCollection.headers)),\n      enumerable: true,\n      writable: true\n    },\n    metadata: {\n      value: (options && options.metadata) ? options.metadata : {},\n      enumerable: true,\n      writable: true\n    },\n    roomId: {\n      value: null,\n      enumerable: true,\n      writable: true\n    },\n    subscribeToSelf: {\n      value: options && typeof options.subscribeToSelf === 'boolean' ? options.subscribeToSelf : true,\n      enumerable: true,\n      writable: true\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['count'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n/**\n * Returns the number of other subscriptions on that room.\n *\n * @param {responseCallback} cb - Handles the query response\n */\nKuzzleRoom.prototype.count = function (cb) {\n  var data;\n\n  this.kuzzle.callbackRequired('KuzzleRoom.count', cb);\n\n  data = this.kuzzle.addHeaders({body: {roomId: this.roomId}}, this.headers);\n\n  if (!isReady.call(this)) {\n    this.queue.push({action: 'count', args: [cb]});\n    return this;\n  }\n\n  if (!this.roomId) {\n    throw new Error('KuzzleRoom.count: cannot count subscriptions on an inactive room');\n  }\n\n  this.kuzzle.query(this.collection.buildQueryArgs('subscribe', 'count'), data, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.count);\n  });\n\n  return this;\n};\n\n/**\n * Renew the subscription using new filters\n *\n * @param {object} [filters] - Filters in Kuzzle DSL format\n * @param {responseCallback} cb - called for each new notification\n */\nKuzzleRoom.prototype.renew = function (filters, cb) {\n  var\n    now = Date.now(),\n    subscribeQuery = {\n      scope: this.scope,\n      state: this.state,\n      users: this.users\n    },\n    self = this;\n\n  if (!cb && filters && typeof filters === 'function') {\n    cb = filters;\n    filters = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleRoom.renew', cb);\n\n  /*\n    Skip subscription renewal if another one was performed a moment before\n   */\n  if (self.lastRenewal && (now - self.lastRenewal) <= self.renewalDelay) {\n    return self;\n  }\n\n  if (filters) {\n    self.filters = filters;\n  }\n\n  /*\n   if not yet connected, register itself to the subscriptions list and wait for the\n   main Kuzzle object to renew once online\n    */\n  if (self.kuzzle.state !== 'connected') {\n    self.callback = cb;\n    self.kuzzle.subscriptions.pending[self.id] = self;\n    return self;\n  }\n\n  if (self.subscribing) {\n    self.queue.push({action: 'renew', args: [filters, cb]});\n    return self;\n  }\n\n  self.unsubscribe();\n  self.roomId = null;\n  self.subscribing = true;\n  self.callback = cb;\n  self.kuzzle.subscriptions.pending[self.id] = self;\n\n  subscribeQuery.body = self.filters;\n  subscribeQuery = self.kuzzle.addHeaders(subscribeQuery, this.headers);\n\n  self.kuzzle.query(self.collection.buildQueryArgs('subscribe', 'on'), subscribeQuery, {metadata: self.metadata}, function (error, response) {\n    delete self.kuzzle.subscriptions.pending[self.id];\n    self.subscribing = false;\n\n    if (error) {\n      self.queue = [];\n      throw new Error('Error during Kuzzle subscription: ' + error.message);\n    }\n\n    self.lastRenewal = now;\n    self.roomId = response.result.roomId;\n    self.channel = response.result.channel;\n\n    if (!self.kuzzle.subscriptions[self.roomId]) {\n      self.kuzzle.subscriptions[self.roomId] = {};\n    }\n\n    self.kuzzle.subscriptions[self.roomId][self.id] = self;\n\n    self.notifier = notificationCallback.bind(self);\n    self.kuzzle.network.on(self.channel, self.notifier);\n\n    dequeue.call(self);\n  });\n\n  return self;\n};\n\n/**\n * Unsubscribes from Kuzzle.\n *\n * Stop listening immediately. If there is no listener left on that room, sends an unsubscribe request to Kuzzle, once\n * pending subscriptions reaches 0, and only if there is still no listener on that room.\n * We wait for pending subscriptions to finish to avoid unsubscribing while another subscription on that room is\n *\n * @return {*} this\n */\nKuzzleRoom.prototype.unsubscribe = function () {\n  var\n    self = this,\n    room = self.roomId,\n    interval;\n\n  if (!isReady.call(this)) {\n    self.queue.push({action: 'unsubscribe', args: []});\n    return self;\n  }\n\n  if (room) {\n    self.kuzzle.network.off(self.channel, this.notifier);\n\n    if (Object.keys(self.kuzzle.subscriptions[room]).length === 1) {\n      delete self.kuzzle.subscriptions[room];\n\n      if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n        self.kuzzle.query(self.collection.buildQueryArgs('subscribe', 'off'), {body: {roomId: room}});\n      } else {\n        interval = setInterval(function () {\n          if (Object.keys(self.kuzzle.subscriptions.pending).length === 0) {\n            if (!self.kuzzle.subscriptions[room]) {\n              self.kuzzle.query(self.collection.buildQueryArgs('subscribe', 'off'), {body: {roomId: room}});\n            }\n            clearInterval(interval);\n          }\n        }, 100);\n      }\n    } else {\n      delete self.kuzzle.subscriptions[room][self.id];\n    }\n\n    self.roomId = null;\n  }\n\n  return self;\n};\n\n/**\n * Helper function allowing to set headers while chaining calls.\n *\n * If the replace argument is set to true, replace the current headers with the provided content.\n * Otherwise, it appends the content to the current headers, only replacing already existing values\n *\n * @param content - new headers content\n * @param [replace] - default: false = append the content. If true: replace the current headers with tj\n */\nKuzzleRoom.prototype.setHeaders = function (content, replace) {\n  this.kuzzle.setHeaders.call(this, content, replace);\n  return this;\n};\n\n/**\n * Callback called by the network handler when a message is sent to the subscribed room ID\n * Calls the registered callback if the notification passes the subscription filters\n *\n * @param {object} data - data\n * @returns {*}\n */\nfunction notificationCallback (data) {\n  if (data.error) {\n    return this.callback(data.error);\n  }\n\n  if (data.action === 'jwtTokenExpired') {\n    this.kuzzle.jwtToken = undefined;\n    return this.kuzzle.emitEvent('jwtTokenExpired');\n  }\n\n  if (this.kuzzle.requestHistory[data.requestId]) {\n    if (this.subscribeToSelf) {\n      this.callback(null, data);\n    }\n    delete this.kuzzle.requestHistory[data.requestId];\n  } else {\n    this.callback(null, data);\n  }\n}\n\n\n/**\n * Dequeue actions performed while subscription was being renewed\n */\nfunction dequeue () {\n  var element;\n\n  while (this.queue.length > 0) {\n    element = this.queue.shift();\n\n    this[element.action].apply(this, element.args);\n  }\n}\n\nfunction isReady() {\n  if (this.kuzzle.state !== 'connected' || this.subscribing) {\n    return false;\n  }\n  return true;\n}\n\nmodule.exports = KuzzleRoom;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/kuzzleRoom.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n *\n * @param host\n * @param wsPort\n * @param ioPort\n * @returns {Object} tnstantiated WebSocket/Socket.IO object\n */\n\nfunction network(host, wsPort, ioPort) {\n  // Web browser / NodeJS websocket handling\n  if (typeof window !== 'undefined') {\n    // use native websockets if the browser supports it\n    if (typeof WebSocket !== 'undefined') {\n      return new (require('./wrappers/wsbrowsers'))(host, wsPort);\n    }\n    // otherwise fallback to socket.io, if available\n    else if (window.io) {\n      return new (require('./wrappers/socketio'))(host, ioPort);\n    }\n\n    throw new Error('Aborting: no websocket support detected and no socket.io library loaded either.');\n  }\n\n  return new (require('./wrappers/wsnode'))(host, wsPort);\n}\n\nmodule.exports = network;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/networkWrapper/index.js\n ** module id = 9\n ** module chunks = 0\n **/","function SocketIO(host, port) {\n  this.host = host;\n  this.port = port;\n  this.socket = null;\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    this.socket = window.io('http://' + this.host + ':' + this.port, {\n      reconnection: autoReconnect,\n      reconnectionDelay: reconnectionDelay,\n      forceNew: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.socket.on('connect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.socket.on('connect_error', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.socket.on('disconnect', callback);\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.socket.on('reconnect', callback);\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    this.socket.once(roomId, callback);\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    this.socket.on(roomId, callback);\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    this.socket.off(roomId, callback);\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    this.socket.emit('kuzzle', payload);\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.socket.close();\n    this.socket = null;\n  };\n}\n\nmodule.exports = SocketIO;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/networkWrapper/wrappers/socketio.js\n ** module id = 10\n ** module chunks = 0\n **/","function WSBrowsers(host, port) {\n  var self = this;\n  this.host = host;\n  this.port = port;\n  this.client = null;\n  this.retrying = false;\n\n  /*\n     Listeners are stored using the following format:\n     roomId: {\n     fn: callback_function,\n     once: boolean\n     }\n   */\n  this.listeners = {\n    error: [],\n    connect: [],\n    disconnect: [],\n    reconnect: []\n  };\n\n  /**\n   * Creates a new socket from the provided arguments\n   *\n   * @constructor\n   * @param {boolean} autoReconnect\n   * @param {int} reconnectionDelay\n   * @returns {Object} Socket\n   */\n  this.connect = function (autoReconnect, reconnectionDelay) {\n    this.client = new WebSocket('ws://' + this.host + ':' + this.port);\n\n    this.client.onopen = function () {\n      if (self.retrying) {\n        poke(self.listeners, 'reconnect');\n      }\n      else {\n        poke(self.listeners, 'connect');\n      }\n    };\n\n    this.client.onclose = function () {\n      poke(self.listeners, 'disconnect');\n    };\n\n    this.client.onerror = function () {\n      if (autoReconnect) {\n        self.retrying = true;\n        setTimeout(function () {\n          self.connect(autoReconnect, reconnectionDelay);\n        }, reconnectionDelay);\n      }\n\n      poke(self.listeners, 'error');\n    };\n\n    this.client.onmessage = function (payload) {\n      var data = JSON.parse(payload.data);\n\n      if (data.room && self.listeners[data.room]) {\n        poke(self.listeners, data.room, data);\n      }\n    };\n  };\n\n  /**\n   * Fires the provided callback whence a connection is established\n   *\n   * @param {function} callback\n   */\n  this.onConnect = function (callback) {\n    this.listeners.connect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a connection error is received\n   * @param {function} callback\n   */\n  this.onConnectError = function (callback) {\n    this.listeners.error.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a disconnection occurred\n   * @param {function} callback\n   */\n  this.onDisconnect = function (callback) {\n    this.listeners.disconnect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Fires the provided callback whenever a connection has been reestablished\n   * @param {function} callback\n   */\n  this.onReconnect = function (callback) {\n    this.listeners.reconnect.push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Registers a callback on a room. Once 1 message is received, fires the\n   * callback and unregister it afterward.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.once = function (roomId, callback) {\n    if (!this.listeners[roomId]) {\n      this.listeners[roomId] = [];\n    }\n\n    this.listeners[roomId].push({\n      fn: callback,\n      keep: false\n    });\n  };\n\n  /**\n   * Registers a callback on a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.on = function (roomId, callback) {\n    if (!this.listeners[roomId]) {\n      this.listeners[roomId] = [];\n    }\n\n    this.listeners[roomId].push({\n      fn: callback,\n      keep: true\n    });\n  };\n\n  /**\n   * Unregisters a callback from a room.\n   *\n   * @param {string} roomId\n   * @param {function} callback\n   */\n  this.off = function (roomId, callback) {\n    var index;\n\n    if (this.listeners[roomId]) {\n      index = this.listeners[roomId].findIndex(function (listener) {\n        return listener.fn === callback;\n      });\n\n      if (index !== -1) {\n        if (this.listeners[roomId].length === 1 && ['error', 'connect', 'disconnect', 'reconnect'].indexOf(roomId) === -1) {\n          delete this.listeners[roomId];\n        }\n        else {\n          this.listeners[roomId].splice(index, 1);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Sends a payload to the connected server\n   *\n   * @param {Object} payload\n   */\n  this.send = function (payload) {\n    if (this.client && this.client.readyState === this.client.OPEN) {\n      this.client.send(JSON.stringify(payload));\n    }\n  };\n\n  /**\n   * Closes the connection\n   */\n  this.close = function () {\n    this.listeners = {\n      error: [],\n      connect: [],\n      disconnect: [],\n      reconnect: []\n    };\n\n    this.retrying = false;\n    this.client.close();\n    this.client = null;\n  };\n}\n\n/**\n * Executes all registered listeners in the provided\n * \"listeners\" structure.\n *\n * Listeners are of the following format:\n * [\n *    { fn: callback, once: boolean },\n *    ...\n * ]\n *\n * @private\n * @param {Object} listeners\n * @param {string} roomId\n * @param {Object} [payload]\n */\nfunction poke (listeners, roomId, payload) {\n  var\n    i,\n    length = listeners[roomId].length;\n\n  for (i = 0; i < length; ++i) {\n    listeners[roomId][i].fn(payload);\n\n    if (!listeners[roomId][i].keep) {\n      if (listeners[roomId].length > 1) {\n        listeners[roomId].splice(i, 1);\n        --i;\n        --length;\n      }\n      else {\n        delete listeners[roomId];\n      }\n    }\n  }\n}\n\nmodule.exports = WSBrowsers;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/networkWrapper/wrappers/wsbrowsers.js\n ** module id = 11\n ** module chunks = 0\n **/","var\n  KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\nfunction KuzzleProfile(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteProfile'\n    },\n    updateActionName: {\n      value: 'updateProfile'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['hydrate', 'save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nKuzzleProfile.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleProfile\n  }\n});\n\n/**\n * Persist to the persistent layer the current profile\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n * @returns {Object} this\n */\nKuzzleProfile.prototype.save = function (options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!this.content.policies) {\n    throw new Error('Argument \"policies\" is mandatory in a profile. This argument contains an array of objects.');\n  }\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = this.serialize();\n\n  self.kuzzle.query(self.kuzzleSecurity.buildQueryArgs('createOrReplaceProfile'), data, options, function (error) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n\n  return self;\n};\n\n\n/**\n * Add a policy in the policies list\n * @param {Object} policy - must be an object containing at least a \"roleId\" member which must be a string.\n *\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.addPolicy = function (policy) {\n\n  if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n    throw new Error('Parameter \"policies\" must be an object containing at least a \"roleId\" member which must be a string.');\n  }\n\n  if (!this.content.policies) {\n    this.content.policies = [];\n  }\n\n  this.content.policies.push(policy);\n\n  return this;\n};\n\n/**\n * Set policies list\n * @param {Array} policies - must be an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @returns {KuzzleProfile} this\n */\nKuzzleProfile.prototype.setPolicies = function (policies) {\n\n  if (!Array.isArray(policies)) {\n    throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n  }\n\n  policies.map(function (policy) {\n    if (typeof policy !== 'object' || typeof policy.roleId !== 'string') {\n      throw new Error('Parameter \"policies\" must be an array of objects containing at least a \"roleId\" member which must be a string');\n    }\n  });\n\n  this.content.policies = policies;\n\n  return this;\n};\n\n/**\n * Serialize this object into a JSON object\n *\n * @return {object} JSON object representing this securityDocument\n */\nKuzzleProfile.prototype.serialize = function () {\n  var\n    data = {};\n\n  if (this.id) {\n    data._id = this.id;\n  }\n\n  data.body = this.content;\n\n  return data;\n};\n\n/**\n * Returns the list of policies associated to this profile.\n * Each policy element is an array of objects containing at least a \"roleId\" member which must be a string\n *\n * @return {object} an array of policies\n */\nKuzzleProfile.prototype.getPolicies = function () {\n  return this.content.policies;\n};\n\nmodule.exports = KuzzleProfile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/security/kuzzleProfile.js\n ** module id = 12\n ** module chunks = 0\n **/","var KuzzleSecurityDocument = require('./kuzzleSecurityDocument');\n\nfunction KuzzleRole(kuzzleSecurity, id, content) {\n\n  KuzzleSecurityDocument.call(this, kuzzleSecurity, id, content);\n\n  // Define properties\n  Object.defineProperties(this, {\n    // private properties\n    deleteActionName: {\n      value: 'deleteRole'\n    },\n    updateActionName: {\n      value: 'updateRole'\n    }\n  });\n\n  // promisifying\n  if (kuzzleSecurity.kuzzle.bluebird) {\n    return kuzzleSecurity.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var whitelist = ['save'];\n\n        return passes && whitelist.indexOf(name) !== -1;\n      }\n    });\n  }\n\n}\n\nKuzzleRole.prototype = Object.create(KuzzleSecurityDocument.prototype, {\n  constructor: {\n    value: KuzzleRole\n  }\n});\n\n/**\n * Saves this role into Kuzzle.\n *\n * If this is a new role, this function will create it in Kuzzle.\n * Otherwise, this method will replace the latest version of this role in Kuzzle by the current content\n * of this object.\n *\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleRole.prototype.save = function (options, cb) {\n  var\n    data = this.serialize(),\n    self = this;\n\n  if (options && cb === undefined && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.query(this.kuzzleSecurity.buildQueryArgs('createOrReplaceRole'), data, options, function (error) {\n    if (error) {\n      return cb ? cb(error) : false;\n    }\n\n    if (cb) {\n      cb(null, self);\n    }\n  });\n};\n\nmodule.exports = KuzzleRole;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/security/kuzzleRole.js\n ** module id = 13\n ** module chunks = 0\n **/","var\n  KuzzleRole = require('./kuzzleRole'),\n  KuzzleProfile = require('./kuzzleProfile'),\n  KuzzleUser = require('./kuzzleUser');\n\n/**\n * Kuzzle security constructor\n *\n * @param kuzzle\n * @returns {KuzzleSecurity}\n * @constructor\n */\nfunction KuzzleSecurity(kuzzle) {\n\n  Object.defineProperty(this, 'kuzzle', {\n    value: kuzzle\n  });\n\n  Object.defineProperty(this, 'buildQueryArgs', {\n    value: function (action) {\n      return {\n        controller: 'security',\n        action: action\n      };\n    }\n  });\n\n  if (this.kuzzle.bluebird) {\n    return this.kuzzle.bluebird.promisifyAll(this, {\n      suffix: 'Promise',\n      filter: function (name, func, target, passes) {\n        var blacklist = ['roleFactory', 'profileFactory', 'userFactory', 'isActionAllowed'];\n\n        return passes && blacklist.indexOf(name) === -1;\n      }\n    });\n  }\n\n  return this;\n}\n\n\n/**\n * Retrieve a single Role using its unique role ID.\n *\n * @param {string} id\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getRole = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id) {\n    throw new Error('Id parameter is mandatory for getRole function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getRole', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getRole'), data, options, function (err, response) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, new KuzzleRole(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on roles according to a filter\n *\n * /!\\ There is a small delay between role creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a role that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `indexes` with a list of index id, a integer `from` and a integer `size`\n * @param {object} [options] - Optional parameters\n * @param {responseCallback} [cb] - returns Kuzzle's response\n *\n */\nKuzzleSecurity.prototype.searchRoles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchRoles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchRoles'), {body: filters}, options, function (error, result) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = result.result.hits.map(function (doc) {\n      return new KuzzleRole(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: result.result.total, roles: documents });\n  });\n};\n\n/**\n * Create a new role in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same role already exists: throw an error if sets to false.\n *        Replace the existing role otherwise\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createRole: cannot create a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceRole' : 'createRole';\n  }\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n      var doc;\n\n      if (err) {\n        return cb(err);\n      }\n\n      doc = new KuzzleRole(self, res.result._id, res.result._source);\n      cb(null, doc);\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs(action), data);\n  }\n};\n\n\n/**\n * Update a role in Kuzzle.\n *\n * @param {string} id - role identifier\n * @param {object} content - a plain javascript object representing the role's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.updateRole = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateRole';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateRole: cannot update a role without a role ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, new KuzzleRole(self, id, content));\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs(action), data);\n  }\n};\n\n/**\n * Delete role.\n *\n * There is a small delay between role deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a role that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Role id to delete\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleSecurity.prototype.deleteRole = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (cb) {\n    this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options, function (err, res) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, res.result._id);\n    });\n  } else {\n    this.kuzzle.query(this.buildQueryArgs('deleteRole'), data, options);\n  }\n};\n\n/**\n * Instantiate a new KuzzleRole object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - role id\n * @param {object} content - role content\n * @constructor\n */\nKuzzleSecurity.prototype.roleFactory = function(id, content) {\n  return new KuzzleRole(this, id, content);\n};\n\n\n/**\n * Get a specific profile from kuzzle\n *\n *\n * @param {string} id\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getProfile = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for getProfile function');\n  }\n\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getProfile', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getProfile'), data, options, function (error, response) {\n    if (error) {\n      return cb(error);\n    }\n\n    cb(null, new KuzzleProfile(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on profiles according to a filter\n *\n *\n * /!\\ There is a small delay between profile creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been created wont be returned by this function.\n *\n * @param {Object} filters - this object can contains an array `roles` with a list of roles id, a integer `from` and a integer `size`\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.searchProfiles = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchProfiles', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchProfiles'), {body: filters}, options, function (error, response) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new KuzzleProfile(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: response.result.total, profiles: documents });\n  });\n};\n\n/**\n * Create a new profile in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same profile already exists: throw an error if sets to false.\n *        Replace the existing profile otherwise\n *\n * @param {string} id - profile identifier\n * @param {object} content - attribute `roles` in `content` must only contains an array of role id\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createProfile = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createProfile: cannot create a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceProfile' : 'createProfile';\n  }\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n      var doc;\n\n      if (err) {\n        return cb(err);\n      }\n\n      doc = new KuzzleProfile(self, res.result._id, res.result._source);\n      cb(null, doc);\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs(action), data);\n  }\n};\n\n\n/**\n * Update a profile in Kuzzle.\n *\n * @param {string} id - profile identifier\n * @param {object} content - a plain javascript object representing the profile's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.updateProfile = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateProfile';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateProfile: cannot update a profile without a profile ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n      var updatedContent = {};\n\n      if (err) {\n        return cb(err);\n      }\n\n      Object.keys(res.result._source).forEach(function (property) {\n        updatedContent[property] = res.result._source[property];\n      });\n\n      cb(null, new KuzzleProfile(self, res.result._id, updatedContent));\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs(action), data);\n  }\n};\n\n/**\n * Delete profile.\n *\n * There is a small delay between profile deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a profile that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleSecurity.prototype.deleteProfile = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (cb) {\n    this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options, function (err, res) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, res.result._id);\n    });\n  } else {\n    this.kuzzle.query(this.buildQueryArgs('deleteProfile'), data, options);\n  }\n};\n\n/**\n * Instantiate a new KuzzleProfile object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - profile id\n * @param {object} content - profile content\n * @constructor\n */\nKuzzleSecurity.prototype.profileFactory = function(id, content) {\n  return new KuzzleProfile(this, id, content);\n};\n\n/**\n * Get a specific user from kuzzle using its unique ID\n *\n * @param {string} id\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} cb - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.getUser = function (id, options, cb) {\n  var\n    data,\n    self = this;\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('Id parameter is mandatory for getUser function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data = {_id: id};\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.getUser', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('getUser'), data, options, function (err, response) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, new KuzzleUser(self, response.result._id, response.result._source));\n  });\n};\n\n/**\n * Executes a search on user according to a filter\n *\n * /!\\ There is a small delay between user creation and their existence in our persistent search layer,\n * usually a couple of seconds.\n * That means that a user that was just been created wont be returned by this function.\n *\n * @param {Object} filters - same filters as documents filters\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - returns Kuzzle's response\n */\nKuzzleSecurity.prototype.searchUsers = function (filters, options, cb) {\n  var\n    self = this;\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('KuzzleSecurity.searchUsers', cb);\n\n  self.kuzzle.query(this.buildQueryArgs('searchUsers'), {body: filters}, options, function (error, response) {\n    var documents;\n\n    if (error) {\n      return cb(error);\n    }\n\n    documents = response.result.hits.map(function (doc) {\n      return new KuzzleUser(self, doc._id, doc._source);\n    });\n\n    cb(null, { total: response.result.total, users: documents });\n  });\n};\n\n/**\n * Create a new user in Kuzzle.\n *\n * Takes an optional argument object with the following property:\n *    - replaceIfExist (boolean, default: false):\n *        If the same user already exists: throw an error if sets to false.\n *        Replace the existing user otherwise\n *\n * @param {string} id - user identifier\n * @param {object} content - attribute `profile` in `content` must only contains the profile id\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.createUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'createUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.createUser: cannot create a user without a user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (options) {\n    action = options.replaceIfExist ? 'createOrReplaceUser' : 'createUser';\n  }\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs(action), data, null, function (err, res) {\n      var doc;\n\n      if (err) {\n        return cb(err);\n      }\n\n      doc = new KuzzleUser(self, res.result._id, res.result._source);\n      cb(null, doc);\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs(action), data);\n  }\n};\n\n\n/**\n * Update an user in Kuzzle.\n *\n * @param {string} id - user identifier\n * @param {object} content - a plain javascript object representing the user's modification\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - (optional) Handles the query response\n */\nKuzzleSecurity.prototype.updateUser = function (id, content, options, cb) {\n  var\n    self = this,\n    data = {},\n    action = 'updateUser';\n\n  if (!id || typeof id !== 'string') {\n    throw new Error('KuzzleSecurity.updateUser: cannot update an user without an user ID');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  data._id = id;\n  data.body = content;\n\n  if (cb) {\n    self.kuzzle.query(this.buildQueryArgs(action), data, options, function (err, res) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, new KuzzleUser(self, res.result._id, res.result._source));\n    });\n  } else {\n    self.kuzzle.query(this.buildQueryArgs(action), data, options);\n  }\n};\n\n/**\n * Delete user.\n *\n * There is a small delay between user deletion and their deletion in our advanced search layer,\n * usually a couple of seconds.\n * That means that a user that was just been delete will be returned by this function\n *\n *\n * @param {string} id - Profile id to delete\n * @param {object} [options] - (optional) arguments\n * @param {responseCallback} [cb] - Handles the query response\n */\nKuzzleSecurity.prototype.deleteUser = function (id, options, cb) {\n  var data = {_id: id};\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  if (cb) {\n    this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options, function (err, res) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, res.result._id);\n    });\n  } else {\n    this.kuzzle.query(this.buildQueryArgs('deleteUser'), data, options);\n  }\n};\n\n/**\n * Instantiate a new KuzzleUser object. Workaround to the module.exports limitation, preventing multiple\n * constructors to be exposed without having to use a factory or a composed object.\n *\n * @param {string} id - user id\n * @param {object} content - user content\n * @constructor\n */\nKuzzleSecurity.prototype.userFactory = function(id, content) {\n  return new KuzzleUser(this, id, content);\n};\n\n/**\n * Tells whether an action is allowed, denied or conditional based on the rights\n * rights provided as the first argument. An action is defined as a couple of\n * action and controller (mandatory), plus an index and a collection(optional).\n *\n * @param {object} rights - The rights rights associated to a user\n *                            (see getMyrights and getUserrights).\n * @param {string} controller - The controller to check the action onto.\n * @param {string} action - The action to perform.\n * @param {string} index - (optional) The name of index to perform the action onto.\n * @param {string} collection - (optional) The name of the collection to perform the action onto.\n *\n * @returns {string} ['allowed', 'denied', 'conditional'] where conditional cases\n *                   correspond to rights containing closures.\n *                   See also http://kuzzle.io/guide/#roles-definition\n */\nKuzzleSecurity.prototype.isActionAllowed = function(rights, controller, action, index, collection) {\n  var filteredRights;\n\n  if (!rights || typeof rights !== 'object') {\n    throw new Error('rights parameter is mandatory for isActionAllowed function');\n  }\n  if (!controller || typeof controller !== 'string') {\n    throw new Error('controller parameter is mandatory for isActionAllowed function');\n  }\n  if (!action || typeof action !== 'string') {\n    throw new Error('action parameter is mandatory for isActionAllowed function');\n  }\n\n  // We filter in all the rights that match the request (including wildcards).\n  filteredRights = rights.filter(function (right) {\n    return right.controller === controller || right.controller === '*';\n  })\n  .filter(function (right) {\n    return right.action === action || right.action === '*';\n  })\n  .filter(function (right) {\n    return right.index === index || right.index === '*';\n  })\n  .filter(function (right) {\n    return right.collection === collection || right.collection === '*';\n  });\n\n  // Then, if at least one right allows the action, we return 'allowed'\n  if (filteredRights.some(function (item) { return item.value === 'allowed'; })) {\n    return 'allowed';\n  }\n  // If no right allows the action, we check for conditionals.\n  if (filteredRights.some(function (item) { return item.value === 'conditional'; })) {\n    return 'conditional';\n  }\n  // Otherwise we return 'denied'.\n  return 'denied';\n};\n\n\n/**\n * Gets the rights array of a given user.\n *\n * @param {string} userId The id of the user.\n * @param {object} [options] - (optional) arguments\n * @param {function} cb   The callback containing the normalized array of rights.\n */\nKuzzleSecurity.prototype.getUserRights = function (userId, options, cb) {\n  var\n    data = {_id: userId},\n    self = this;\n\n  if (!userId || typeof userId !== 'string') {\n    throw new Error('userId parameter is mandatory for getUserRights function');\n  }\n\n  if (!cb && typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n\n  self.kuzzle.callbackRequired('Kuzzle.getUserRights', cb);\n\n  this.kuzzle.query(this.buildQueryArgs('getUserRights'), data, options, function (err, res) {\n    if (err) {\n      return cb(err);\n    }\n\n    cb(null, res.result.hits);\n  });\n};\n\nmodule.exports = KuzzleSecurity;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/security/kuzzleSecurity.js\n ** module id = 14\n ** module chunks = 0\n **/"],"sourceRoot":""}